<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Практика преподавания и изучения программирования преимущественно на базе императивных языков (включая объектно-ориентированные императивные языки) приводит к тому, что такой фундаментальный алгоритмический механизм, как рекурсия, остаётся плохо понятным многими программистами и порождает заблуждения, транслируемые в популярной культуре. Попытаемся внести в вопрос немного ясности и изложить некоторые свои мысли по этому поводу.</p>
   <p><strong>Что такое рекурсия?</strong></p>
   <p>Что такое рекурсия в бытовом понимании? Это решение задачи через сведение её к самой себе в более простых условиях.</p>
   <p>Допустим, мы туристы, и перед нами стоит задача попытаться найти в&nbsp;доставшемся нам рюкзаке с&nbsp;едой банку тушёнки. Проверим, пустой&nbsp;ли рюкзак. Если пустой, задача решена, тушёнки нет. Иначе вынимаем из&nbsp;рюкзака первый попавшийся предмет. Если это банка тушёнки, задача решена, тушёнка найдена. Иначе повторяем весь наш алгоритм для&nbsp;имеющегося теперь у&nbsp;нас полегчавшего рюкзака с&nbsp;оставшимся содержимым, и результат решения задачи при этом откладывается на следующий шаг.</p>
   <p>Этот пример рекурсии поймёт и маленький ребёнок, а программисты заметят, что это по существу задача поиска элемента в односвязном списке.</p>
   <p>Рекурсия сама по себе представляет просто один из возможных способов описания повторяющихся действий. Цикл всегда может быть описан в виде рекурсии. Рекурсия может быть описана в виде конечного числа циклов, но это иногда может потребовать дополнительной структуры данных, хранящей последовательность рекурсивных вызовов.</p>
   <p><strong>Определения</strong></p>
   <p>Формально введём некоторые определения. Вопрос далеко не нов, поэтому возьмём определения из достаточно академичных источников, таких как [Friedman1975] и [Хювёнен1990]. В математике рекурсия рассматривается в теории рекурсивных функций, являющейся одним из формализмов теории алгоритмов, поэтому определения многих терминов имеют базу в виде очень чётко заданных математических понятий.</p>
   <p><em>Рекурсия</em> – использование самого себя. Также для простоты словом рекурсия называют рекурсивный вызов.</p>
   <p><em>Рекурсивный вызов</em> – прямой или опосредованный вызов функцией самой себя.</p>
   <p><em>Простая рекурсия</em> – рекурсивный вызов, встречающийся не более одного раза в каждой ветви кода функции. Чандра в [Chandra1972] показал, что простая рекурсия всегда может быть сведена компилятором к итеративному циклу, в дальнейшем этот результат был улучшен, что описано ниже.</p>
   <p><em>Терминальная ветвь</em> – ветвь кода рекурсивной функции, завершающая его без дальнейших рекурсивных вызовов.</p>
   <p><em>Бесконечная рекурсия</em> – последовательность рекурсивных вызовов, никогда не выходящая на терминальную ветвь.</p>
   <p><em>Параллельная рекурсия</em> – рекурсия, встречающаяся несколько раз в одной ветви кода функции.</p>
   <p><em>Взаимная рекурси</em>я – вызов двумя или более функциями друг друга.</p>
   <p><em>Рекурсия по значению</em> – рекурсивный вызов, определяющий результат функции.</p>
   <p><em>Рекурсия по аргументам</em> – рекурсивный вызов, участвующий в вычислении аргументов функции.</p>
   <p><em>Рекурсия высокого порядка</em> – случай, когда в определении функции рекурсивный вызов является аргументом вызова этой же самой функции. Обратите внимание, что рекурсия высокого порядка не имеет никакого отношения к функциям высокого порядка. При помощи рекурсии порядка N могут быть описаны вычисления в N+1 вложенных циклах, однако обратное не всегда верно.</p>
   <p><em>Порядок рекурсии</em> – уровень, на котором находится вызов в рекурсии высокого порядка. Обычные используемые на практике случаи рекурсии содержат рекурсивные вызовы нулевого порядка.</p>
   <p><em>Стилизованная рекурсивная функция</em> – некий специальный вид рекурсивной функции нулевого порядка, более общий, чем простая рекурсия, и удовлетворяющий семи требованиям, описанным в статье [Friedman1975] (желающие могут прочитать их по ссылке ниже). Авторы показывают, что стилизованная функция всегда может быть сведена компилятором к итеративному циклу.</p>
   <p>Далее приведены строго не определённые понятия.</p>
   <p><em>Хвостовая рекурсия</em> – простая рекурсия, рекурсивный вызов в которой находится в конце кода функции. Многие источники в интернете называют хвостовой рекурсией только такие вызовы, которые непосредственно предшествуют возврату из функции (назовём это <em>хвостовой рекурсией I</em>), в то время как другие интерпретируют хвостовую рекурсию более широко, понимая её как однократный рекурсивный вызов где-либо в последней линейной ветке кода (назовём это <em>хвостовой рекурсией II</em>), или как простую рекурсию.</p>
   <p><em>Оптимизация хвостовой рекурсии</em>, или <em>оптимизация хвостового вызова</em> – преобразование транслятором хвостового вызова функции (необязательно рекурсивного) в линейный (циклический) код. Здесь опять-таки широк диапазон интерпретаций, начиная от простой замены пары команд <em>call/ret</em> на <em>jmp</em> (которая в том числе устраняет хвостовую рекурсию I) и заканчивая более сложными оптимизациями хвостовой рекурсии II и простой рекурсии.</p>
   <p><strong>Применение определений</strong></p>
   <p>Наш бытовой пример с тушёнкой в рюкзаке представлял собой простую рекурсию с двумя терминальными ветвями и хвостовой рекурсией. Заметим, что рекурсивный код всегда начинается с терминальных ветвей, иначе исполнение программы погрузится в бесконечную рекурсию и никогда до них не дойдёт.</p>
   <p>Напишем псевдокод на языке Лисп для наших туристов, чтобы они точно понимали, что делать, проснувшись утром голодными и не помнящими, что у них в рюкзаках:</p>
   <pre><code class="lisp">(defun ищемТушёнку (рюкзак)
  (cond 
    ((null рюкзак) nil)
    ((тушёнка? (car рюкзак)) (car рюкзак))
    (t (ищемТушёнку (cdr рюкзак)))))</code></pre>
   <p>Здесь мы определили функцию <em>ищемТушёнку</em> от параметра-списка <em>рюкзак.</em> Её тело состоит из условного оператора <em>cond</em>, имеющего две терминальные и одну рекурсивную ветку. Рюкзак проверяется на пустоту, затем первый элемент рюкзака <em>(car рюкзак)</em> проверяется специальным предикатом, не тушёнка ли это, затем по третьей ветви, которая предваряется тождественно истинным к этому моменту условием <em>t,</em> уходим на рекурсивный вызов с остатком списка <em>(cdr рюкзак).</em></p>
   <p>Если есть желание довести дело до компьютерного исполняемого кода, определим также наш предикат:</p>
   <pre><code class="lisp">(defun тушёнка? (x) (eq x 'тушёнка))</code></pre>
   <p>Прямо в таком виде это можно ввести в GNU Common Lisp или SBCL и искать тушёнку.</p>
   <pre><code class="lisp">(ищемТушёнку '(носки хлеб учебникЛиспа штопор
               тушёнка смартфон ноутбук
               шишка шишка кирпич носовойПлаток
               нож кредитка конфета бумажка
               зубочистка непонятныйМусор))

ТУШЁНКА</code></pre>
   <p>Код здесь написан в чисто функциональном стиле, не содержит переменных и присваиваний, что эффективно с точки зрения распределения памяти в статической секции и в куче.</p>
   <p><strong>Эффективность рекурсии</strong></p>
   <p>Многие программисты считают, что рекурсия неэффективна, так как поедает место на стеке, и ей не место в продуктовом коде. Так ли это?</p>
   <p>Безусловно, всякий инструмент нужно применять по назначению, и для перебора чисел от 1 до N, наверное, не надо использовать рекурсивный вызов. Тем не менее, так ли ужаcна рекурсия по сравнению с итерированным циклом?</p>
   <p>Современные 64-разрядные системы программирования обычно без труда позволяют распределять до гигабайтов адресного пространства в стековой памяти. Этого хватит буквально на миллиарды вложенных рекурсивных вызовов. Вряд ли когда-нибудь вам понадобится рекурсия такой глубины, и даже если да, то основной проблемой, скорее всего, станет процессорное время, а не стековая память. Цикл с содержательным смыслом на миллиард итераций – это дело серьёзное. Тем не менее, проблема со стеком всё-таки есть, и о ней необходимо помнить.</p>
   <p>Однако, как следует из приводившихся выше определений, всякая стилизованная рекурсия и тем более всякая простая рекурсия приводима к виду итеративного цикла. Многие трансляторы об этом знают, в большем или меньшем объёме.</p>
   <p>Часто использующимся в компиляторах приёмом оптимизации является оптимизация хвостовой рекурсии, или tail call (tail recursion) optimization. Многим программистам известно, что обычно трансляторы преобразуют хвостовую рекурсию I в эквивалентный цикл, поэтому такая задача, как наш поиск в рюкзаке, после оптимизации не будет занимать место на стеке по мере продвижения в глубины рюкзака.</p>
   <p>Однако, интернет полон мнений, что способность компилятора к оптимизации хвостовой рекурсии исчерпывается заменой пары команд call/ret на команду jmp. Поэтому, якобы, даже обычная функция факториала в виде</p>
   <pre><code class="lisp">(defun fact (n)
  (cond
    ((zerop n) 1)
    (t (* n (fact (- n 1))))))</code></pre>
   <p>непригодна к оптимизации и вызовет разрушительный рост стека, так как после рекурсивного вызова остаётся выполнить ещё умножение, и код функции, таким образом, не представляет собой хвостовую рекурсию I. Дальше разделяющие такое мнение люди предлагают "оптимизировать" этот факториал, передавая умножаемые значения вторым параметром.</p>
   <p>В действительности, например, у [Penman2018] <a href="https://tristanpenman.com/blog/posts/2018/12/08/tail-call-optimisation-and-c-cpp/" rel="noopener noreferrer nofollow">разобран</a> пример компиляции соответствующего кода в C/C++ и показано, что хвостовая рекурсия II оптимизируется и заменяется на цикл современным компилятором. Попытки выполнить такую оптимизацию вручную ни к чему не приводят на уровне машинного кода и только затрудняют понимание исходного текста.</p>
   <p>В общем-то, уже на уровне здравого смысла понятно, что вычисления, записанные в коде после вызова хвостовой рекурсии II, можно переместить из эпилога получаемого цикла в пролог его следующей итерации, чем свести задачу к хвостовой рекурсии I.</p>
   <p>На практике оказывается, что компиляторы популярных для вычислений языков (Си/Си++, Фортран) как правило, обеспечивают глубокую оптимизацию хвостовой рекурсии при включённой оптимизации. Трансляторы Лиспа оптимизируют хвостовую рекурсию в разной степени. Трансляторы Джавы и Питона не оптимизирует хвостовую рекурсию по принципиальным соображениям, так как разработчики считают важным сохранять исходную трассировку вызовов.</p>
   <p>Оптимизация некоторых рекурсивных вычислительных процессов также может может быть достигнута путём применения механизма мемоизации.</p>
   <p>Наконец, вновь надо вернуться к обстоятельству, что уже значение <em>(fact 1000)</em> занимает целый экран цифрами получившегося числа, а в стеке набирается всего 1000 элементов.</p>
   <p><strong>Кошмары высокого порядка</strong></p>
   <p>Рассмотрим теперь действительно не оптимизируемую автоматически рекурсивную функцию, например, крайне вычислительно ёмкую функцию Аккермана с рекурсией первого порядка, быстро уходящей на огромную глубину. Цитируется по [Хювяйнен1990]:</p>
   <pre><code class="lisp">(defun аккерман (m n)
  (cond
    ((= m 0) (+ n 1))
    ((= n 0) (аккерман (- m 1) 1))
    (t (аккерман (- m 1) (аккерман m (- n 1))))))</code></pre>
   <p>Значение <em>(аккерман 4 1)</em> считается на моём компьютере в SBCL за 16 секунд с занятым стеком менее 4 мегабайт, то есть стек расходуется со скоростью 256 килобайт в секунду. Таким образом, 4-гигабайтного стека хватило бы на 4.5 часа вычислений рекурсивной функции, ничего по существу не делающей, кроме углубления своей рекурсии. (Для завершённости заметим, что значение <em>(аккерман 4 2)</em> вычислить брутфорсом через её рекурсивное определение пока не в человеческих силах, хотя имеется более быстрый альтернативный алгоритм [Grossman1988]; и полагаем совершенно невероятным, чтобы кому-либо в практических целях понадобился вычислительный процесс, описываемый рекурсией второго и более порядка).</p>
   <p><strong>Вывод</strong></p>
   <p>Так как это статья о рекурсии, то вывод заключается в том, что выводы представлены в самой этой статье о рекурсии.</p>
   <p><strong>Литература</strong></p>
   <p>[Хювёнен1990] Э. Хювёнен, Й. Сеппянен. Мир&nbsp;Лиспа. М.: Мир, 1990.</p>
   <p>[Chandra1972] A. Chandra. Efficient compilation of linear recursive programs. Stanford AI project, STAN‑CS-72–282, 1972.</p>
   <p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiG44Xn7p_9AhUFp4sKHXEdD9wQFnoECA0QAQ&amp;url=https%3A%2F%2Flegacy.cs.indiana.edu%2Fftp%2Ftechreports%2FTR19.pdf&amp;usg=AOvVaw2pmaFY11i7I63JzzIMsMWw" rel="noopener noreferrer nofollow">[Friedman1975] D. Friedman, D. Wise. Unwinding stylized recursions into iterations // Indiana Univ., 1975.</a></p>
   <p><a href="https://www.sciencedirect.com/science/article/pii/0304397588900461?ref=pdf_download&amp;fr=RR-9&amp;rr=79bdcd617c2e0065" rel="noopener noreferrer nofollow">[Grossman1988] J. Grossman, R. Zeitman. An inherently iterative computation of Ackermann's function // Theoretical Computer Science Vol. 57 Issues 2-3,&nbsp;May 1988, pp. 327-330</a></p>
   <p><a href="https://tristanpenman.com/blog/posts/2018/12/08/tail-call-optimisation-and-c-cpp/" rel="noopener noreferrer nofollow">[Penman2018] T. Penman. Tail Call Optimisation and C / C++</a></p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->