<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Время запуска приложения является важным показателем для&nbsp;пользователей, поскольку это их первое взаимодействие с&nbsp;приложением, и даже незначительные улучшения могут иметь значительные преимущества для&nbsp;пользователей. Первые впечатления являются важным фактором конверсии потребителей, а&nbsp;время запуска часто указывает на&nbsp;общее качество приложения. Кроме того, другие компании обнаружили, что <a href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales" rel="noopener noreferrer nofollow">увеличение задержки равнозначно снижению продаж</a>.</p>
   <p>В&nbsp;DoorDash мы очень серьезно относимся к&nbsp;скорости запуска приложений. Мы одержимы оптимизацией опыта наших клиентов и постоянными улучшениями.</p>
   <p>В&nbsp;этой статье мы рассмотрим три отдельные оптимизации, которые сократили время, необходимое для&nbsp;запуска нашего потребительского приложения для&nbsp;iOS, на <strong>60%</strong>. Мы определили эти возможности, используя проприетарные инструменты повышения производительности, но&nbsp;инструменты Xcode или&nbsp;DTrace также могут&nbsp;быть подходящими альтернативами.</p>
   <h3>Изменение String(describing:) на ObjectIdentifier()</h3>
   <p>В начале 2022 года наш путь оптимизации запуска приложений начался с визуализации основных узких мест с помощью инструмента анализа производительности&nbsp;<a href="https://www.emergetools.com/" rel="noopener noreferrer nofollow">Emerge Tools</a>, как показано на рис. 1.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/462/b97/ac8/462b97ac8283a33189a5d8a8665c927f.webp" alt="Рис. 1. Трассировка стека, показывающая три возможности оптимизации производительности" title="Рис. 1. Трассировка стека, показывающая три возможности оптимизации производительности" width="1024" height="358">
    <figcaption>
     Рис. 1. Трассировка стека, показывающая три возможности оптимизации производительности
    </figcaption>
   </figure>
   <p>Этот инструмент производительности помог продемонстрировать неоптимизированные ветки как&nbsp;с&nbsp;высоты птичьего полёта, так и с&nbsp;подробностями. Одним из&nbsp;самых больших отличий&nbsp;было время, которое мы потратили на <a href="https://github.com/apple/swift/blob/244ca4e2426260e7b9161c2fd6534dc350983cdf/stdlib/public/runtime/ProtocolConformance.cpp#L970" rel="noopener noreferrer nofollow">Swift protocol conformance checks</a> (проверка соответствия типа протоколу). Но&nbsp;почему?</p>
   <p>Архитектурные принципы, такие как&nbsp;принцип единой ответственности, разделение задач и другие, являются ключевыми в&nbsp;том, как&nbsp;мы пишем код в&nbsp;DoorDash. Службы и зависимости часто внедряются и описываются по&nbsp;их типу. Проблема в&nbsp;том, что&nbsp;мы использовали <a href="https://developer.apple.com/documentation/swift/string/init(describing:)-67ncf" rel="noopener noreferrer nofollow">String(describing:)</a> для&nbsp;идентификации служб, что&nbsp;привело к&nbsp;снижению производительности во&nbsp;время выполнения из‑за проверки того, соответствует&nbsp;ли тип различным другим протоколам. Трассировка стека на&nbsp;рис. 2&nbsp;взята непосредственно из&nbsp;запуска нашего приложения, чтобы продемонстрировать это.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/c4c/615/095/c4c615095d906815cbd06567cbff4930.webp" alt="Рис. 2. Трассировка стека того, что происходит за кулисами API String(describing:)" title="Рис. 2. Трассировка стека того, что происходит за кулисами API String(describing:)" width="1024" height="308">
    <figcaption>
     Рис. 2. Трассировка стека того, что происходит за кулисами API String(describing:)
    </figcaption>
   </figure>
   <p>Первый вопрос, который мы задали себе,&nbsp;был: «Действительно&nbsp;ли нам нужна строка для&nbsp;идентификации типа?» Устранение требования к&nbsp;строке и переход на&nbsp;идентификацию типов с&nbsp;использованием вместо этого ObjectIdentifier, который является простым <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/ObjectIdentifier.swift#L63" rel="noopener noreferrer nofollow">указателем на&nbsp;тип</a>, позволил сократить время запуска приложения на <strong>11%</strong>. Мы также применили эту технику к&nbsp;другим областям, где вместо необработанной строки&nbsp;было достаточно указателя, что&nbsp;дало дополнительное улучшение на <strong>11%</strong>.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/b00/f6a/a7a/b00f6aa7a3bfbc1423ebccfb4db6989b.webp" alt="" title="" width="690" height="60">
    <figcaption></figcaption>
   </figure>
   <p>Если возможно использовать необработанный указатель на&nbsp;тип вместо использования <a href="https://developer.apple.com/documentation/swift/string/init(describing:)-67ncf" rel="noopener noreferrer nofollow">String(describing:)</a>, мы рекомендуем внести такое&nbsp;же изменение, чтобы сэкономить на&nbsp;задержке.</p>
   <h3>Прекратите преобразовывать ненужные объекты в AnyHashable</h3>
   <p>В&nbsp;DoorDash мы инкапсулируем действия пользователя, сетевые запросы, мутации данных и другие вычислительные рабочие нагрузки в (то, что&nbsp;мы называем) команды. Например, когда мы загружаем меню магазина, мы отправляем его как&nbsp;запрос механизму выполнения команд. Затем механизм сохранит команду в&nbsp;массиве обработки и последовательно выполнит входящие команды. Структурирование наших операций, таким образом, является ключевой частью нашей новой архитектуры, где мы намеренно изолируем прямые мутации и вместо этого наблюдаем за&nbsp;результатами ожидаемых действий.</p>
   <p>Эта оптимизация началась с&nbsp;переосмысления того, как&nbsp;мы идентифицируем команды и генерируем их <a href="https://computersciencewiki.org/index.php/Hashing" rel="noopener noreferrer nofollow">хеш‑значения</a>. Наш массив обработки и другие зависимости полагаются на&nbsp;уникальное хэш‑значение для&nbsp;идентификации и разделения соответствующих команд. Исторически сложилось так, что&nbsp;мы избегали необходимости думать о&nbsp;хэшировании, используя <a href="https://developer.apple.com/documentation/swift/anyhashable" rel="noopener noreferrer nofollow">AnyHashable</a>. Однако, <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/AnyHashable.swift#L133" rel="noopener noreferrer nofollow">как&nbsp;указано в&nbsp;стандарте Swift</a>, это&nbsp;было опасно, поскольку использование хэш‑значений, предоставляемых AnyHashable, могло меняться между релизами.</p>
   <p>Мы могли&nbsp;бы оптимизировать нашу стратегию хеширования несколькими способами, но&nbsp;мы начали с&nbsp;переосмысления наших первоначальных ограничений и границ. Первоначально хеш‑значение команды представляло собой комбинацию связанных с&nbsp;ней членов. Это решение&nbsp;было принято намеренно, поскольку мы хотели сохранить гибкую и мощную абстракцию команд. Но&nbsp;после повсеместного внедрения новой архитектуры мы заметили, что&nbsp;выбор дизайна&nbsp;был преждевременным и в&nbsp;целом остался неиспользованным. Изменение этого требования для&nbsp;идентификации команд по&nbsp;их типу привело к&nbsp;ускорению запуска приложений на <strong>29%</strong>, ускорению выполнения команд на <strong>55%</strong> и ускорению регистрации команд на <strong>20%</strong>.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/33e/344/93f/33e34493f96c9a4318388e814a3fa68d.webp" alt="" title="" width="695" height="59">
    <figcaption></figcaption>
   </figure>
   <h3>Аудит инициализаторов сторонних фреймворков</h3>
   <p>В&nbsp;DoorDash мы стремимся&nbsp;быть свободными от&nbsp;сторонних зависимостей, где это возможно. Тем не&nbsp;менее,&nbsp;бывают случаи, когда пользовательский опыт может значительно выиграть от&nbsp;интеграции сторонних продуктов. Несмотря на&nbsp;это, мы проводим несколько тщательных проверок того, как&nbsp;сторонние зависимости влияют на&nbsp;наши услуги и качество, которые мы поддерживаем.</p>
   <p>Недавний аудит показал, что&nbsp;из‑за определённой сторонней платформы наше iOS‑приложение запускается примерно на 200&nbsp;мс медленнее. Одна только эта структура занимала примерно <strong>40%</strong> (!) времени запуска нашего приложения, как&nbsp;показано на&nbsp;рис. 3.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/080/7da/ab2/0807daab2a14b45440091c41b458d67f.webp" alt="Рис. 3. “Пламенная” диаграмма, показывающая примерно 200 мс времени запуска нашего приложения, возникла из-за того, что сторонний фреймворк итерировал наш&nbsp;NSBundle." title="Рис. 3. “Пламенная” диаграмма, показывающая примерно 200 мс времени запуска нашего приложения, возникла из-за того, что сторонний фреймворк итерировал наш&nbsp;NSBundle." width="1024" height="417">
    <figcaption>
     Рис. 3. “Пламенная” диаграмма, показывающая примерно 200 мс времени запуска нашего приложения, возникла из-за того, что сторонний фреймворк итерировал наш&nbsp;NSBundle.
    </figcaption>
   </figure>
   <p>Чтобы усложнить ситуацию, рассматриваемая структура&nbsp;была ключевой частью обеспечения положительного потребительского опыта. Так что&nbsp;мы можем сделать? Как&nbsp;нам сбалансировать один аспект клиентского опыта с&nbsp;быстрым временем запуска приложения?</p>
   <p>Как&nbsp;правило, хороший подход заключается в&nbsp;том, чтобы начать с&nbsp;переноса любых ресурсоемких функций запуска на&nbsp;более позднюю часть процесса запуска и переоценки оттуда. В&nbsp;нашем случае мы вызывали или&nbsp;ссылались на&nbsp;классы в&nbsp;фреймворке намного позже в&nbsp;процессе, но&nbsp;фреймворк всё ещё блокировал время запуска. Почему?</p>
   <p>Когда приложение запускается и загружается в&nbsp;память, за&nbsp;его подготовку отвечает динамический компоновщик (dyld). Одним из&nbsp;шагов dyld является сканирование динамически связанных фреймворков и вызов любых функций инициализации модулей, которые могут&nbsp;быть у&nbsp;него. dyld делает это, определяя типы разделов, помеченные 0×9&nbsp;(<a href="https://opensource.apple.com/source/xnu/xnu-792/EXTERNAL_HEADERS/mach-o/loader.h" rel="noopener noreferrer nofollow">S_MOD_INIT_FUNC_POINTERS</a>), обычно расположенные в&nbsp;сегменте «__DATA».</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/4d1/568/a47/4d1568a47417b9b6146daa7397017bd5.webp" alt="" title="" width="699" height="294">
    <figcaption></figcaption>
   </figure>
   <p>После обнаружения dyld устанавливает логическую переменную в&nbsp;значение true и вскоре после этого вызывает инициализаторы в&nbsp;другой фазе.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/getpro/habr/upload_files/e1d/716/615/e1d716615c532965095409cb090148c3.webp" alt="" title="" width="1024" height="332">
    <figcaption></figcaption>
   </figure>
   <p>Рассматриваемая сторонняя структура имела в&nbsp;общей сложности девять инициализаторов модулей, которым всем из‑за dyld&nbsp;было разрешено работать до&nbsp;того, как&nbsp;наше приложение запустило main(). Эти девять инициализаторов относятся к&nbsp;общей стоимости, которая задержала запуск нашего приложения. Итак, как&nbsp;мы это исправим?</p>
   <p>Есть несколько способов исправить задержку. Популярным вариантом является использование <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html" rel="noopener noreferrer nofollow">dlopen </a>и написание интерфейса‑оболочки для&nbsp;функций, которые ещё предстоит разрешить. Однако этот метод означал потерю безопасности компилятора, поскольку компилятор больше не&nbsp;мог гарантировать, что&nbsp;определённая функция будет существовать в&nbsp;среде во&nbsp;время компиляции. У&nbsp;этого варианта есть и <a href="https://www.mailerq.com/blog/good-reasons-to-use-dlopen#:~:text=The%20downside%20of%20dlopen(),manage%20pointer-to-functions." rel="noopener noreferrer nofollow">другие минусы</a>, но&nbsp;безопасность компиляции значила для&nbsp;нас больше всего.</p>
   <p>Мы также связались со сторонними разработчиками и попросили их преобразовать инициализатор модуля в&nbsp;простую функцию, которую мы могли&nbsp;бы вызывать на&nbsp;досуге. Они, к&nbsp;сожалению, еще не&nbsp;ответили нам.</p>
   <p>Вместо этого мы выбрали несколько иной подход, чем общеизвестные методы. Идея заключалась в&nbsp;том, чтобы обмануть dyld, заставив его думать, что&nbsp;он просматривает обычный раздел, и поэтому пропустить вызов инициализаторов модуля. Затем, позже во&nbsp;время выполнения, мы могли&nbsp;бы получить базовый адрес фреймворка с&nbsp;помощью <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dladdr.3.html" rel="noopener noreferrer nofollow">dladdr </a>и вызвать инициализаторы с&nbsp;известным статическим смещением.</p>
   <p>Мы&nbsp;бы использовали это смещение, проверяя хэш фреймворка во&nbsp;время компиляции, проверяя разделы во&nbsp;время выполнения и проверяя, что&nbsp;флаг раздела действительно&nbsp;был заменён. Имея в&nbsp;виду эти меры безопасности и общий план, мы успешно развернули эту оптимизацию и увеличили скорость запуска приложения на <strong>36%</strong>.</p>
   <h3>Заключение</h3>
   <p>Точное определение узких мест и возможностей производительности часто является самой сложной частью любой оптимизации. Общеизвестно, что&nbsp;распространённой ошибкой является измерение A, оптимизация B и заключение C.</p>
   <p>Именно здесь хорошие инструменты повышения производительности помогают выявить узкие места. Инструменты Xcode, часть Xcode, поставляются с&nbsp;несколькими шаблонами, помогающими выявить различные потенциальные проблемы в&nbsp;приложении macOS/iOS. Но&nbsp;для&nbsp;дополнительной детализации и простоты использования Emerge Tools предоставляет упрощённое представление о&nbsp;производительности приложений с&nbsp;помощью своих инструментов производительности.</p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->