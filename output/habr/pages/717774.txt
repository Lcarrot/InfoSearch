<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Считается, что эвент-сорсинг это просто паттерн работы с данными, но применение эвент-сорсинга на деле приводит к большому числу изменений в дизайне приложений. К тому же, сделать эвент-сорсинг правильно не так просто, с одной стороны потому, что нужно заранее ответить на большое количество вопросов, а с другой нужно знать на какие вопросы отвечать.</p>
   <p>В&nbsp;этой статье попробую рассказать о том, что такое эвент-сорсинг, как он меняет дизайн приложений, постараюсь подсветить те вопросы, которые нужно учесть при проектировании и ещё поделюсь примером системы из двух приложений, написанных с применением эвент-сорсинга.</p>
   <h2>Пример системы</h2>
   <p>Начну сразу с примера системы. Система состоит из двух сервисов, оба написаны с применением эвент-сорсинга.</p>
   <p>Первый сервис отвечает за проведение платежей. Так выглядит стейт-машина воображаемого платежа.</p>
   <figure class="bordered full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/2b9/87a/306/2b987a306fef3444b70976c58f6d35ec.png" alt="1. Стейт-машина платежа" title="1. Стейт-машина платежа" width="6119" height="653" data-src="https://habrastorage.org/getpro/habr/upload_files/2b9/87a/306/2b987a306fef3444b70976c58f6d35ec.png">
    <figcaption>
     1. Стейт-машина платежа
    </figcaption>
   </figure>
   <p>Второй сервис отвечает за проведение заказов. Заказ представлен такой стейт-машиной.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/b1d/675/694/b1d6756948556cd275e928f5f8db3ea9.png" alt="2.Стейт-машина заказа" title="2.Стейт-машина заказа" width="4468" height="895" data-src="https://habrastorage.org/getpro/habr/upload_files/b1d/675/694/b1d6756948556cd275e928f5f8db3ea9.png">
    <figcaption>
     2.Стейт-машина заказа
    </figcaption>
   </figure>
   <p>Предполагается, что для заказа необходима оплата, поэтому сервисы взаимодействуют друг с другом. Флоу заказа с учетом необходимости оплаты выглядит так.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/cef/23b/1a9/cef23b1a9ce2588155e94f8ad8f0ca89.png" alt="3. Флоу заказа целиком" title="3. Флоу заказа целиком" width="3068" height="1303" data-src="https://habrastorage.org/getpro/habr/upload_files/cef/23b/1a9/cef23b1a9ce2588155e94f8ad8f0ca89.png">
    <figcaption>
     3. Флоу заказа целиком
    </figcaption>
   </figure>
   <p>А так система выглядит на уровне компонентов.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/8fb/0a4/d9f/8fb0a4d9f1720057a1bccd9f2978a74b.png" alt="4. Система на уровне компонентов" title="4. Система на уровне компонентов" width="3136" height="1275" data-src="https://habrastorage.org/getpro/habr/upload_files/8fb/0a4/d9f/8fb0a4d9f1720057a1bccd9f2978a74b.png">
    <figcaption>
     4. Система на уровне компонентов
    </figcaption>
   </figure>
   <p>Это игрушечный пример, поэтому тут не будет обработки ошибок или сложной логики, но я постарался сделать пример таким, чтобы все его компоненты выглядели и работали как в реальном мире. В частности, я использовал настоящие базы данных, сделал подписки и интегрировал приложения через шину и АПИ. Можно было бы интегрировать только через шину, но для пример использовал два механизма.</p>
   <p>Код приложений находится <a href="https://github.com/aurokk/event-sourcing" rel="noopener noreferrer nofollow">тут</a>, там же есть e2e-тест, который создает и оплачивает заказ в соответствии с алгоритмом выше. Приложения докеризированы и в репозитории есть докер-компоуз файл, который позволяет без лишних сложностей собрать и запустить систему для того, чтобы поразбираться как и что работает. Команды для запуска в разных вариациях в <a href="https://github.com/aurokk/event-sourcing" rel="noopener noreferrer nofollow">ридми</a>.</p>
   <p>Смотреть и запускать код совершенно не обязательно, просто знайте, что такая возможность есть. Если всё же пойдёте смотреть — рекомендую обратить внимание на то, как выглядят эвенты и агрегаты, как используются эвенты для восстановления состояния агрегатов и как выглядят обработчики эвентов.</p>
   <p>По ходу статьи я буду ссылаться на некоторые части системы, поэтому пробегитесь хотя бы по картинкам!</p>
   <h2>Что такое эвент-сорсинг</h2>
   <p>Теперь давайте разбираться что такое эвент-сорсинг. Цель главы — понять основные составляющие и выделить термины.</p>
   <p>Оттолкнёмся от определения из статьи майкрософта. Да и, в целом, вся статья неплохая, рекомендую к прочтению, но только после моей!</p>
   <blockquote>
    <p>Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</p>
    <p>Ссылка: <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" rel="noopener noreferrer nofollow">https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</a></p>
   </blockquote>
   <p>Объяснять буду на примере сервиса заказов.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/79e/841/d19/79e841d198f9708556d0fd51e0aa092c.png" alt="5. Стейт-машина заказа" title="5. Стейт-машина заказа" width="4468" height="895" data-src="https://habrastorage.org/getpro/habr/upload_files/79e/841/d19/79e841d198f9708556d0fd51e0aa092c.png">
    <figcaption>
     5. Стейт-машина заказа
    </figcaption>
   </figure>
   <p>Основная идея эвент-сорсинга заключается в том, что нужно хранить состояние системы в виде упорядоченного неизменяемого лога возникающих в системе событий вместо того, чтобы хранить его в виде снимков состояний объектов.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/909/23f/4e1/90923f4e1001079521012f5cb1bef19c.png" alt="6. От снимков состояний к событиям" title="6. От снимков состояний к событиям" width="3291" height="1215" data-src="https://habrastorage.org/getpro/habr/upload_files/909/23f/4e1/90923f4e1001079521012f5cb1bef19c.png">
    <figcaption>
     6. От снимков состояний к событиям
    </figcaption>
   </figure>
   <p>Когда состояние системы хранится в виде снимков состояния — состояние объекта в системе представлено изменяемой строкой или строками в базе данных. При обновлении состояния объекта мы перезаписываем строку новыми значениями.</p>
   <p>Когда применяется эвент-сорсинг — состояние хранится в виде последовательности неизменяемых событий. При обновлении состояния объекта нужно сохранить новые события не меняя старые.</p>
   <p>Событие в эвент-сорсинге это набор данных описывающий некоторый факт реального мира, когда событие уже произошло, как и в реальном мире, оно уже не может измениться.</p>
   <p>В коде это некоторый неизменяемый объект, <a href="https://github.com/aurokk/event-sourcing/blob/main/src/Orders.Domain/OrderCreated.cs#L5" rel="noopener noreferrer nofollow">пример</a>.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/730/643/989/73064398924ae69011ec02b69abed6d6.png" alt="7. Стрим" title="7. Стрим" width="3689" height="1084" data-src="https://habrastorage.org/getpro/habr/upload_files/730/643/989/73064398924ae69011ec02b69abed6d6.png">
    <figcaption>
     7. Стрим
    </figcaption>
   </figure>
   <p>Последовательность событий относящихся к одному объекту называют стримом. События внутри стрима должны быть упорядочены всегда для того, чтобы можно было их считать, применить в порядке возникновения и таким образом восстановить состояние объекта.</p>
   <p><a href="https://github.com/aurokk/event-sourcing/blob/main/src/Orders.Domain/Order.cs#L15" rel="noopener noreferrer nofollow">Стрим в коде</a> удобно представить в виде DDD-агрегата, потому что стрим как и DDD-агрегат образует границу согласованности данных.</p>
   <blockquote>
    <p>An Event Stream is a list of Events that form a consistency unit that you might call an aggregate if you practice Domain-Driven Design or otherwise an entity, business object, …</p>
    <p>Ссылка: <a href="https://itnext.io/event-sourcing-explained-b19ccaa93ae4#:~:text=An" rel="noopener noreferrer nofollow">https://itnext.io/event-sourcing-explained-b19ccaa93ae4#:~:text=An</a> Event Stream is a,keep it simple for now</p>
   </blockquote>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/600/eed/ac3/600eedac3fa12feb7c5da8f191d4f10e.png" alt="8. Лог" title="8. Лог" width="3689" height="1084" data-src="https://habrastorage.org/getpro/habr/upload_files/600/eed/ac3/600eedac3fa12feb7c5da8f191d4f10e.png">
    <figcaption>
     8. Лог
    </figcaption>
   </figure>
   <p>Пару слов о том, как события хранятся в базе данных. Возможны разные варианты, в зависимости от требований к системе, нагрузки и прочего, но в самом простом случае, все события хранятся в некоторой append-only таблице и глобально-упорядочены. Эту таблицу также называют логом.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/0e7/80d/6d5/0e780d6d590bc944c35d534e64a3e248.png" alt="9. Эвент-стор" title="9. Эвент-стор" width="3288" height="1216" data-src="https://habrastorage.org/getpro/habr/upload_files/0e7/80d/6d5/0e780d6d590bc944c35d534e64a3e248.png">
    <figcaption>
     9. Эвент-стор
    </figcaption>
   </figure>
   <p>Базу данных, в которой хранятся логи, обычно называют эвент-стором. Эвент-стором может быть не каждая база данных, а только такая, которая предоставляет необходимые возможности для работы с данными. Для примера, нам нужна упорядоченность данных, возможность чтения отдельных стримов, возможность чтения событий в логе по порядку. На самом деле набор требований не определен строго и может варьироваться в зависимости от требований к системе. Подробно поговорим об эвент-сторах чуть позже.</p>
   <p>Одно из перечисленных выше требований — возможность чтения событий в логе по порядку или подписки — является самой главной фичей, которую даёт нам эвент-сорсинг и без него он просто теряет смысл. С помощью этого механизма мы можем строить проекции, а так же выполнять фоновую работу, например, делать вызовы сторонних сервисов. Также этот механизм заменяет транзакции.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/dbf/f0d/9b5/dbff0d9b50cb18e8e3159e72d80779b4.png" alt="10. Лог" title="10. Лог" width="2674" height="1495" data-src="https://habrastorage.org/getpro/habr/upload_files/dbf/f0d/9b5/dbff0d9b50cb18e8e3159e72d80779b4.png">
    <figcaption>
     10. Лог
    </figcaption>
   </figure>
   <p>Начнем с проекций.</p>
   <p>Проекции или как их ещё называют материализованные представления это состояние объекта или объектов в оптимизированном для чтения виде. В оптимизированном для чтения значит, что данные для обработки некоторого [get-]запроса подготовлены заранее и для их получения не требуется выполнения сложных операций, в частности, не нужно восстанавливать состояние объекта из стрима событий, а так же не нужно делать серии вызовов для того, чтобы получить все нужные для обработки запроса данные.</p>
   <p>Примерами проекций могут быть снимки состояний объектов, отчеты и другие данные, которые необходимо показать на UI. К слову, если захочется сделать какой-то джоин (join), то сделать это можно будет только с помощью проекций, события джойнить сложновато :-)</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/ee6/00f/f85/ee600ff85dba79ec51b0130a6b1cb989.png" alt="11. Фоновая работа" title="11. Фоновая работа" width="2874" height="1391" data-src="https://habrastorage.org/getpro/habr/upload_files/ee6/00f/f85/ee600ff85dba79ec51b0130a6b1cb989.png">
    <figcaption>
     11. Фоновая работа
    </figcaption>
   </figure>
   <p>Теперь про фоновую работу.</p>
   <p>Под этой фразой я понимаю запрос к некоторому внешнему сервису, который потребляет много ресурсов, CPU или времени — обращение к модулю text-to-speech или публикация интеграционных эвентов в шину, всё что угодно, что не относится напрямую к обработке текущего запроса. Имея возможность подписки на новые события, становится возможным выполнять эти задачи асинхронно, реактивно и в фоне, что делает нашу систему более отзывчивой и более контролируемой.</p>
   <p>Я думаю вы уже догадались зачем нужно чтобы эвенты были упорядоченными, но проговорю на всякий случай. Порядок эвентов нужен, чтобы мы могли обрабатывать их всегда в одном и том же порядке порядке и могли хранить оффсеты уже обработанных записей.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/db6/85d/ecb/db685decb40e32a01f4b36feddab114e.png" alt="12. Оффсеты" title="12. Оффсеты" width="4216" height="948" data-src="https://habrastorage.org/getpro/habr/upload_files/db6/85d/ecb/db685decb40e32a01f4b36feddab114e.png">
    <figcaption>
     12. Оффсеты
    </figcaption>
   </figure>
   <p>Концептуально обработка эвентов в фоне выглядит так же <a href="https://medium.com/javarevisited/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00" rel="noopener noreferrer nofollow">как в кафке</a>, концепции буквально те же, лог = топик, партиции = шарды, консьюмер группы и консьюмеры даже можно называть так же.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/fa4/9ed/013/fa49ed013ac37065446ff46eca6dedb8.png" alt="13. Обработка эвентов в фоне как в кафке" title="13. Обработка эвентов в фоне как в кафке" width="3276" height="1220" data-src="https://habrastorage.org/getpro/habr/upload_files/fa4/9ed/013/fa49ed013ac37065446ff46eca6dedb8.png">
    <figcaption>
     13. Обработка эвентов в фоне как в кафке
    </figcaption>
   </figure>
   <p>Мы можем добавлять новых консьюмеров на события в любое время, и так как мы храним все данные, мы можем обрабатывать события с нужного нам момента, с самого первого эвента в системе или с текущего момента, например.</p>
   <p>Что касается транзакций.</p>
   <p>Фоновая обработка эвентов избавляет нас от необходимости в транзакциях. Вообще, транзакции нужны для того, чтобы обеспечить консистентность данных. В случае когда мы используем транзакции мы имеем строгую консистентность (strong consistency), т.е. когда база данных нам отвечает ОК, это значит что все объекты изменились и все изменения записаны. В случае с эвент-сорсингом мы имеем консистентность в конечном счете (eventual consistency), но за то наша система становится отзывчивой, задачи очень хорошо отделяются друг от друга, что делает код проще и надёжнее.</p>
   <p>Вкратце, это вся теория.</p>
   <h2>Влияние на архитектуру приложения</h2>
   <p>Как я сказал в начале, эвент-сорсинг влияет на архитектуру приложения. В моём понимании, влияние положительное, так как система становится более понятной за счет четкого распределения ответственности в коде и прозрачной работы с данными. Далее перечислю за счет чего.</p>
   <h3>Command Query Responsibility Segregation</h3>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/41b/1a2/7ba/41b1a27baee0de24c89a396ca7363c8b.png" alt="14. CQRS" title="14. CQRS" width="3276" height="1220" data-src="https://habrastorage.org/getpro/habr/upload_files/41b/1a2/7ba/41b1a27baee0de24c89a396ca7363c8b.png">
    <figcaption>
     14. CQRS
    </figcaption>
   </figure>
   <p>Следствием того, что в приложении с применением эвент-сорсинга нет транзакций, но есть проекции является то, что в таких приложениях изначально логически разделены модели данных для чтения (read) и для записи (write). По-сути, <a href="https://martinfowler.com/bliki/CQRS.html" rel="noopener noreferrer nofollow">CQRS</a>.</p>
   <h3>Domain Driven Design</h3>
   <p>Как я сказал выше, очень удобно моделировать стрим в коде в виде DDD-агрегата. Обе сущности определяют границу транзакционности, что играет нам на руку. К примеру, я привык моделировать агрегат в коде таким образом, чтобы он умел порождать новые эвенты, и восстанавливать свое состояние из потока эвентов. Примерно <a href="https://buildplease.com/pages/fpc-9/" rel="noopener noreferrer nofollow">такая</a> имплементация мне по душе. В более сложных кейсах ответственность можно поделить таким образом, чтобы логика была в одном классе, а состояние в другом.</p>
   <h3>Фоновая обработка</h3>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e38/df3/4bc/e38df34bc4afeedbc2dd8d2288d7d6cc.png" alt="15. Тяжелые операции смещаются в фоновые сервисы" title="15. Тяжелые операции смещаются в фоновые сервисы" width="3276" height="1220" data-src="https://habrastorage.org/getpro/habr/upload_files/e38/df3/4bc/e38df34bc4afeedbc2dd8d2288d7d6cc.png">
    <figcaption>
     15. Тяжелые операции смещаются в фоновые сервисы
    </figcaption>
   </figure>
   <p>Имея механизм подписок становится просто вынести обработку тяжёлых операций из обработчиков запросов в фоновые сервисы. Это позитивно влиеяет на отзывчивость системы, а так же даёт больше контроля над нагрузкой.</p>
   <h3>Акторы</h3>
   <p>На самом деле акторы не обязательно использовать, но на мой взгляд акторы очень естественно выглядят как обёртка над агрегатами. В дотнете особенно удачным решением выглядит фреймворк <a href="https://learn.microsoft.com/en-us/dotnet/orleans/" rel="noopener noreferrer nofollow">orleans</a> и их концепция виртуальных акторов.</p>
   <p>Использование акторов поможет оптимизировать нагрузку на базу данных, за счет того, что данные будут находиться в памяти и их не нужно будет перечитывать для обработки каждого запроса. Так же акторы снижают нагрузку на базу данных за счет уменьшения проблем связанных с конкаренси. Это применимо как для write так и для read нагрузки.</p>
   <h2>Что ещё стоит знать</h2>
   <p>В этом разделе я собрал вопросы, в которых точно стоит разобраться до того, как применять эвент-сорсинг.</p>
   <h3>Чем отличаются эвенты от команд</h3>
   <p>Основная идея, которая стоит за словом эвент в эвент-сорсинге заключается в том, что это набор данных описывающих событие, которое уже произошло. Эвент появляется в результате работы некоторого кода, например, выполнения команды. После того, как эвент создал он не примениться к агрегату только в случае ошибок в коде, других причин быть не должно логически, в частности, неправильно делать валидации с точки зрения доменной логики при восстановлении состояния агрегата из базы данных.</p>
   <p>Команда же это описание некоторого задания. Концептуально, команда это объект у которого есть состояние — она может обрабатываться в данный момент, может быть выполнена и может иметь результат. Команда в результате работы может менять агрегаты, что приведет к возникновению новых эвентов.</p>
   <p>Ещё есть такая концепция как команд-сорсинг. Суть заключается в том, чтобы хранить команды, которые исполняет система, для того, чтобы иметь возможность проиграть их заново. В результате такого воспроизведения мы получим другое (новое) системы. В эвент-сорсинге же мы храним состояние и можем воспроизводить одно конкретное состояние в разные моменты времени. Почитать ещё про команд-сорсинг можно <a href="https://blog.arkency.com/command-sourcing-why-i-am-considering-it/" rel="noopener noreferrer nofollow">тут</a>.</p>
   <h3>Как скейлить допустимую read нагрузку</h3>
   <p>Представим, что у есть система, которая:</p>
   <ul>
    <li><p>состоит из одного НЕшардированного лога</p></li>
    <li><p>в рамках шарда эвенты упорядочены</p></li>
    <li><p>есть обработчик, который обрабатывает эвенты последовательно 0, 1, 2, 3...</p></li>
    <li><p>обработчик сохраняет свой оффсет, чтобы после перезапуска продолжить обработку с места остановки</p></li>
    <li><p></p></li>
   </ul>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/644/4f5/d54/6444f5d543f1d6c109cb5361a905c829.png" alt="16. Скейлим read компоненты" title="16. Скейлим read компоненты" width="3134" height="1276" data-src="https://habrastorage.org/getpro/habr/upload_files/644/4f5/d54/6444f5d543f1d6c109cb5361a905c829.png">
    <figcaption>
     16. Скейлим read компоненты
    </figcaption>
   </figure>
   <p>В случае проблем с нагрузкой на read компоненты мы можем просто увеличивать количество инстансов API и реплик базы данных и таким образом справляться с любой нужной нам нагрузкой. По-умолчанию всё скейлится горизонтально.</p>
   <p>Более интересный случай, когда нам не хватает скорости, с которой работает какой-нибудь подписчик на write базу данных.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/be6/790/c34/be6790c3431dc348979f906f53e03ab7.png" alt="17. Скейлим обработчики эвентов" title="17. Скейлим обработчики эвентов" width="3134" height="1276" data-src="https://habrastorage.org/getpro/habr/upload_files/be6/790/c34/be6790c3431dc348979f906f53e03ab7.png">
    <figcaption>
     17. Скейлим обработчики эвентов
    </figcaption>
   </figure>
   <p>В данном случае придётся применять шардирование, например, самое банальное брать остаток от деления StreamId на N и таким образом делить наши ключи на N ренжей и распределять обработку на N обработчиков. Конечно, подход с отстатком от деления не самый гибкий и лучше применять какой-то более продвинутый.</p>
   <p>Наиболее сложный момент при скейлинге обработчиков заключается в распределении ресурсов, в нашем случае ренжей хэшей, по обработчикам. В реальном мире даже самые простые приложения имеют несколько запущенных копий для обеспеычения отказоустойчивости, их количество может меняться в процессе работы и нужно уметь распределять нагрузку равномерно.</p>
   <p>Если вы используете, например, MySql, то придётся всё сделать самостоятельно, если же вы используете, например, Azure Cosmos DB, то вопрос скейлинга решен из коробки. <a href="https://learn.microsoft.com/en-us/azure/cosmos-db/partitioning-overview" rel="noopener noreferrer nofollow">Тут</a> можно почитать о том как это сделано в Azure Cosmos DB, обратите внимание на шардирование, ченжфид и балансировку.</p>
   <p>Подходы могут быть разные в зависимости от задачи, например, если важно, чтобы события одного стрима обрабатывались последовательно, то нужно распределять работу так, чтобы события одного стрима попадали в один и тот же обработчик, если нет, то можно распределять опираясь на SequenceId, round-robin-ом или как-то ещё.</p>
   <h3>Как скейлить допустимую write нагрузку</h3>
   <p>В прошлом параграфе мы обсудили скейлинг read нагрузки в случае когда лог не шардирован. Шардирование лога позволяет скейлить допустимую write нагрузку.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/5d0/54f/685/5d054f68527492f0510f76064b513025.png" alt="18. Скейлинг write компонентов" title="18. Скейлинг write компонентов" width="3134" height="1276" data-src="https://habrastorage.org/getpro/habr/upload_files/5d0/54f/685/5d054f68527492f0510f76064b513025.png">
    <figcaption>
     18. Скейлинг write компонентов
    </figcaption>
   </figure>
   <p>Всё что мы обсудили ранее справедливо и для лога с несколькими шардами, но есть нюансы. Например, теперь ресурсами являются не ренжи хешей, а шарды или партиции. Если вы используете и хеширование внутри шарда и шардирование вместе, то нужно количество обработчиков у вас будет умножаться при добавлении новых шардов, нужно это учитывать. В данном случае, также как и со чтением, нужно уметь распределять обработку логов по разным инстансам.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/477/07a/9c2/47707a9c21c96662c48ee93c9b91ef91.png" alt="19. Несколько шардов" title="19. Несколько шардов" width="4027" height="993" data-src="https://habrastorage.org/getpro/habr/upload_files/477/07a/9c2/47707a9c21c96662c48ee93c9b91ef91.png">
    <figcaption>
     19. Несколько шардов
    </figcaption>
   </figure>
   <p>Хочется заметить, что когда в системе появляется несколько шардов (&gt;1) эвенты перестают быть глобально упорядоченными, и становятся упорядоченными только в рамках шарда. Это повлияет на то, что теперь система, при проигрывании эвентов будет каждый раз делать это по-разному, потому что эвенты из разных шардов могут обрабатываться с разной скоростью, но в конечном счете система будет оказываться в одном и том же состоянии.</p>
   <h3>Как избежать head-of-line блокировок при обработке эвентов</h3>
   <p>С head-of-line блокировками вы столкнётесь, если будете делать медленные операций напрямую в обработчике эвентов из базы данных. Медленные операции это, например, вызовы АПИ внешних систем или вызовы какого-то ресурсоёмкого кода. Если это не учитывать, то возможна ситуация, когда обработка эвента 5 в первой линии затормозит и все последующие эвенты будут ожидать своей очереди до тех пор, пока эвент 5 не обработается.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/076/d68/2af/076d682af9956ae498061ea0e5dc1a1d.png" alt="20. Head-of-line blocking" title="20. Head-of-line blocking" width="4027" height="993" data-src="https://habrastorage.org/getpro/habr/upload_files/076/d68/2af/076d682af9956ae498061ea0e5dc1a1d.png">
    <figcaption>
     20. Head-of-line blocking
    </figcaption>
   </figure>
   <p>Чтобы избежать этой проблемы стоит эвенты превращать в команды, которые могут исполняться независимо друг от друга и перекладывать их в другую систему, которая может обеспечить нужную степень параллелизма. Для примера, сейчас я работаю над платёжным шлюзом и у меня независимо исполняются команды по каждому платежу. В случае, если один платёж подвиснет или будет проходить медленно, то это никак не зааффектит остальные.</p>
   <h3>Что делать если нужно удалить некоторые данные</h3>
   <p>Допустим нам нужно удалить некоторые данные из нашей системы, что мы можем сделать? Логическое удаление, которое по сути является обновлением, скорее всего нам не подойдет, потому что физически данные останутся в логе. Нам подходит только физическое удаление и мы можем:</p>
   <ol>
    <li><p>Удалить один эвент физически — это приведет к тому, что станет невозможно восстановить состояние одного аггрегата, к тому же все проекции, которые использовали этот эвент требуется перестроить</p></li>
    <li><p>Перезаписать данные некоторого эвента — это приведёт к тому, что все проекции, которые использовали этот эвент требуется перестроить</p></li>
    <li><p>Удалить один стрим физически — это приведёт к тому, все проекции, которые использовали этот эвент требуется перестроить</p></li>
   </ol>
   <p>Но это ещё не все — если данные эвента как-то распространялись по системе, то вычистить их повсеместно может быть очень сложно.</p>
   <p>На мой взгляд единственное что можно сделать — заранее предусмотреть необходимые функциональные возможности. В данном случае это сводится к тому, чтобы добавить уровень косвенности и хранить ПД отдельно в таком хранилище, которое поддерживает удаление отдельных записей.</p>
   <p>Все остальные решения сводятся к манипуляциям с данными и приводят к тому, что проекции и данные во внешних системах становятся неконсистентными и требуют перестроения.</p>
   <h3>Как делать UI</h3>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/221/d89/603/221d89603736b80ec89e5345e8b250d1.png" alt="21. Задержка обновления read моделей" title="21. Задержка обновления read моделей" width="3134" height="1276" data-src="https://habrastorage.org/getpro/habr/upload_files/221/d89/603/221d89603736b80ec89e5345e8b250d1.png">
    <figcaption>
     21. Задержка обновления read моделей
    </figcaption>
   </figure>
   <p>Допустим мы показываем пользователю страницу на сайте, для чего используем некоторую проекцию и пользователь имеет возможность как-то менять данные на странице. Так как проекции (read модели) не строго-консистентны с write моделью, то они обновляются с некоторой задержкой, и нам нужно обработать ситуацию когда пользователь нажал на кнопку сохранения, но проекции ещё не обновились.</p>
   <p>Какие решения:</p>
   <ol>
    <li><p>Делать честный task-based UI. Это решение подразумевает то, что нужна некоторая инфраструктура для работы с [асинхронным] задачами, и, в частности, отслеживания состояния задач (в очереди → исполняется → результат). Главный недостаток этого решения в его высокой сложности.</p></li>
    <li><p>Чуть более дешёвое — поллинг на фронтенде. При записи эвента нам известен его порядковый номер в стриме, можно опрашивать бэкенд до тех пор, пока модель не достигнет нужной версии. Недостаток в том, что нужно обеспечить возможность поллинга всех сущностей и достаточное количество ресурсов для обработки запросов.</p></li>
    <li><p>Ещё более дешёвое — поллинг на бэкенде. Суть заключается в том, чтобы не завершать запрос в момент, когда мы сохранили эвент, а поллить read базу до тех пор пока нужная модель не достигнет нужной версии, примерно тоже самое, что в предыдущем пункте. Недостаток заключается в том, что ресурсы тоже будут расходоваться на поллинг, но ещё и сетевые подключения будут существовать относительно долго.</p></li>
    <li><p>Ничего не делать. Главный недостаток — пользователи будут страдать, а с ними и вы от количество вопросов о том, почему всё не работает :-)</p></li>
   </ol>
   <h3>Стоит ли интегрировать сервисы с помощью эвент-сорсинга</h3>
   <p>Несколько раз мне попадалась идея о том, чтобы использовать эвент-сорсинг как средство интеграции [микро] сервисов. Я считаю, что это плохое решение потому что приводит к излишней связности и хрупкости. Если доменные эвенты используются для решения задач интеграции — это уже интеграционные эвенты и они предполагают наличие некоторого контракта, который нужно соблюдать, что накладывает ограничения на внесение изменений в код сервиса.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/847/128/7ed/8471287ed586460dce8376f56cab40ea.png" alt="22. Разделение интеграционных и доменных эвентов" title="22. Разделение интеграционных и доменных эвентов" width="3136" height="1275" data-src="https://habrastorage.org/getpro/habr/upload_files/847/128/7ed/8471287ed586460dce8376f56cab40ea.png">
    <figcaption>
     22. Разделение интеграционных и доменных эвентов
    </figcaption>
   </figure>
   <p>Я за разумный подход, стоит применять эвент-сорсинг в ограниченных рамках, например, в рамках одного bounded context, допустим, сервис платежей может быть написан с применением event-sourcing, или сервис заказов может быть написан с применением event-sourcing. Но каждый из них — отдельный сервис и интегрируются они стандартно — с помощью интеграционных эвентов или АПИ.</p>
   <p>Как архитекторы мы должны стремиться к тому, чтобы наша система оставалась максимально гибкой и могла удовлетворять любые потребности бизнеса, повсеместное и бездумное применение эвент-сорсинга, к сожалению, не способствует решению этой задачи.</p>
   <p>Почитать ещё о проблемах интеграции сервисов с помощью эвент-сорсинга можно <a href="https://dev.to/olibutzki/why-event-sourcing-is-a-microservice-anti-pattern-3mcj" rel="noopener noreferrer nofollow">тут</a>.</p>
   <h3>Что если в транзакции обновлять агрегаты</h3>
   <p>Возможно в предыдущем пункте у вас возникла идея использовать [распределенные] транзакции для обновления проекций. Думаю, это возможно но есть и свои минусы:</p>
   <ul>
    <li><p>Неконтролируемо растет сложность и время записей</p></li>
    <li><p>Место где происходит запись в базу становится хрупким и сложным, так как требует внесения изменений каждый раз при изменении проекций</p></li>
    <li><p>Если нужно будет добавить новые проекции, то придется писать два механизма обновления проекций. Первый тот, что умеет читать из лога последовательно, второй тот, что обновляет проекции в транзакциях</p></li>
   </ul>
   <p>Если имеет место необходимость иметь read модель строго-консистентную с write моделью, то возможно эвент-сорсинг не самое подходящее решение. Стоит рассмотреть возможность сохранения ревизий объектов — тоже append-only сторедж, но хранить нужно не события, а версии снимков состояния объектов. Так делают блоговые движки, вроде <a href="https://wordpress.org/documentation/article/revisions/" rel="noopener noreferrer nofollow">wordpress</a> — сохраняют ревизии постов.</p>
   <h2>Выбираем технологию для event store</h2>
   <p>Важнейший аспект эвент-сорсинга — хранение данных, поэтому выбор технологии для эвент-стора это один из главных вопросов. В этой главе поговорим о требованиях к технологии, рассмотрим несколько вариантов, проанализируем и оценим насколько они подходят для решения задачи. По аналогии вы сможете проанализировать и другие технологии. От выбора зависит то, какие задачи придётся решать самостоятельно — скейлинг, поллинг и упорядочивание данных, какие будут ограничения — возможно, не будет транзакций, что может быть полезно в ситуации, когда мы хотим зафиксировать несколько отдельных изменений в рамках одного запроса, а возможно технология окажется вовсе неподходящей.</p>
   <p>Предлагаю дополнить ваш список требований к технологии такими вопросами:</p>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>Это нужно для того, чтобы обеспечить возможность подписки на новые эвенты.</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>Это нужно для того, чтобы мы могли просто работать с данными. Если мы записали эвент в базу данных, но следующим запросом не можем его прочитать, то это может привести к нарушению работы бизнес-логики. Допустим мы можем сохранить эвент о том, что мы списали деньги. Следующим запросом прочитать стрим в котором не будет этого эвента, списать деньги ещё раз.</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Нам интересно что предлагается из коробки для решения задачи и или существование популярные готовые решения.</p></li>
    <li><p>Возможность модифицировать записанные данные</p></li>
   </ol>
   <p>Важно так же рассмотреть влияние одних фич на другие. Возможно, это звучит сейчас загадочно, но я поясню когда такое произойдет.</p>
   <p>Я не являюсь большим экспертом в каждой из технологий которые буду рассматривать дальше. Ответы на вопросы я старался писать опираясь на концептуальные возможности и документацию решения. Некоторые решения не подходят концептуально, но могут быть подогнаны костылями к нужному нам виду — это не мой путь и в таких случаях я буду считать технологию неподходящей.</p>
   <h3>🟩 MySQL (или другие rdbms)</h3>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>Есть, с помощью авто-инкремента.</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p><p>Вопрос со звёздочкой. Кажется, можно использовать для этого CDC, но эта технология, на мой взгляд, слишком сложная и хрупкая. Поэтому я считаю, что лучше сделать поллинг упорядоченных с помощью авто-инкремента данных самостоятельно. При этом придётся решить задачи скейлинга и балансировки самостоятельно.</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p><p>Да</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>По умолчанию у нас строгий уровень консистентности и такая гарантия есть.</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Шардирование. Коробочных решений нет, но есть условно готовые решения, вроде <a href="https://proxysql.com/" rel="noopener noreferrer nofollow">ProxySQL</a>.</p></li>
    <li><p>Возможность модифицировать записанные данные</p><p>Да, полный контроль над данными</p></li>
   </ol>
   <p>На мой взгляд это самый гибкий вариант, но и ручной работы при этом много.</p>
   <h3>❌ MongoDB</h3>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>В целом нет, но гуглится <a href="https://www.mongodb.com/basics/mongodb-auto-increment" rel="noopener noreferrer nofollow">такое решение</a> с триггерами — на мой взгляд выглядит костыльно и очень хрупко.</p><p>Если использовать ченж стримы — <a href="https://www.mongodb.com/docs/manual/changeStreams/" rel="noopener noreferrer nofollow">https://www.mongodb.com/docs/manual/changeStreams/</a>, то возможно упорядочивать данные вручную не нужно, так как записи в оплоге будут упорядочены за нас, но это решение со звёздочкой.</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p><p>Есть чендж стримы, но они ограничены размером oplog-а, что на мой взгляд для нашей задачи не совсем подходит из-за того, что нужно рассчитать размер oplog-а таким образом, чтобы это удовлетворяло нашим потребностям и он может варьироваться от размера и кол-ва записей.</p><p>К тому же ченж стримы не так удобны — нет простой возможности прочитать всё с самого начала, а ещё когда oplog начнет обрезать старые данные, то оно не будет учитывать целостность данных и скорее всего началом станет эвент из середины какого-то стрима, что тоже надо обработать.</p><p>Это что-то вроде CDC в случае с rdbms, но чуть более продвинутое. В целом я бы не стал использовать это для критичного функционала, так как всё выглядит очень хрупко.</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p><p>Да</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>По умолчанию у нас строгий уровень консистентности и такая гарантия есть</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Шардирование, решено из коробки</p></li>
    <li><p>Возможность модифицировать записанные данные</p><p>Да, полный контроль над данными. К слову, возможность модификации данных влияет на то, какие записи попадут в оплог и в ченж стрим соответственно.</p></li>
   </ol>
   <p>В моём понимании mongo не подходит для использования в качестве event-store так как слишком хрупка, хотя очень даже подходит для использования как read база данных.</p>
   <h3>🟩 Azure CosmosDB</h3>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>Нет, но данные упорядочены для нас в ченж фидах.</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p><p>Да, причем проблемы скейлинга и балансировки нагрузки решены за нас из коробки. <a href="https://learn.microsoft.com/en-us/azure/cosmos-db/change-feed" rel="noopener noreferrer nofollow">https://learn.microsoft.com/en-us/azure/cosmos-db/change-feed</a></p><p>Когда я пробовал эту функцию пару лет назад было ограничение в скорости поллинга, кажется, не быстрее ~500ms. А так же каждый запрос к ченжфиду биллится и это просто напросто может оказаться дорогим решением. Нужно считать в каждом конкретном случае.</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p><p>Да</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>Да, доступна строгая консистентность</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Решено из коробки с помощью шардирования — <a href="https://learn.microsoft.com/en-us/azure/cosmos-db/partitioning-overview" rel="noopener noreferrer nofollow">https://learn.microsoft.com/en-us/azure/cosmos-db/partitioning-overview</a>. Но есть нюанс, что мы напрямую не контролируем скейлинг, алгоритм скрыт от нас и полностью автоматический.</p></li>
    <li><p>Возможность модифицировать записанные данные</p><p>Да, но апдейты появятся в ченж фиде, их нужно будет игнорировать</p></li>
   </ol>
   <p>На мой взгляд подходит, тут есть пример как делать эвент-сорсинг на Azure CosmosDB <a href="https://medium.com/@thomasweiss_io/planet-scale-event-sourcing-with-azure-cosmos-db-48a557757c8d" rel="noopener noreferrer nofollow">https://medium.com/@thomasweiss_io/planet-scale-event-sourcing-with-azure-cosmos-db-48a557757c8d</a>. Из аргументов против может быть то, что это решение вендорлок на облако Azure.</p>
   <h3>🟩 EventStoreDB</h3>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>Сделано за нас из коробки</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p><p>Сделано за нас из коробки</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p><p>Да</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>Да</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Как я понял из документации, только вертикальное, значит шардирование придётся делать руками</p></li>
    <li><p>Возможность модифицировать записанные данные</p><p>Нет, предлагают делать через копирование — <a href="https://www.eventstore.com/blog/why-cant-i-update-an-event" rel="noopener noreferrer nofollow">https://www.eventstore.com/blog/why-cant-i-update-an-event</a></p></li>
   </ol>
   <p>Подходит, но не выглядит прям круто. Похоже, что из коробки не скейлится на запись, только на чтение. Непонятны бенчмарки — обещают 15к райтов, 50к ридов в секунду, но нет деталей про железо и нагрузку. Есть встроенный механизм проекций — на мой взгляд бесполезная фича, так как функции в базе данных это тоже самое что хранимые процедуры — ад и геморрой в поддержке.</p>
   <h3>❌ Kafka</h3>
   <ol>
    <li><p>Есть ли возможность упорядочить данные?</p><p>Сделано за нас из коробки</p></li>
    <li><p>Есть ли готовые решения для подписки на новые эвенты?</p><p>Сделано за нас из коробки</p></li>
    <li><p>Возможно прочитать отдельный стрим?</p><p>Нет!</p></li>
    <li><p>Возможно ли прочитать данные сразу после записи? (Уровень консистентности)</p><p>Нет! Так как мы не можем читать отдельные данные, то есть делать запросы, то нам нужно материализовать данные, а значит уровень консистентности eventual.</p></li>
    <li><p>Как скейлить запись и чтение?</p><p>Скейлится из коробки</p></li>
    <li><p>Возможность модифицировать записанные данные</p><p>Нет, но можно сделать какой-то механизм на основе этой идеи — <a href="https://www.eventstore.com/blog/why-cant-i-update-an-event" rel="noopener noreferrer nofollow">https://www.eventstore.com/blog/why-cant-i-update-an-event</a></p></li>
   </ol>
   <p>Кафку очень часто форсят в книгах и статьях как серебряную пулю решающую все проблемы и в том числе когда речь про эвент-сорсинг. Но это точно не так — кейсы где кафка действительно подходит очень специфичные и нужно очень тонко понимать все ограничения. Я считаю что кафка точно НЕ подходит по-умолчанию.</p>
   <p>Так как это очень спорная тема хочу оставить тут ряд статей от разных авторов с разными взглядами.</p>
   <ul>
    <li><p>Тут утверждают, что можно сделать — <a href="https://www.confluent.io/blog/event-sourcing-using-apache-kafka/" rel="noopener noreferrer nofollow">раз</a>.</p></li>
    <li><p>Тут поняли проблему с тем, что нужно стронг консистенси и пытаются её решить — <a href="https://github.com/evgeniy-khist/ksqldb-event-souring#c60b741f731650358e295c4598f5b9fd" rel="noopener noreferrer nofollow">раз</a>.</p></li>
    <li><p>А тут утверждают что не подходит — <a href="https://itnext.io/event-sourcing-why-kafka-is-not-suitable-as-an-event-store-796e5d9ab63c" rel="noopener noreferrer nofollow">раз</a>, <a href="https://domaincentric.net/blog/eventstoredb-vs-kafka" rel="noopener noreferrer nofollow">два</a>.</p></li>
   </ul>
   <h2>Когда применять эвент-сорсинг</h2>
   <p>Теперь когда у нас есть полная картина того, что такое эвент-сорсинг можно ответить на этот вопрос. Поделюсь с вами некоторыми из своих мыслей, но это не финальный список и возможно я что-то упустил.</p>
   <h3>Когда применять</h3>
   <ul>
    <li><p>Когда нужен полный аудит лог событий в системе</p><p>За счет особенностей хранения данных в event sourcing архитектуре у нас есть лог всех событий в системе. Тут есть нюансы, что если у вас шардированный лог эвентов, то получить точное состояние в каждый конкретный момент времени будет сложнее, но возможно по ссылке на конкретные версии разных объектов.</p></li>
    <li><p>Когда не хочется использовать транзакции</p><p>Важно сказать, что так же позитивно на пропускную способность влияет то, что мы избавляемся от транзакций.</p></li>
    <li><p>Когда нужна высокая пропускная способность</p><p>Это достигается за счет CQRS, фоновой обработки событий и прочих полезных свойств, которые возникают у системы с применением event-sourcing. Так же акторы хорошо дружат с эвент-сорсингом и могут быть инструментом контроля нагрузки за счет кеширования данных в памяти и избавления от состояний гонки про обновлении данных.</p></li>
    <li><p>Когда хочется получить однонаправленный поток данных</p><p>Когда в системе возникает какое-то событие, мы просто записываем новую строчку в конец лога. Затем консьюмеры обрабатывают эти записи последовательно изменяя проекции, задачи, строят отчеты, переливают данные куда-нибудь ещё, либо создавая новые события, которые снова попадают в лог.</p><p>Система становится очень понятной за счет того, что у каждого типа операций есть определенное место в коде.</p></li>
    <li><p>Когда не хочется терять данные by design</p><p>В архитектурах где предполагается хранение снимков состояний объектов в базе данных предполагается перезапись данных при изменении состояния объектов. Обычно в таких системах теряется информация о том, что послужило причиной изменения состояния. Когда мы храним события, вместо снимков состояния мы обладаем полной информацией о том, что, когда и почему происходило в системе и ничего не теряем by design.</p></li>
   </ul>
   <h3>Когда не применять</h3>
   <ul>
    <li><p>Когда у вас простой домен. Эвенты вида created → updated → updated … → deleted имеют мало смысла с точки зрения эвент-сорсинга и в таком случае можно ограничиться более простым подходом. В таком случае можно рассмотреть применение CRUD или хранения ревизий объектов. Например, в <a href="https://wordpress.org/documentation/article/revisions/" rel="noopener noreferrer nofollow">wordpress</a> посты хранят в виде ревизий.</p></li>
    <li><p>Когда необходима строгая согласованность между read и write моделями данных. В таком случае скорее всего не обойтись без транзакций и эвент-сорсинг теряет свои полезные свойства.</p></li>
   </ul>
   <h2>Литература</h2>
   <p>Тут некоторые из материалов и технологий, которые так или иначе повлияли на мое понимание эвент-сорсинга.</p>
   <h3>Статьи</h3>
   <ul>
    <li><p><a href="https://itnext.io/event-sourcing-explained-b19ccaa93ae4" rel="noopener noreferrer nofollow">https://itnext.io/event-sourcing-explained-b19ccaa93ae4</a></p></li>
    <li><p><a href="https://www.eventstore.com/blog/keep-your-streams-short-temporal-modelling-for-fast-reads-and-optimal-data-retention" rel="noopener noreferrer nofollow">https://www.eventstore.com/blog/keep-your-streams-short-temporal-modelling-for-fast-reads-and-optimal-data-retention</a></p></li>
    <li><p><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" rel="noopener noreferrer nofollow">https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</a></p></li>
    <li><p><a href="https://www.confluent.io/blog/infinite-kafka-data-storage-in-confluent-cloud/" rel="noopener noreferrer nofollow">https://www.confluent.io/blog/infinite-kafka-data-storage-in-confluent-cloud/</a></p></li>
    <li><p><a href="https://dev.to/olibutzki/why-event-sourcing-is-a-microservice-anti-pattern-3mcj" rel="noopener noreferrer nofollow">https://dev.to/olibutzki/why-event-sourcing-is-a-microservice-anti-pattern-3mcj</a></p></li>
   </ul>
   <h3>Книги</h3>
   <ul>
    <li><p>Domain-Driven Design by Eric Evans</p></li>
    <li><p>Implementing Domain-driven Design by Vaughn Vernon</p></li>
    <li><p>Building Microservices by Sam Newman</p></li>
    <li><p>Building Event-Driven Microservices by Adam Bellemare</p></li>
   </ul>
   <h3>Технологии</h3>
   <ul>
    <li><p><a href="https://learn.microsoft.com/en-us/dotnet/orleans/" rel="noopener noreferrer nofollow">Microsoft Orleans</a></p></li>
    <li><p><a href="https://learn.microsoft.com/en-us/azure/cosmos-db/introduction" rel="noopener noreferrer nofollow">Microsoft Azure CosmosDB</a></p></li>
    <li><p><a href="https://www.lightbend.com/akka" rel="noopener noreferrer nofollow">Lightbend Akka</a></p></li>
    <li><p><a href="https://kafka.apache.org/" rel="noopener noreferrer nofollow">Apache Kafka</a></p></li>
    <li><p><a href="https://www.eventstore.com/" rel="noopener noreferrer nofollow">Event Store DB</a></p></li>
   </ul>
   <h2>Ищу работу</h2>
   <p>Я открыт к предложениям о работе тимлидом, backend-разработчиком, fullstack-разработчиком, SRE или консультантом. Для меня важны понятные перспективы продукта, над которым нужно будет работать, сильная команда и достойная оплата. Остальное обсуждаемо :-)</p>
   <p>Мой CV — <a href="https://www.notion.so/Dmitrii-Kochnev-Software-Engineer-c3f23e9a240e42869fdbb3a4487f09fe" rel="noopener noreferrer nofollow">тут</a>, моя телега — <a href="https://t.me/aurokk" rel="noopener noreferrer nofollow">@aurokk</a></p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->