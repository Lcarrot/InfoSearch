<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/081/028/59c/08102859c7d9a718a98ab8142e88f7cb.png" width="780" height="439" data-src="https://habrastorage.org/getpro/habr/upload_files/081/028/59c/08102859c7d9a718a98ab8142e88f7cb.png">
    <figcaption></figcaption>
   </figure>
   <p>Рынок интернета вещей растет значительными темпами и разработка кода для&nbsp;микроконтроллеров важна для&nbsp;любых проектов, где подразумевается наличие какого‑либо вспомогательного оборудования или&nbsp;носимого устройства. Для&nbsp;разработки программного обеспечения под&nbsp;встраиваемые микроконтроллеры сейчас (кроме C/C++) можно использовать многие другие технологии (например, <a href="https://habr.com/ru/company/otus/blog/663118/">TinyGo</a>, <a href="https://github.com/sony/flutter-elinux">Dart/Flutter</a>, <a href="https://www.rust-lang.org/what/embedded">Rust</a>), так&nbsp;же как&nbsp;и Python в&nbsp;наборе библиотек MicroPython, который работает как&nbsp;со своей платой (pyboard), так и с&nbsp;другими микроконтроллерами (например платами на&nbsp;процессорах ESP8266&nbsp;или&nbsp;STM32). В&nbsp;этой статье мы рассмотрим общие подходы к&nbsp;разработке и тестированию программного обеспечения для&nbsp;микроконтроллеров с&nbsp;использованием Python.</p>
   <p>MicroPython предоставляет упрощенную реализацию стандартной библиотеки python и несколько дополнительных модулей для&nbsp;взаимодействия с&nbsp;оборудованием. При&nbsp;использовании pyboard основная функциональность будет доступна через модуль pyb, но&nbsp;в&nbsp;целом может использоваться следующий набор модулей:</p>
   <ul>
    <li><p><code>machine</code>&nbsp;— подключение к&nbsp;оборудованию (например, может использоваться для&nbsp;получения или&nbsp;изменения тактовой частоты)</p>
     <ul>
      <li><p><code>Pin</code>&nbsp;— доступ к&nbsp;цифровому пину (например, переключение управляемого устройства)</p></li>
      <li><p><code>ADC</code>&nbsp;— доступ к&nbsp;аналоговому пину (например, получение с&nbsp;внешнего датчика температуры или&nbsp;освещенности)</p></li>
      <li><p><code>I2C</code>&nbsp;— доступ к&nbsp;устройствам шины (часто используется для&nbsp;подключения внешних датчиков, каждое устройство имеет уникальный идентификатор)</p></li>
      <li><p><code>SPI</code>&nbsp;— высокоскоростная шина (например, может использоваться для&nbsp;подключения к&nbsp;Card reader или&nbsp;к&nbsp;LCD‑экранам)</p></li>
      <li><p><code>PWM</code>&nbsp;— использование ШИМ (широтно‑импульсной модуляции) на&nbsp;цифровом пине (например, для&nbsp;управления яркостью подключенного индикатора)</p></li>
      <li><p><code>RTC</code>&nbsp;— встроенные часы (если есть)</p></li>
      <li><p><code>WDT</code>&nbsp;— таймер для&nbsp;перезапуска устройства при&nbsp;зависании (Watch‑Dog Timer)</p></li>
      <li><p><code>UART</code>&nbsp;— доступ к&nbsp;последовательному порту (консоли), часто используется для&nbsp;отладки, поскольку микроконтроллер на&nbsp;компьютере разработки определяется как&nbsp;COM‑порт и через него можно считывать сообщения от&nbsp;устройства и отправлять команды на&nbsp;устройства</p></li>
     </ul></li>
    <li><p><code>bluetooth</code>&nbsp;— доступ к&nbsp;управлению устройствами</p></li>
    <li><p><code>btree</code>&nbsp;— простая база данных</p></li>
    <li><p><code>cryptolib</code>&nbsp;— поддержка криптографии (шифрование, хэши, подпись)</p></li>
    <li><p><code>framebuf</code>&nbsp;— работа с&nbsp;экранным буфером</p></li>
    <li><p><code>neopixel</code>&nbsp;— поддержка светодиодных панелей (WS2812)</p></li>
    <li><p><code>network</code>&nbsp;— настройка сети (в том числе WiFi на&nbsp;поддерживаемых устройствах)</p></li>
    <li><p>значительная часть модулей из&nbsp;стандартной библиотеки Python (и поддержка синтаксиса с&nbsp;async/await и большинства возможностей Python 3.6)</p></li>
   </ul>
   <p>Также представлены модули для&nbsp;поддержки esp32, esp8266&nbsp;и другие. Кроме этого доступны модули для&nbsp;управления генерацией байт‑кода и вызова внешних инструмент кросс‑компиляции, благодаря чему возможно создать поддержку реализации другой целевой аппаратной архитектуры (для создания среды исполнения и соответствующих модификаций байт‑кода, если это требуется).</p>
   <p>Для&nbsp;поддержки запуска кода micropython нужна поддержка со стороны прошивки на&nbsp;устройстве, которая может&nbsp;быть установлена на&nbsp;плату через esptool (для ESP8266/ESP32) или <a href="https://dfu-util.sourceforge.net/releases/">dfu‑util</a>, при&nbsp;этом на&nbsp;pyboard прошивка изначально поддерживает запуск байт‑кода micropython. Для&nbsp;редактирования приложения можно использовать как&nbsp;расширения для&nbsp;IDE Jetbrains&nbsp;лии VSCode, так и специализированные <a href="https://codewith.mu/">MuEditor</a>, <a href="https://dfrobot.gitbooks.io/upycraft/content/">uPyCraft</a>, <a href="https://thonny.org/">Thonny IDE</a>, <a href="https://microide.com/">microIDE</a>.</p>
   <p>Рассмотрим на&nbsp;примере простого приложения, которое будет управлять включением лампы в&nbsp;зависимости от&nbsp;уровня освещенности. Внешний датчик освещенности будет подключен к&nbsp;аналоговому входу Y4&nbsp;(или A0&nbsp;для&nbsp;плат Arduino), управляющее устройство (реле)&nbsp;— к&nbsp;цифровому выходу Y12&nbsp;(или GPIO12&nbsp;для&nbsp;ESP8266).</p>
   <p>Создадим простую реализацию и попробуем ее протестировать:</p>
   <pre><code class="python">import machine
import pyb
import time

turned_on = False
y4 = machine.Pin('Y4')
y12 = machine.Pin('Y12')

while True:
  adc=pyb.ADC(y4)
  if adc&gt;128:
    if not turned_on:
        turned_on = True
        y12(1)
  else:
    if turned_on:
        turned_on = False
        y12(0)
  time.sleep(1)</code></pre>
   <p>Для&nbsp;установки на&nbsp;аппаратное устройство установим дополнительно mpremote:</p>
   <pre><code class="bash">pip install mpremote
mpremote exec control.py</code></pre>
   <p>Mpremote также позволяет получить доступ к&nbsp;repl‑консоли (mpremote repl), управлять файловой системой (cat, ls, cp, rm, mkdir, rmdir, touch). По&nbsp;умолчанию mpremote автоматически находит подключенное по&nbsp;usb‑serial устройство.</p>
   <p>При&nbsp;компиляции под&nbsp;STM32&nbsp;требуется дополнительно установить кросскомпиляторы ARM GCC Toolchain (apt install arm‑none‑eabi‑gcc arm‑none‑eabi‑binutils arm‑none‑eabi‑newlib для&nbsp;Debian/Ubuntu). Micropython включает возможность компиляции python‑кода в&nbsp;байт‑код для&nbsp;запуска на&nbsp;микроконтроллере, для&nbsp;этого используется инструмент mpy‑cross, а&nbsp;также позволяет устанавливать дополнительные пакеты с&nbsp;github через инструмент mip.</p>
   <p>Для&nbsp;запуска тестов на&nbsp;устройстве можно использовать run‑tests.py из&nbsp;каталога tests в&nbsp;micropython. Тесты располагаются в&nbsp;подкаталогах tests/ и каждый тест пропускается через компилятор mpy‑cross и запускается на&nbsp;устройстве. Собственные тесты также могут&nbsp;быть добавлены к&nbsp;существующим тестам библиотеки, а&nbsp;также тесты могут&nbsp;быть реализованы как&nbsp;обычные приложения, которые могут&nbsp;быть запущены через mpremote.</p>
   <p>Основная сложность в&nbsp;тестировании на&nbsp;реальных устройствах будет в&nbsp;вопроизведении сценариев управления, которые зависят от&nbsp;внешних условий. Один из&nbsp;вариантов&nbsp;— создание обратной связи на&nbsp;устройстве (например, соединение выходных и входных пинов для&nbsp;контроля переключения, или&nbsp;PWM‑выходов с&nbsp;аналоговыми входа для&nbsp;симуляции изменения состояния датчиков). Второй вариант&nbsp;— использование симуляторов (например для <a href="https://wokwi.com/projects/new/micropython-esp32?template=micropython-esp32">ESP32</a> можно использовать wokwi), здесь также можно объединить пины и выполнять контроль через чтение состояния контрольных пинов (подключенных к&nbsp;выходным). Также можно установить <a>Open Source симулятор ESP32</a> и взаимодействовать непосредственно с&nbsp;ним, в&nbsp;этом случае можно изменять значения входных пинов и проверять значения выходных (через подключение виртуального устройства wokwi‑logic‑analyzer, которая может сохранять историю изменения значений на 8&nbsp;каналах в&nbsp;формате.VCD‑файла, который может&nbsp;быть проанализирован программно или&nbsp;визуализирован через <a href="https://gtkwave.sourceforge.net/">GTKWave</a>). Для&nbsp;описания схемы соединения устройств симулятор получает json‑файл и он может&nbsp;быть разработан в&nbsp;соответствии с&nbsp;реализацией тестируемого устройства.</p>
   <p>Таким образом можно создавать и тестировать приложения для&nbsp;микроконтроллеров с&nbsp;использованием Python. К&nbsp;сожалению, ценой удобства является некоторая потеря производительности (см. <a href="https://www.mdpi.com/2079-9292/12/1/143">сравнение</a> C++, TinyGo, Rust и MicroPython), но&nbsp;для&nbsp;большинства задач автоматизации с&nbsp;использованием микроконтроллеров производительность не&nbsp;имеет решающего значения, а&nbsp;удобство разработки и использование привычного языка программирования значительно упрощает создание прошивок для&nbsp;микроконтроллеров.</p>
   <p>В&nbsp;конце этой статьи хочу порекомендовать вам интересный урок от&nbsp;моих коллег из&nbsp;OTUS по&nbsp;теме: «Основы работы с&nbsp;PostgreSQL в&nbsp;Python». Зарегистрироваться на&nbsp;урок можно по <a href="https://otus.pw/qw3J/">этой ссылке</a>.</p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->