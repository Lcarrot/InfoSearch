<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-1">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <img src="https://habrastorage.org/r/w780q1/webt/5r/sc/hk/5rschkrhamki90mafs57w7ivk7u.jpeg" data-src="https://habrastorage.org/webt/5r/sc/hk/5rschkrhamki90mafs57w7ivk7u.jpeg" data-blurred="true"><br> <br> Куда и зачем смотреть, что поменять, чтобы в два раза ускорить командное время от взятия задачи в работу до её попадания в артефакты продакшена? Как при этом не мучить бесполезной рутиной команду, а сделать её счастливее? Для этого нужно автоматизировать подсчёты Cycle Time и научиться правильно читать графики. Посмотрим, как это сделать.<br> <br> Меня зовут Никита Дубко, я беларус и мастер подземелий в D&amp;D. А ещё — доброжелюбный бородач из подкаста «Веб-стандарты» и руководитель службы разработки HR Tech Яндекса. Моя задача — оптимизация процессов. О том, как я это делаю, и пойдёт речь в статье. Текст написан по мотивам моего <a href="https://teamleadconf.ru/spb/2022/abstracts/8346">доклада</a> на TeamLead Conf 2022.<br> <a name="habracut"></a><br>
   <h2>Эффективность</h2><br> Начнём с того, что такое эффективность. В Википедии сказано, что эффективность — «это соотношение между достигнутым результатом и использованными ресурсами». Красивое определение, но давайте посмотрим, как с ним работать. <br> <br> Рассмотрим Scrum. В нём есть разные методики работы с теми или иными артефактами. Можно заставить команду бежать одну или две недели, то есть устроить спринт. Также можно попытаться оценивать задачи с помощью сторипоинтов (SP): вот эта задача на 500 сторипоинтов, а эта — на 3. Таким образом, эффективность можно рассчитать, измерив, на сколько сторипоинтов команда выполнила работы в спринте:<br> <br> E = SP / спринт<br> <br> Но действительно ли, чем больше сторипоинтов, тем выше эффективность? Иногда бывает так, что много SP запихивают в одну задачу. Кажется, что всё здорово, спринт закрыт, но у команды не появляется ощущение принесённой пользы, а эффект для пользователя непонятен. Ещё может быть вот такой интересный бёрндаун:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/co/x0/fs/cox0fsjfb3zac4huiz1eax0yowa.jpeg" data-src="https://habrastorage.org/webt/co/x0/fs/cox0fsjfb3zac4huiz1eax0yowa.jpeg" data-blurred="true"><br> <br> Потому что не всегда получается взять и всё сделать идеально. В 2021 году на Saint TeamLead Conf был классный доклад Яна Ашенкампфа «Как я выбираю, кому повысить зарплату?». Там он разбирал много примеров, показывающих, почему любой способ оценить эффективность по количественным метрикам обречён на манипуляции со стороны команды. <br> <br>
   <div class="spoiler" role="button" tabindex="0"><b class="spoiler_title">Смотреть доклад</b>
    <div class="spoiler_text">
     <div class="oembed">
      <div class="tm-iframe_temp" data-src="https://embedd.srv.habr.com/iframe/63e399b5a9cdfde04233099d" data-style="" id="63e399b5a9cdfde04233099d" width=""></div>
     </div>
    </div>
   </div><br> Например, если вы будете оценивать строчки кода, то рано или поздно появится правило в линтере, которое будет мотивировать добавлять эти самые строчки где попало. А если оценивать количество коммитов, то любая задача начнёт дробиться на мелкие правки, чтобы коммитов стало больше. Ну и даже, если оценивать по сторипоинтам, то команда сможет обосновать, почему задача была выполнена не за 2 SP, а за 8. Потому что команда, как правило, сама устанавливает «стоимость» 1 SP, при этом она же и оценивает задачи — чувствуется неувязка.<br> <br> А что, если попробовать оценивать не по сторипоинтам, а по количеству фич в спринте? То есть:<br> <br> E = количество фич / спринт<br> <br> Ведь <b>пользователи ждут именно фичи</b>. Им не важно, сколько сторипоинтов вы на это потратили и сколько ретро провели, чтобы выкатить фичу быстрее. Они ждут, когда в продакшене появится то, чего они хотят. <br> <br> Допустим, что фича — это тикет в трекере задач. Тут можно подсмотреть, как работают адепты Kanban.<br> <br> В Kanban есть Cycle Time. <b>Cycle Time — это время, которое задача находилась в разработке от момента, когда ей начали заниматься, до момента, когда она прошла фазу конечной поставки</b>. С точки зрения тикета, это время перехода из In Progress в Closed, то есть в продакшен. Будем считать, что релиз — это тот самый статус Closed. Если на этот переход тратить меньше времени, фича будет быстрее попадать в прод. А чем быстрее она окажется в проде, тем выше эффективность команды.<br> <br> Как с этим работать? Я расскажу вам две истории из личного опыта о том, как Cycle Time можно использовать в разных местах с разным объёмом задач. <br> <br>
   <h2>История №1: большой продукт</h2><br> Началось всё с того, что я стал скрам-подмастерьем. Принялся изучать, как эффективнее двигать процессы, как сделать команде хорошо. Со временем я стал техлидом, а потом, внезапно, — тимлидом. Когда проходишь этот путь, начинаешь понимать, где и что может болеть.<br> <br>
   <h4>Особенности Поиска</h4><br> Поиск — это большой проект с большой аудиторией. Процессы уже давно налажены — понятно, как и что с ними делать. Релизы там катаются дважды в день: вечером и утром. Они хорошо автоматизированы. Нужно просто успеть попасть на этот релизный паровозик, но в целом команда не зависит от того, когда катится релиз.<br> <br> У нас есть «зелёный» транк. Это такой подход, когда всё максимально покрывается тестами, чтобы что-то упало в CI на любую правку в коде, если тесты при этом не поправили. И даже если всё хорошо, тестировщики всё равно посмотрят релиз. Не дай бог какой-то баг! Баги нельзя пропускать, потому что их увидят миллионы — такая особенность.<br> <br>
   <h4>Статусы задач</h4><br> Статусы задач в этом процессе выкатки были такие:<br> <br>
   <ul>
    <li><b>Open</b> — менеджер завёл тикет, но пока в нём нет ничего, кроме описания.</li>
    <li><b>Need info</b> — разработчик начал что-то делать, но ему не хватает информации. Например, где дизайн или указаний о том, что делать с бэкендом.</li>
    <li><b>In progress</b> — разработчик уже работает над задачей.</li>
    <li><b>In review</b> — разработчик написал код, закоммитил и ждёт, когда его коллеги придут и скажут, где всё замечательно, а где нужно поправить.</li>
    <li><b>Review completed</b> — ревью пройдено, можно работать с тикетом дальше. Этот промежуточный статус иногда очень полезен для торможения тикета.</li>
    <li><b>Ready for test</b> — статус говорит тестировщикам, какие задачи можно забирать.</li>
    <li><b>Testing</b> — идёт тестирование.</li>
    <li><b>Tested</b> — задача протестирована.</li>
    <li><b>Ready for Dev</b> — тикет готов к тому, чтобы его залили в основную ветку, которая называется Trunk.</li>
    <li><b>Dev</b> — код попал в ветку Trunk и готов к выкатке релиза.</li>
    <li><b>Release candidate</b> — код попал в релиз, который сейчас едет в продакшен.</li>
    <li><b>Closed</b> — всё классно, код в продакшене.</li>
   </ul><br> Важно объяснить команде значение всех этих статусов — особенно новичкам. Когда люди обладают общим понятийным аппаратом, они не задают вопрос, почему нужно переводить тикет в такой-то статус. Для этого, например, можно завести вики-страничку, документацию или просто давать информацию на онбординге. Ещё можно диаграмму в Miro нарисовать и пошарить со всеми. <br> <br> Как считать, сколько тикет находился в каждом статусе? С одной стороны, можно зайти в трекер, покликать и подсчитать с калькулятором, сколько тикетов выполнено, а сколько — в работе. <br> <br> С другой стороны, мы же технари. Почти у всех трекеров задач есть API. Где-то он платный, где-то — бесплатный. Через API можно, как правило, брать и получать данные скриптами. Не надо делать ничего руками, пускай страдают машины. Тем более, что машины могут строить сложные внутри, но удобные пользователям графики.<br> <br>
   <h4>Графики</h4><br> Как работают эти графики? Что на них происходит? Во-первых, есть <b>фильтр задач</b>.<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/9h/wi/o8/9hwio8nw5osj7eapszx3gluomv0.jpeg" data-src="https://habrastorage.org/webt/9h/wi/o8/9hwio8nw5osj7eapszx3gluomv0.jpeg" data-blurred="true"><br> <br> В вашем таск-трекере может быть много разных задач, они лежат в разных очередях, с ними работают разные команды и так далее. Поэтому вы собираете фильтр — его, при необходимости, можно сделать кастомным внутри очереди. С помощью этого фильтра вы говорите графику, с какими тикетами ему работать.<br> <br> Во-вторых, есть <b>скользящее окно</b>. Что это и зачем оно? Представим, что мы считаем, как долго задачи находились в статусах от In progress до Closed. Возьмём задачи, которые перешли в Closed за последние 28 дней. Это нам показывает график:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/rz/ps/ah/rzpsahztlc_hdwntd6s-yjqno5e.jpeg" data-src="https://habrastorage.org/webt/rz/ps/ah/rzpsahztlc_hdwntd6s-yjqno5e.jpeg" data-blurred="true"><br> <br> Но если мы будем просто смотреть на каждую задачу отдельно, то нормальной статистики не увидим. Будет много выбросов, зависимостей от встреч в календаре, фаз луны. Такие графики очень тяжело анализировать. Нужно взять скользящее окно и провести его по заданному перцентилю.<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/6s/yw/6l/6syw6lqgmu9_tjjlikp2eqhd6h0.jpeg" data-src="https://habrastorage.org/webt/6s/yw/6l/6syw6lqgmu9_tjjlikp2eqhd6h0.jpeg" data-blurred="true"><br> <br> 85-й перцентиль в окне в 28 дней — это значение метрики, в которое попадает 85% задач за эти 28 дней. Оно и попадёт на график.<br> <br> Самое классное, что вы можете использовать скользящее окно, чтобы ставить цели перед командой. Например, если вы хотите ускориться за следующие полгода, можно выставить скользящее окно в 6 месяцев, и позднее оно покажет, как вы продвинулись в деле улучшения эффективности работы с тикетами.<br> <br> В-третьих, есть второй <b>график, который показывает все статусы</b> с таким же скользящим окном и перцентилем:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/vu/s9/3x/vus93xmpyfxadfdyqmkgfcksjac.jpeg" data-src="https://habrastorage.org/webt/vu/s9/3x/vus93xmpyfxadfdyqmkgfcksjac.jpeg" data-blurred="true"><br> <br> Можно также выделять конкретные статусы и смотреть на их динамику:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/le/fs/he/lefshexfhwxwkit2qu1gnfrhk6c.jpeg" data-src="https://habrastorage.org/webt/le/fs/he/lefshexfhwxwkit2qu1gnfrhk6c.jpeg" data-blurred="true"><br> <br> И, наконец, есть <b>график, который показывает, за сколько была выполнена каждая отдельная закрытая задача</b>:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/6f/n6/s9/6fn6s9ygsdogihlp4nhctqkc9ki.jpeg" data-src="https://habrastorage.org/webt/6f/n6/s9/6fn6s9ygsdogihlp4nhctqkc9ki.jpeg" data-blurred="true"><br> <br> Это тоже полезный инструмент, потому что здесь можно выцепить аномалии. Например, тикет потенциально был простым, но на графике видно, что его закрыли за два или три месяца — повод присмотреться внимательнее.<br> <br>
   <h4>Как сделать лучше?</h4><br> Задача оптимизаторов — <b>минимизировать время в статусе</b>. Мы смотрим на эти графики и пытаемся придумать, как сделать лучше. Конечно, самый простой способ — прийти в команду и попробовать заставить её работать быстрее, сказав: «Тестировщик, ты чего медленно тестируешь? Давай быстрее». Но это вряд ли сработает. По-хорошему, нужно спрашивать у команды, что ей мешает делать быстрее. <b>Что нужно сделать внутри команды, чтобы ей стало лучше?</b><br> <br>
   <h4>Конвейерный метод</h4><br>
   <div style="text-align:center;">
    <img src="https://habrastorage.org/r/w780q1/webt/tn/pg/5a/tnpg5aznlv790vx9hjf5piydk3i.jpeg" width="300" data-src="https://habrastorage.org/webt/tn/pg/5a/tnpg5aznlv790vx9hjf5piydk3i.jpeg" data-blurred="true">
   </div><br> Это Генри Форд. В 1914 году он внедрил конвейерный метод, перевернув индустрию — один человек теперь не должен был отвечать за всё, ведь появился выстроенный процесс. Каждый делает одну часть работы и передаёт её дальше. Причём значительную долю задач взяли на себя машины. Если присмотреться, движение тикетов — это тоже в какой-то мере конвейер доставки задач в продакшен. <br> <br> Я выписал три принципа оптимизации производительности труда по Форду:<br> <br>
   <ol>
    <li>Ограничивать число операций, которые выполняет рабочий. Если мы говорим про тестировщика или разработчика, то нужно посмотреть, что он делает, и убрать лишнее и ненужное из этого процесса.</li>
    <li>Приближать задачу к исполнителю. Разработчики должны не просто продвигать тикеты и внедрять код, а понимать, зачем они это всё делают, иметь продуктовое видение.</li>
    <li>Учитывать последовательность выполнения операций. Если мы оптимизируем процесс в каком-то одном месте, в другом он может сломаться. Так бывает. Поэтому нужно проводить ретро.</li>
   </ol><br>
   <h4>Ретро про процессы</h4><br> Поговорите с командой, принесите ей графики и обсудите, почему где-то работа стала идти медленнее, что можно с этим сделать. Прямо такая мини психологическая сессия. Она много чего покажет, если у вас с командой доверительные отношения.<br> <br> Вот какие вопросы можно задавать:<br> <br>
   <ul>
    <li>Что хорошо в процессах? Что нужно закрепить?</li>
    <li>Что болит? Где стало плохо? Почему процессы замедлились?</li>
    <li>Как улучшить процессы? Что мы можем сделать, чтобы не болело?</li>
   </ul><br>
   <h4>Принцип Парето</h4><br>
   <div style="text-align:center;">
    <img src="https://habrastorage.org/r/w780q1/webt/jg/bw/7q/jgbw7qloweiwcqc91m7redgebj0.jpeg" width="250" data-src="https://habrastorage.org/webt/jg/bw/7q/jgbw7qloweiwcqc91m7redgebj0.jpeg" data-blurred="true">
   </div><br> Это Вильфредо Парето — человек, который научил менеджеров использовать числа 20 и 80 где попало. Принцип Парето гласит, что <b>20% усилий приводят к 80% результата</b>. Фишка в том, что, конечно, команда может нагенерировать много идей — обалденных и не очень — однако не всегда они реализуемы и по-настоящему полезны. Например, у нас была идея убрать встречу об оценке задач из календаря и переложить этот муторный процесс на ML. Казалось бы, классная и современная идея. У нас есть исторические знания о старых тикетах, берём их и просто скармливаем модели. А она уже пусть оценит, сколько там было сторипоинтов и реального времени на разработку. Но вот нюанс: тикеты не всегда хорошо заполнены. Иногда это просто заголовок, что, прямо скажем, грустно. И участники команды не всегда корректно присваивают статусы тикетам. К тому же, теряется очень важный этап обсуждения сути<br> <br>
   <h4>Что мы сделали в нашей команде?</h4><br>
   <ul>
    <li><b>Стали реализовывать простые идеи и сделали автоматизацию призывов в тикеты</b>. Теперь, когда нужно, чтобы тестировщик посмотрел ту или иную задачу, трекер призывает его в комментарии через триггеры, а ещё присылает на почту письмо с призывом. Выглядит это примерно так. Допустим, назначается демо в конце спринта. Тогда трекер просит через триггер заполнить блок «Тезисы для демо внутри тикета»:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/cg/ub/nn/cgubnndommswqo0unykega95cwa.jpeg" data-src="https://habrastorage.org/webt/cg/ub/nn/cgubnndommswqo0unykega95cwa.jpeg" data-blurred="true"><br> <br> Человеку, который собирает презентацию для демо, почти ничего не нужно делать: он просто копирует тезисы из тикета. Такая небольшая автоматизация очень удобна и значительно экономит время. Ещё она помогает развивать продуктовое видение — люди лучше понимают, для чего они работают.</li>
    <li><b>Добавили умные подсказки-комментарии в нужные моменты</b>. Важно, чтобы человек был ближе к задаче. Когда разработчик переводит тикет в статус In Review, поднимается стенд с доработанной версией приложения, которую тут же можно тестировать. Триггер добавляет комментарий о том, как подготовить тикет к тестированию:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/hs/9m/gw/hs9mgwk1pqeh9hjprfirwbns7fo.jpeg" data-src="https://habrastorage.org/webt/hs/9m/gw/hs9mgwk1pqeh9hjprfirwbns7fo.jpeg" data-blurred="true"><br> <br> Это очень полезно новичкам. Тестировщики иногда меняются, поэтому для сменщика, который, например, работает вместо заболевшего коллеги, процессы будут новыми. В таком случае нужно просто перевести тикет в статус Testing. Тестировщику тут же придёт в комментарии форма с чекбоксами, ссылками и инструкциями, что нужно проверить:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/tb/4r/u5/tb4ru5bolgjbhtbocjxynp2ddh4.jpeg" width="450" data-src="https://habrastorage.org/webt/tb/4r/u5/tb4ru5bolgjbhtbocjxynp2ddh4.jpeg" data-blurred="true"></li>
    <li><b>Порой можно нарушать общие правила в части кросс-ревью</b>. Поиск большой — его делает огромное количество людей. Полезно делать «перекрёстное опыление», когда на код-ревью приходят разработчики из разных команд. Однако иногда это очень сильно тормозит Cycle Time, так как погружаться в чужой код долго, в бизнес-процессы другой команды — сложно, а релиз желательно выкатить уже завтра. Поэтому мы решили ревьювить код только у себя внутри. Но если вдруг кто-то захочет прийти, то пусть приходит — мы не будем игнорировать замечания и внесём правки в рамках техдолга.</li>
    <li><b>Написали генераторы кода</b>. Мы заметили особенность наших экспериментов: обёртка в коде у них везде повторяется. Сама генерация — очень банальная, она просто подставляет названия флагов («включателей» экспериментов) и правильно называет папки. Но такая генерация экономит огромное количество времени. Причём автогенерация может быть какой угодно. Можно взять и придумать инструмент, а затем протащить его тикетом в спринт. Например, инструмент, помогающий удобнее дебажить сниппеты. Так мы в Поиске делали сниппеты, а также отдельный инструмент под них, который принимает JSON и рисует сниппет такой же, как в проде, но без доступа к бэкенду. Если у вас, например, React-стек или Storybook, напишите какую-то обёртку, которая поможет посмотреть всё, что нужно.<br> <br> Ещё пример. Один человек в команде взял и написал полезного бота, которому передаётся ссылка на борду со спринтом, а сам он ходит по тикетам и собирает из них презентацию для демо. Так человек сэкономил и своё время, и помог всей команде.</li>
    <li><b>Завели шаблоны тикетов</b>. Если какое-то поле не заполнено, в тикете оно выделяется жёлтым или красным цветом. Так можно проверять менеджеров на халтуру. Мы даже договорились, что плохо заполненные тикеты не будем брать в работу.</li>
    <li><b>Придумали, как поднять команде настроение</b>. Когда мы добавляем автоматизацию, появляется слишком много роботов, но слишком мало настроения. Мы начали разбавлять описания тикетов и комментарии в них мемами и похвалой.</li>
    <li><b>Оптимизировали календарь встреч</b>. Мы выяснили, что ребятам не нравится, когда за встречей на 15 минут следует получасовой перерыв, после которого — снова встреча на 15 минут и так далее. В таких условиях работать невозможно. Поэтому мы прошлись по календарю и <b>выпилили ненужные встречи</b> к чёрту.</li>
    <li><b>Сделали отбивки по Cycle Time</b>. Графики Cycle Time можно взять и вставить в комментарии через iframe, чтобы показать, какой Cycle Time был у той или иной задачи. Мы назвали это <b>«отбивки в тикет с Cycle Time»</b>. Для тех, кто занимается оптимизацией, это очень удобно. Если вдруг проявилась какая-то аномалия, можно зайти в тикет и посмотреть:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/xt/-q/ob/xt-qobr960x5utdyzp_-uxwscom.jpeg" data-src="https://habrastorage.org/webt/xt/-q/ob/xt-qobr960x5utdyzp_-uxwscom.jpeg" data-blurred="true"><br> <br> Здесь, например, тикет долго висел в статусах Need Info и Ready For Test — тестировщик не приходил.<br> <br> Ещё удобно, что включается эффект наблюдателя — человеку, который выполнял эту задачу, тоже приходит отбивка. Таким образом, команда сама начинает задумываться, что пошло не так.<br> <br> Как мы это внедрили? В команде был <b>ответственный за Cycle Time</b> — я. Сейчас этим занимается кто-то другой, но такая роль есть в каждой команде. В целом, это тот же человек, который смотрит на графики. Возможно, у вас им может стать скрам-мастер.</li>
    <li><b>Оптимизация должна быть на пользу</b>, не должна мешать работе команды. Именно для этого стоит проводить ретро. Когда вы собираетесь на ретро, важно, чтобы команда превращала свои <b>обещания в тикеты</b>. И, естественно, важно периодически проводить <b>ретро про процессы</b> — смотреть, что помогает, а что мешает.<br> <br> Ещё у нас появилась прикольная штука — <b>клуб по интересам</b>. Там люди, которые оптимизируют Cycle Time, стали обсуждать разные интересные фишки: что они сделали и где собрали какой-то инструмент. Это позволило делиться идеями.</li>
    <li><b>Мы устроили багатоны</b>. Если баги не критичные, мы не чиним их в течение всего спринта, а выделяем для этого отдельные дни — багатоны. Чем это полезно? Когда мелкие баги прилетают в течение недели, они меняют контекст. Например, я занимался большой фичей, но, вдруг, переключился на мелкий баг, для которого нужно писать тесты. В результате — фича не доделана. Это очень тормозит разработку. Теперь же мы с командой в один день просто накидываемся на баги, и, не поверите, так мы стали лидерами по ZBP — Zero Bug Policy.</li>
    <li><b>Потраченное на внедрение улучшалки время должно привести к экономии и/или приросту настроения в будущем</b>. Это важно, потому что если команда довольна своей работой, она работает чуть лучше и эффективнее. А если потратить много времени на сложную оптимизацию, но она в итоге почти не принесёт пользы, вряд ли команда будет рада.</li>
   </ul><br>
   <h4>Результаты</h4><br> Хочется поделиться результатами оптимизации:<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/cs/1o/v4/cs1ov4b0puj7xikopdiedfr8o9o.jpeg" data-src="https://habrastorage.org/webt/cs/1o/v4/cs1ov4b0puj7xikopdiedfr8o9o.jpeg" data-blurred="true"><br> <br> Если посмотреть на начало семестра, на 75-м перцентиле по плавающему окну в 28 дней тикеты находились в работе около 11 дней. А в конце семестра — 7 дней. То есть оптимизация достаточно сильная.<br> <br>
   <h2>История №2: почти аутсорс</h2><br> В своё время я перешёл из Поиска в HR Tech. В мае нам исполнится два года — команда HR Tech достаточно молодая. По процессам мы похожи на аутсорс, потому что у нас много проектов, некоторые из которых живут по полгода — то есть после запуска работают в режиме саппорта. Кроме того, мы используем разные стеки технологий, а сама команда небольшая.<br> <br> Сейчас я руковожу службой разработки. Сначала думал, что изученные на предыдущем месте практики оптимизации будут работать «из коробки», но всё оказалось иначе. Потому что большая продуктовая разработка — это одно, а маленькая команда с маленькими проектами — совсем другое. Здесь процессы большого продукта с налаженными схемами перестают работать.<br> <br>
   <h4>Проблемы</h4><br>
   <ul>
    <li><b>Не работало скользящее окно</b>. Потому что есть проекты на саппорте, в которых тикеты проходят путь от взятия в работу до релиза медленно.</li>
    <li><b>У разных команд отличаются релизные циклы и процессы</b>. Например, бэкендеры релизятся раз в неделю, фронтендеры — после мёржа в trunk. Нужно их всех как-то синхронизировать, чтобы ничего не сломалось.</li>
    <li><b>В некоторых местах не было такой крутой автоматизации, как в Поиске</b>. Поиск обмазан своими автоматизациями, но лучшие решения — кастомные. Их нельзя просто взять и переиспользовать, как есть.</li>
    <li><b>Проекты на поддержке</b>. Сложно вспоминать, что с ними делать. Такие проекты тяжело деплоить, потому что там легаси. И задачи там редкие — приходят раз в полгода.</li>
   </ul><br>
   <h4>Как я внедрял Cycle Time?</h4><br> Можно было бы сдаться и жить без графиков Cycle Time. Но я решил, что не смогу так. <br> <br>
   <ul>
    <li><b>Вместо общей очереди настроил свой график каждому проекту</b>. Теперь можно посмотреть, что происходит в проекте, используя фильтры для конкретной очереди.<br> <br> <img src="https://habrastorage.org/r/w780q1/webt/eo/9z/ei/eo9zeix2orikaq5v2s1rdvydxvy.jpeg" data-src="https://habrastorage.org/webt/eo/9z/ei/eo9zeix2orikaq5v2s1rdvydxvy.jpeg" data-blurred="true"></li>
    <li><b>Дополнительно сделал отдельную очередь и отдельные фильтры для задач</b>. Оптимизируя бэклог для графиков, я сделал для самого себя работу с бэклогом по проектам удобнее.</li>
    <li><b>Вместо времени до Closed начали измерять время до Merged</b>. Почему? Потому что есть проекты на саппорте, у которых релиз выкатывается раз в полгода. В этих случаях исправление багов и вливание изменений могут происходить уже после закрытия задачи.</li>
    <li><b>Начали работать над унификацией процессов, чтобы в командах было что-то общее</b>. Для этого мне пришлось сесть и нарисовать, как движется тикет:<br> <br> <a href="https://habrastorage.org/webt/ur/xl/ft/urxlftavbbv4yubrfs9ybmcewpa.jpeg"><img src="https://habrastorage.org/r/w780q1/webt/ur/xl/ft/urxlftavbbv4yubrfs9ybmcewpa.jpeg" data-src="https://habrastorage.org/webt/ur/xl/ft/urxlftavbbv4yubrfs9ybmcewpa.jpeg" data-blurred="true"></a><br> <sup>Кликабельно</sup><br> <br> На этой схеме объясняется, что должно происходить, когда тикет переходит из одного статуса в другой, какие статусы и переходы полезны, а какие — вредны.</li>
    <li><b>Каждому проекту пришлось выставить индивидуальный перцентиль</b>. Это необходимо, чтобы отсечь аномалии на графике. Дело в том, что есть проекты, в которых очень много задач. Для них стоит ставить 90-й перцентиль, так аномалии будут лучше видны. Но если брать проекты, где задач мало, лучше ставить 60-й перцентиль, так как из-за малой выборки получается очень много аномалий. С ними нужно разбираться отдельно.</li>
    <li><b>Важно было объяснить команде, что такое приборы для наблюдения</b>. Хотя эти графики изучает, в первую очередь, руководитель, команда тоже должна о них знать. Так обеспечивается эффект наблюдателя. Зачем? У меня был такой случай: я принёс графики Cycle Time, а команда никогда с ними не работала. Ребята подумали, что графики нужны, чтобы я следил, как медленно команда решает задачи. Мне пришлось объяснять, что это не слежка, а придумано для того, чтобы найти места, где можно оптимизироваться. Смысл графиков нужно объяснить всей команде и конкретно тем, кто против такого подхода, чтобы в целом все более или менее с ним согласились.</li>
    <li><b>В моём календаре появилась встреча с самим собой</b>. Раз в неделю примерно один час я трачу на изучение графиков и аномалий. Потом аномалии приношу, например, на ретро или подхожу к людям и спрашиваю, почему так получилось. Они знают, что я делаю это не для того, чтобы узнать, почему у них так медленно идёт тикет. Они знают, что я пытаюсь оптимизировать процесс, придумать какую-то автоматизацию.</li>
    <li><b>У нас появилось ретро про процессы с командой</b>. Оно привнесло в работу много интересного, потому что я в команде был новым человеком, а разработчики уже давно сидели с какими-то болями. Что мы выяснили на ретро? Низкий бас-фактор в некоторых проектах, иногда только один человек знал, как что-то делать. Эту проблему надо было решать.</li>
    <li><b>Получилось улучшить декомпозицию некоторых задач</b>. Теперь, когда менеджер приносит задачу, мы пробуем сделать в одном тикете бэкенд, а в другом — фронтенд. Или большую фичу дробим на самостоятельные кусочки, которые можно показать на стенде и протестировать независимо.</li>
    <li><b>Мы ускорили код-ревью</b> — перестали ждать, когда кто-то придёт на код-ревью, а начали прямо в чате команды писать: «Ребята, посмотрите, пожалуйста, #review_request».</li>
    <li><b>Выстроили новые процессы работы с дизайнерами</b>. В этом месте процессы шли медленнее, потому что у нас есть и внутри дизайнеры, и на аутсорсе. С ними нужно работать по-разному. Пришлось подумать, как сделать удобнее.</li>
    <li><b>Завели шаблоны для создания новых задач</b>. Причём для багов и фич шаблоны разные. Для багов важно уметь их воспроизвести, а для фич — понимать ожидаемый результат.</li>
    <li><b>Я сходил в команду инфраструктуры, они добавили автоматизацию — закрытие тикетов по релизу</b>. Теперь, когда выкатывается релиз, тикеты автоматически закрываются. Например, я качу релиз, в котором 20 тикетов, но мне не нужно проходить по каждому и закрывать руками. Экономия каких-то пяти минут, но каждый раз радует.</li>
    <li><b>В некоторых проектах убрали тестирование из PR, оставили только релизное</b>. Благодаря такому решению мы очень сильно ускорились в определённых местах.</li>
   </ul><br>
   <h4>Помогло ли это?</h4><br> Посмотрим на графики. <br> <br> <img src="https://habrastorage.org/r/w780q1/webt/iz/w7/az/izw7azvk4kho-rqc7q4q8kjgoso.jpeg" data-src="https://habrastorage.org/webt/iz/w7/az/izw7azvk4kho-rqc7q4q8kjgoso.jpeg" data-blurred="true"><br> <br> По этому фильтру работа началась приблизительно в июне, то есть мы с 19 дней на задачу ускорились до 9 дней. Результат ещё круче, чем в Поиске! <br> <br> Обратите внимание на зелёную линию. Это количество задач, которые попали на график. Мы стали чуть больше декомпозировать и, как следствие, выполнять больше задач.<br> <br>
   <h2>Итоги и советы</h2><br> <b>→ Графики Cycle Time — полезный инструмент</b>. Не считайте Cycle Time в Excel, попробуйте внутри команды сделать свой инструмент. Дайте задачу фронтендерам сверстать эти графики, бэкендерам — собрать для них данные. Это не сложно. Ещё и приятное переключение с рутины на сайд-проект.<br> <br> <b>→ Не мешайте команде делать работу</b>. Не нужно постоянно приходить к людям с предложением: «Давайте оптимизировать Cycle Time, давайте бежать быстрее». Команда хочет работать, а не оптимизировать ваши процессы и графики.<br> <br> <b>→ Убирайте мусор в процессах</b>. Везде, куда ни придёшь, есть легаси. Однако много от чего можно отказаться, избавиться от старья. Конечно, стоит спросить у команды, но иногда нужно просто взять и переписать проект, чтобы работа пошла в разы быстрее. Или посмотреть на встречу в календаре, на которой ничего полезного не происходит, и отменить её. Или вообще отказаться от всех встреч, кроме одного синка в неделю, а коммуникацию перенести в чат.<br> <br> <b>→ Донесите до команды, что Cycle Time — это не про наказание</b>. Этот инструмент не для того, чтобы следить и заставлять работать быстрее — он призван сделать процессы лучше.<br> <br> <b>→ Автоматизируйте рутину</b>. Вещи, которые можно переложить на скрипты, обязательно перекладывайте на скрипты. Многие делают руками и не задумываются, что можно ничего не делать, а только смотреть на результаты. <br> <br> <b>→ Попытайтесь сделать рутину веселее и проще</b>. Добавьте настроения в ваш трекер. <br> <br> <b>→ Обязательно спрашивайте у команды, где болит</b>. Если у вас где-то болит, это не значит, что у команды та же проблема. Может, у разработчиков всё нормально. Тут важно придумать, как поддерживать баланс.<br> <br> <b>→ Доверяйте инструментам, а не только ощущениям</b>. Вам может казаться, что процесс идёт плохо, а на приборах — отличные показатели. Или наоборот — может казаться, что стало лучше, а по инструментам — хуже. Но иногда к ощущениям тоже нужно прислушиваться.<br> <br> <b>→ При любой аномалии задавайте вопрос «Почему?»</b>. О каждой бесполезной встрече в календаре я спрашиваю: почему она произошла? Здесь явно что-то пошло не так в процессах. Может быть, нужно что-то автоматизировать или просто убрать какие-то задачи, не делать их больше никогда.<br> <br> <b>→ Иногда люди просто ленятся или не могут работать по объективным причинам</b>. Бывает такое, когда приходишь на работу, открываешь новости и работать не хочется. К этому тоже нужно относиться с пониманием.<br> <br> <b>→ Работа над процессами — не факультатив</b>. Если вы будете заниматься Cycle Time, не делайте это факультативно. Это ваша работа. Берёте тикет «Работа над процессами» и доводите его до ума в рабочее время. У меня, по крайней мере, не получалось факультативно.<br> <br> <b>→ Подсматривайте и не упарывайтесь</b>. Мы в взяли что-то из Scrum, подсмотрели что-то в Kanban, а в итоге получилось классно. Не упарывайтесь по процессам, потому что иногда слишком хочется оптимизировать, чтобы всё было идеально. Не нужно — помните про принцип Парето. Берите то, что ближе к вам, и пытайтесь в этих местах улучшиться.<br> <br> <b>→ Старайтесь делать команду счастливее</b>. Я искренне верю, что команда, которая довольна своей работой и радуется тому, что у неё мало рутины, начинает работать лучше. Моя личная статистика показывает, что это так.<br> <br> <b>→ Feature Time</b>. Можно попробовать оптимизировать, если с Cycle Time уже всё хорошо. Это классная метрика, но, внедряя её, важно выстроить работу с менеджерами. Feature Time используется, когда берётся не отдельный тикет, а эпики — например, когда мы целый экран хотим выпустить в прод. С этой важной метрикой тоже нужно уметь работать.<br> <br> <b>→ Lead Time</b>. Эта метрика измеряет время от момента, когда мы завели тикет, до момента, когда мы его закрыли. То есть не от взятия в работу, а от его появления в трекере. Используя эту метрику, можно находить «бриллианты» в бэклоге и чистить его от того, что никогда в работу не попадёт.<br> <br> Надеюсь, что эти две истории и перечисленные мной советы позволят вам достичь оптимального Cycle Time коротким путём, не получив местами болезненный опыт, который получил я. Материалы моих коллег тоже помогут — скоро пройдёт следующая TeamLead Conf, на которой можно будет подключиться к <a href="https://teamleadconf.ru/moscow/2023/yatrack">Яндекс треку</a> и другим нашим докладам.
  </div>
 </div>
</div> <!----> <!---->