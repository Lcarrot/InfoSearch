<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p><a href="https://microservices.io/patterns/microservices.html"><u>Микросервисная архитектура</u></a> в&nbsp;последние годы приобрела большую популярность. Но, несмотря на&nbsp;все ее преимущества, у&nbsp;нее есть и некоторые проблемы. Одна из&nbsp;них&nbsp;— сбор необходимых данных для&nbsp;передачи во&nbsp;фронтэнд. Здесь напрашивается простое и интуитивное решение&nbsp;— <a href="https://microservices.io/patterns/data/api-composition.html"><u>паттерн API composition</u></a> (композиция API). Это решение данной проблемы, но&nbsp;не&nbsp;идеальное. Например, в&nbsp;случае высоконагруженных и высокодоступных систем, вызов нескольких сервисов для&nbsp;создания только одного представления может&nbsp;быть неприемлемым. Нужно придумать что‑то другое. Давайте попробуем CQRS.</p>
   <h2>CQRS</h2>
   <p><a href="https://microservices.io/patterns/data/cqrs.html"><u>Паттерн CQRS</u></a>, описанный Крисом Ричардсоном,&nbsp;— альтернатива API Composition. Вместо сбора информации из&nbsp;нескольких источников создается специализированная read‑модель (модель чтения, модель представления), хранящая всю необходимую информацию. Read‑модель представляет собой отдельную базу данных, используемую только Edge‑сервисом (пограничный сервис) и, по&nbsp;сути, дублирующую данные. На&nbsp;рисунке ниже приведен пример, как&nbsp;может выглядеть высокоуровневая архитектура такого подхода.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/ce3/ce7/ad5/ce3ce7ad5eaaa3cfed77c934f93f0532.png" width="557" height="453" data-src="https://habrastorage.org/getpro/habr/upload_files/ce3/ce7/ad5/ce3ce7ad5eaaa3cfed77c934f93f0532.png">
    <figcaption></figcaption>
   </figure>
   <p>Однако CQRS&nbsp;— не&nbsp;избавит от&nbsp;всех проблем, связанных с&nbsp;запросами в&nbsp;микросервисной архитектуре. Наполнение read‑модели&nbsp;— довольно простая задача. Изменение схемы базы данных (например, добавление нового поля, которое должно отображаться в&nbsp;пользовательском интерфейсе)&nbsp;— куда сложнее.</p>
   <h2>Построение read-модели</h2>
   <p>Давайте посмотрим на&nbsp;рисунок ниже. У&nbsp;обоих событий (<code>SomethingHappened</code>, <code>SomethingElseHappened</code>) простая структура из&nbsp;двух полей. Но, допустим, нам нужна только часть информации каждого события. За&nbsp;извлечение необходимой информации из&nbsp;события и добавление его к&nbsp;соответствующей записи в&nbsp;базе данных отвечает Edge‑сервис. Запись в&nbsp;БД мы идентифицируем по <code>id</code> <a href="https://microservices.io/patterns/data/domain-event.html"><u>доменного события</u></a>.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/744/750/4e6/7447504e637fa67fb40e9ce075e9fde8.png" width="700" height="588" data-src="https://habrastorage.org/getpro/habr/upload_files/744/750/4e6/7447504e637fa67fb40e9ce075e9fde8.png">
    <figcaption></figcaption>
   </figure>
   <p>В&nbsp;конце концов, когда мы обработаем все доменные события, будет построена первая версия read‑модели, которую можно использовать для&nbsp;передачи данных в&nbsp;UI. Обратите внимание, здесь мы предполагали доступность всех доменных событий, но&nbsp;это не&nbsp;всегда так. Причины этого рассмотрим далее.</p>
   <h2>Возможные проблемы с read-моделью</h2>
   <h3>Недоступность данных</h3>
   <p>Продукт развивается, и со временем выясняется, что&nbsp;в&nbsp;UI необходимо передать дополнительные данные. Допустим, в&nbsp;событие <code>SomethingHappened</code> добавляется еще одно поле.</p>
   <p>На&nbsp;первый взгляд, решение этой проблемы относительно просто:</p>
   <ol>
    <li><p>Повторно обрабатываем все события соответствующего типа.</p></li>
    <li><p>Находим в&nbsp;базе данных read‑модели запись по <code>id</code> события.</p></li>
    <li><p>Обновляем запись в&nbsp;read‑модели.</p></li>
   </ol>
   <p>К&nbsp;сожалению, велик риск, что&nbsp;такое наивное решение не&nbsp;сработает. Например, некоторые события к&nbsp;этому моменту могут&nbsp;быть удалены брокером сообщений. При&nbsp;использовании Apache Kafka срок хранения по&nbsp;умолчанию равен семи дням. В&nbsp;случае AWS Kinesis Data Streams&nbsp;— всего 24&nbsp;часа. Если мы заранее не&nbsp;предусмотрели такой сценарий, то теперь у&nbsp;нас связаны руки. Здесь нет идеального и красивого решения. Но&nbsp;все‑таки как&nbsp;мы можем решить эту новую проблему?</p>
   <ul>
    <li><p>Можно вернуться к&nbsp;паттерну API Composition, но&nbsp;он неразрывно связан с&nbsp;предположением, что&nbsp;сервис, публикующий события <code>SomethingHappened</code>, предоставляет API для&nbsp;чтения интересующей нас сущности. Это не&nbsp;всегда так.</p></li>
    <li><p>Если доменные события сохраняются в&nbsp;постоянное хранилище и доступны нам, то у&nbsp;нас еще есть надежда. Иначе мы пропали и будем вынуждены применять «грязные» решения.</p></li>
   </ul>
   <h3>Изменения формата события</h3>
   <p>Предположим, мы построили и заполнили нашу read‑модель, обработав все необходимые доменные события. Но&nbsp;тем временем продюсер событий внес изменения в&nbsp;схему события.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/508/b0c/773/508b0c77303340f7ffdd9fc7400d19d9.png" width="700" height="121" data-src="https://habrastorage.org/getpro/habr/upload_files/508/b0c/773/508b0c77303340f7ffdd9fc7400d19d9.png">
    <figcaption></figcaption>
   </figure>
   <p>С&nbsp;точки зрения потребителя, появились две проблемы:</p>
   <ul>
    <li><p>Если мы хотим сохранить информацию, переданную в&nbsp;поле <strong>x</strong>, то нам нужно как‑то найти это поле в&nbsp;старых событиях. Это та&nbsp;же проблема, описанная выше.</p></li>
    <li><p>Необходимо реализовать свой десериализатор (а может и не&nbsp;один), чтобы&nbsp;быть уверенным, что&nbsp;мы сможем десериализовать все сообщения в&nbsp;потоке. Это не&nbsp;только дополнительная работа, которую нужно сделать, но&nbsp;она может оказаться и не&nbsp;такой простой, поскольку у&nbsp;событий разные несовместимые схемы. Также стоит отметить, что&nbsp;реализация кастомного десериализатора&nbsp;— это не&nbsp;разовое действие. Скорее всего, потребуется постоянно вносить в&nbsp;него изменения, потому что&nbsp;схемы сообщений будут меняться.</p></li>
   </ul>
   <h3>Очередность событий</h3>
   <p>Рассмотрим случай, когда для&nbsp;построения read‑модели потребуется несколько доменных событий.</p>
   <ul>
    <li><p><strong>CompanyCreated</strong></p></li>
   </ul>
   <pre><code>{
  "id": "68d2a8d8-eea1-44ea-bbd3-1533f223b0f4",
  "taxOfficeId": "de6a9b5a-e74c-4145-bfd0-71e3e6ee7689",
  "name": "Easy Invoicing",
  "size": 100
}</code></pre>
   <ul>
    <li><p><strong>TaxOfficeClerkChanged</strong></p></li>
   </ul>
   <pre><code>{
  "id": "de6a9b5a-e74c-4145-bfd0-71e3e6ee7689",
  "name": "John Doe"
}</code></pre>
   <p>В&nbsp;нашей системе выставления счетов требуется отображать на&nbsp;дашборде название компании, ее размер и имя сотрудника налоговой инспекции, которому мы подчиняемся.</p>
   <pre><code>{
  "companyId": "68d2a8d8-eea1-44ea-bbd3-1533f223b0f4",
  "taxOfficeId": "de6a9b5a-e74c-4145-bfd0-71e3e6ee7689",
  "companyName": "Easy Invoicing",
  "companySize": 100,
  "taxOfficeClerkName": "John Doe"
}</code></pre>
   <p>В&nbsp;этом случае нам нужно убедиться, что&nbsp;событие <code>CompanyCreated</code><strong> </strong>мы получили перед событием <code>TaxOfficeClerkChanged</code>. Можно решить эту проблему, сохраняя события <code>TaxOfficeClerkChanged</code> в&nbsp;отдельной временной базе данных, и искать в&nbsp;ней имя клерка при&nbsp;получении события <code>CompanyCreated</code>. Однако стоит отметить, что&nbsp;в&nbsp;этом случае мы значительно увеличиваем дублирование данных, возможно, создавая новые проблемы, которые всплывут в&nbsp;будущем. Например, если событие <code>TaxOfficeClerkChanged</code> содержит персональные данные, и мы сохранили их, то нам нужно это учитывать при&nbsp;обсуждении вопросов соответствия GDPR.</p>
   <h3>Утечка знаний о предметной области</h3>
   <p>Помимо чисто технических моментов, описанных ранее, есть еще один, который не&nbsp;виден сразу. Рассмотрим следующий сценарий:</p>
   <ol>
    <li><p>Продюсер генерирует событие <code>InvoicePaid</code><strong> </strong>(счет оплачен), в&nbsp;котором присутствует информация об&nbsp;оплаченной сумме.</p></li>
    <li><p>Мы обрабатываем это событие и, исходя из&nbsp;оплаченной суммы, списываем часть денег со счета клиента.</p></li>
    <li><p>На&nbsp;стороне продюсера происходят изменения: появляется новый способ оплаты с&nbsp;покупкой в&nbsp;рассрочку. Клиент оплачивает счет и генерируется событие <code>InvoicePaid</code>. Счет оплачен и нам неважно, кто оплатил счет (банк или&nbsp;клиент). Отличие только в&nbsp;том, что&nbsp;теперь мы не&nbsp;должны списывать всю сумму со счета единовременно, а&nbsp;делать это частями ежемесячно.</p></li>
    <li><p>Допустим, мы не&nbsp;знали об&nbsp;этом изменении и не&nbsp;внесли правок на&nbsp;нашей стороне. В&nbsp;итоге пользователи увидят как&nbsp;новый договор с&nbsp;банком, так и списание полной суммы с&nbsp;их счета. Это серьезная проблема, мы&nbsp;бы не&nbsp;хотели, чтобы наши клиенты хоть на&nbsp;мгновение сомневались в&nbsp;том, что&nbsp;мы можем управлять их деньгами.</p></li>
   </ol>
   <p>Приведенный выше пример показывает, что, даже если мы преодолеем все ранее описанные проблемы, все равно что‑то может пойти не&nbsp;так. Однако между этими двумя проблемами есть существенная разница. Первую мы сможем обнаружить при&nbsp;функциональном тестировании, а&nbsp;в&nbsp;случае утечки знаний предметной области, как&nbsp;бы мы ни старались, не&nbsp;поймаем ошибку, так как&nbsp;на&nbsp;момент тестирования все работает нормально…</p>
   <h2>Альтернативное решение</h2>
   <p>Как&nbsp;было показано, построение read‑модели на&nbsp;основе доменных событий может оказаться долгим и чреватым ошибками. Хотя это не&nbsp;значит, что&nbsp;нет безопасного способа для&nbsp;ее построения. Вместо использования доменных событий можно использовать события сущности (entity event). Они, наряду с&nbsp;другими интересными концепциями, описаны в <a href="https://www.datamesh-architecture.com/#ingesting"><u>статье, посвященной Data Mesh</u></a>. Если вкратце, то на&nbsp;основе событий сущности можно создать полный снимок измененной сущности. Каждое изменение может инициировать как&nbsp;доменные события, так и события сущности. Первые из&nbsp;них используются для&nbsp;организации бизнес‑процессов. Вторые&nbsp;— для&nbsp;аналитических целей, а&nbsp;также для&nbsp;построения read‑моделей.</p>
   <h2>Заключение</h2>
   <p>В&nbsp;заключение я&nbsp;бы хотел сказать, что, конечно, вы можете и не&nbsp;встретиться с&nbsp;указанными проблемами при&nbsp;построении read‑модели на&nbsp;основе доменных событий. Однако поднятые мною вопросы не&nbsp;выдуманы. Они встретились в&nbsp;моей практике, и я хотел&nbsp;бы рассказать вам о&nbsp;них. Спасибо, что&nbsp;дочитали до&nbsp;конца и удачных экспериментов!</p>
   <hr>
   <p>Приглашаем всех&nbsp;желающих на&nbsp;открытое занятие «Микросервисная архитектура&nbsp;— когда нужна, а&nbsp;когда нет?». На&nbsp;занятии рассмотрим плюсы и минусы монолитов и микросервисов. Рассмотрим боли при&nbsp;двух подходах, а&nbsp;также основные паттерны в&nbsp;микросервисной архитектуре. Записаться можно <a href="https://otus.pw/0FsD/">по&nbsp;ссылке.</a></p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->