<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Сегодня хочу просто и доходчиво рассказать про такую структуру данных как связный список. Это одна из базовых структур, которая может быть полезной при реализации алгоритмов различной сложности, в том числе при решении задачек на собеседованиях.</p>
   <h3>А зачем вообще эти структуры данных?</h3>
   <p>Многие начинающие (да и не только начинающие) программисты могут даже не знать, что существуют структуры данных, кроме встроенных в их любимый ЯП. Проработав несколько лет сначала с использованием Ruby, а затем и JavaScript, я был в их числе. Но в какой-то момент…говоря коротка - понадобились. И если вы считаете, что вам все эти алгоритмы и структуры данных даром не нужны, то…просто добавьте эту статью в закладки, вернетесь, когда будет надо.</p>
   <p>Пишу я не только для вас, дорогие читатели, но (даже в первую очередь) для себя, поскольку в процессе объяснения материала кому-то сам начинаешь его лучше понимать. Как говорится, если ты не можешь объяснить что-то, чтобы тебя понял шестилетний ребенок - ты сам этого не понимаешь.</p>
   <h3>Собственно, к теме</h3>
   <p>Связный список - это базовая динамическая структура данных, состоящая из узлов, каждый из которых содержит значение и ссылку на следующий узел. Первый элемент списка - Head, последний - Tail, он ссылается на NULL.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e14/94f/35d/e1494f35d86c9ddd0c89fdee212e61f2.png" width="1149" height="333" data-src="https://habrastorage.org/getpro/habr/upload_files/e14/94f/35d/e1494f35d86c9ddd0c89fdee212e61f2.png">
    <figcaption></figcaption>
   </figure>
   <p>Связные списки похожи на массивы, однако добавление и удаление элементов из середины или из начала списка здесь проще, так как нет необходимости менять индексы всех последующих элементов.</p>
   <p>Двойной связанный список - это список, в котором узлы содержат ссылки еще и на предыдущий элемент.</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/c29/765/248/c29765248a85de64eaa766107b0416c0.png" width="1293" height="408" data-src="https://habrastorage.org/getpro/habr/upload_files/c29/765/248/c29765248a85de64eaa766107b0416c0.png">
    <figcaption></figcaption>
   </figure>
   <h3>Реализация</h3>
   <p>Этот раздел также делал в своих <s>эгоистичных</s> целях.</p>
   <p>Для того, чтобы при решении различных задач и контестов мне не нужно было искать реализацию той или иной структуры данных в интернете или реализовывать вручную, теряя драгоценное время, я решил реализовать самые популярные структуры данных и алгоритмы, собрать это все в кучу и поместить к себе на github.</p>
   <p>Итак…</p>
   <p>Базовым элементом списка является узел (Node) с полями value, next и prev (последнее - для двунаправленного списка). Реализуем двунаправленный список, из которого при необходимости можно легко сделать простой, просто убрав из кода указатели prev.</p>
   <pre><code class="javascript">class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
		this.prev = null;
    }
}</code></pre>
   <p>У самого списка также есть начальный набор свойств:</p>
   <ul>
    <li><p>head - это “точка входа”, начальный элемент списка</p></li>
    <li><p>tail - конечный элемент списка</p></li>
    <li><p>length - количество элементов списка. Необязательный элемент, но иногда бывает необходим. Да и, пожалуй, одно значение много памяти не отнимет.</p></li>
   </ul>
   <pre><code class="javascript">class DoubleLinkedList {
    constructor(value) {
        this.head = new Node(value);
        this.tail = this.head;
        this.length = 1;
    }
}</code></pre>
   <h3>Методы</h3>
   <p>Сам список не будет представлять никакой ценности, если мы не сможем с ним ничего сделать.</p>
   <p>Базовыми “умениями” нашего списка будет добавление элементов в конец (append) и в начало (prepend) списка.</p>
   <pre><code class="javascript">// Методы внутри класса DoubleLinkedList

// Добавление узла в конец списка
append(value) {
    const newNode = new Node(value);
    newNode.prev = this.tail;
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
    return this;
}

// Добавление узла в начало списка
prepend(value) {
    const newNode = new Node(value);
    this.head.prev = newNode;
    newNode.next = this.head;
    this.head = newNode;
    this.length++;
    return this;
}</code></pre>
   <p>Стоит отметить, что применение связанного списка вместо массива весьма оправдано как раз в случае, когда нужно добавлять или удалять большое количество элементов в начало списка, поскольку в связанном списке нет необходимости менять индексы элементов, после удаленных, то есть временная сложность O(1) у списка против O(n) у массива (для shift/unshift).</p>
   <p>Для двунаправленного списка можно также добавить метод разворота списка.</p>
   <pre><code class="javascript">// Разворот списка
reverse() {
    if (!this.head.next) {
        return this.head;
    }
    let first = this.head;
    this.tail = this.head;
    let second = first.next;
    while (second) {
        const temp = second.next;
        second.next = first;
        first = second;
        second = temp;
    }
    this.head.next = null;
    this.head = first;
    return this;
}
</code></pre>
   <p>Для понимания, что вообще происходит внутри списка, добавим служебный метод, выводящий список в консоль.</p>
   <pre><code class="javascript">// Вывод списка в консоль - служебный метод для визуализации
_print() {
    console.log(`HEAD: ${this.head.value}`);
    let currentNode = this.head;
    while (currentNode.next) {
        console.log(currentNode.value);
        currentNode = currentNode.next;
    }
    console.log(currentNode.value);
    console.log(`TAIL: ${this.tail.value}`);
}
</code></pre>
   <p>В итоге получаем нечто подобное:</p>
   <pre><code class="javascript">const list = new DoubleLinkedList(2)
list.append(3)
list.prepend(5)
list.prepend(8)
list._print()
// HEAD: 8
// 8
// 5
// 2
// 3
// TAIL: 3
list.reverse()
list._print()
// HEAD: 3
// 3
// 2
// 5
// 8
// TAIL: 8</code></pre>
   <h3>Что в итоге</h3>
   <p>У любой вещи, технологии, концепции…у всего есть положительные и отрицательные стороны. Не бывает чего-либо однозначно хорошего и однозначно плохого, есть набор плюсов и минусов.</p>
   <blockquote>
    <p>Если вы будете судить рыбу по её способности взбираться на дерево, она проживёт всю жизнь, считая себя дурой (А. Эйнштейн)</p>
   </blockquote>
   <p>Плюсы связанного списка:</p>
   <ul>
    <li><p>упорядочен</p></li>
    <li><p>имеет гибкий размер</p></li>
    <li><p>временная сложность вставки в начало (prepend) и в конец (append) - O(1)</p></li>
   </ul>
   <p>Минусы:</p>
   <ul>
    <li><p>занимает много памяти</p></li>
    <li><p>перебор, вставка в середину и удаление произвольного элемента имеют временную сложность O(n)</p></li>
   </ul>
   <p>Реализации связных списков (простого, двойного, сортированного, а также реализацию структуры данных "очередь", основанную на связном списке) можно <a href="https://github.com/shsv382/dataStructures/tree/main/LinkedLists" rel="noopener noreferrer nofollow">взять в моем github </a></p>
   <h3>Резюме</h3>
   <p>Надеюсь, данная статья оказалась для вас полезной. Буду признателен за ваши плюсики, особенно учитывая, что это моя первая статья на Хабре (никогда ведь не поздно начинать).</p>
   <p>Всем желаю успехов!</p>
  </div>
 </div>
</div> <!----> <!---->