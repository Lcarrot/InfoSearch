<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>В&nbsp;то время как&nbsp;я очень рад новому UI от&nbsp;Unity&nbsp;— UI Toolkit (UITK), я также&nbsp;был постоянно разочарован в&nbsp;связи с&nbsp;отсутствием множества фич, которые нужны здесь и сейчас.</p>
   <p>И несмотря на&nbsp;то, что&nbsp;привязка данных в&nbsp;рантайме и поддержка локализации (тоже пакет от&nbsp;Unity) уже в&nbsp;разработке для&nbsp;UITK, их релиз ожидается только к&nbsp;концу 2023. Потому я решил разработать привязку данных самостоятельно и не&nbsp;терять время в&nbsp;ожидании или&nbsp;привыканию к&nbsp;uGUI (естественно за&nbsp;исключением, когда необходим world‑space UI).</p>
   <p>Учитывая, что&nbsp;UITK очень схож с&nbsp;уже давно существующими языками XAML&nbsp;— UXML и CSS&nbsp;— USS, становится очень удобно использование уже укрепившихся паттернов широко используемых при&nbsp;разработке GUI.</p>
   <p>Например, уже в&nbsp;настоящий момент UITK полностью поддерживает разработку используя Model‑View‑Presentation паттерн. И хотя в&nbsp;его использовании не&nbsp;мало хорошего, но&nbsp;он также имеет ряд серьёзных недостатков. Поэтому&nbsp;было решено использовать паттерн Model‑View‑ViewModel, который подразумевает использование привязка данных типа View→ViewModel, что&nbsp;позволяет разделить разработку View и кода принося несколько ключевых преимуществ:</p>
   <ul>
    <li><p>Появляется возможность рефакторить View, совершенно не трогая код и наоборот - можно рефакторить код, не ломая интерфейс.</p></li>
    <li><p>UI дизайнерам не нужно знать, как работает код, чтобы работать на интерфейсом и наоборот - кодерам совсем не обязательно уметь верстать красивый интерфейс.</p></li>
    <li><p>Использование привязки значительно сокращает количество необходимо кода.</p></li>
   </ul>
   <p>Для того чтобы реализовать все эти преимущества я решил использовать <a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/" rel="noopener noreferrer nofollow">CommunityToolkit.Mvvm</a> широко рекомендуемый Microsoft, при использовании своих фреймворков. Его использование также добавляет несколько ключевых преимуществ:</p>
   <ul>
    <li><p>Кодогенерация шаблонного кода</p></li>
    <li><p>Высокопроизводительная система сообщений (Messaging)</p></li>
   </ul>
   <h2>Итак. Что же было достигнуто и что мы имеем?</h2>
   <p>На данный момент в моём пакете вы встретите следующие фичи:</p>
   <ol>
    <li><p>Привязка текста <strong>TextElement</strong>ов.<br>Прямо через UXML можно привязать <strong>text</strong> к свойству <strong>ViewModel</strong>, используя синтаксис <strong>string.Format</strong>.</p></li>
    <li><p>Привязка локализации с поддержкой переменных, вложенных (nested) переменных и вложенных локализаций и полной поддержкой всех фич предоставляемых <strong>smart-string</strong>.</p></li>
    <li><p>Привязка по интерфейсу <strong>INotifyValueChanged&lt;T&gt;</strong>.<br>Такая привязка является двухсторонней и открывает широкие возможности для чтения ввода (input) пользователя.</p></li>
    <li><p>Привязка <strong>IRelayCommand</strong>.<br>Эта привязка позволяет очень просто создавать кнопки. Также можно даже передать параметр для вызываемого метода, что позволяет привязать к одному методу сразу несколько кнопок.</p></li>
    <li><p>Привязка через рефлексию.<br>С её помощью можно привязать практически любое свойства <strong>VisualElement</strong> к коду. Например: <strong>style.fontSize</strong>&nbsp;или&nbsp;<strong>style.backgroundImage</strong>.</p></li>
    <li><p>Поддержка <strong>Burst</strong>.<br>А если вы пользователь DOTS, то вы можете интегрировать игровую логику с UI с помощью специального враппера прямо из нативного кода.</p></li>
   </ol>
   <p><em>И множество других фич на горизонте...</em></p>
   <p>Все виды привязок используют делегаты и избегают боксинга значений так, как это только возможно. Достичь этого удалось с помощью явно объявленных дженериков, в виде, позволяющем добавить поддержку любого кастомного типа в одну строчку.</p>
   <p>И всё это с полной поддержкой IL2CPP и WebGL.</p>
   <p>Не обошлось и без требований. Для успешной работы привязок потребуется:</p>
   <ul>
    <li><p>UniTask. Он широко используется для асинхронной привязки локализации, позволяя избегать скачков фреймрейта (fps).</p></li>
    <li><p>Net Standard 2.1</p></li>
    <li><p>Unity 2022.2. Хотя все предыдущие версии Unity тоже частично поддерживаются (при условии наличия UniTask и NS2.1), 2022.2 - это первая версия включающая поддержку Roslyn 4.0.1 API, которая даёт возможность использовать кодогенерацию из пакета <strong>CommunityToolkit.Mvvm</strong>.</p></li>
   </ul>
   <p>В пакете представлены <a href="https://github.com/bustedbunny/com.bustedbunny.mvvmtoolkit/tree/com.bustedbunny.mvvmtoolkit/Samples~/SampleView" rel="noopener noreferrer nofollow">семпл проект</a> и подробный <a href="https://github.com/bustedbunny/com.bustedbunny.mvvmtoolkit/blob/com.bustedbunny.mvvmtoolkit/README.md" rel="noopener noreferrer nofollow">readme</a> с инструкцией на практически каждую фичу из проекта (на данный момент всё на английском и будет переведено при достаточном спросе).</p>
   <p>Лицензирован пакет под лицензией MIT.</p>
   <p><a href="https://github.com/bustedbunny/com.bustedbunny.mvvmtoolkit" rel="noopener noreferrer nofollow">https://github.com/bustedbunny/com.bustedbunny.mvvmtoolkit</a></p>
   <p><em>Проект всё ещё в активной разработке и до первого стабильного релиза в основную ветку могут быть запушены коммиты с кардинальными изменениями.</em></p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->