<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-1">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <img src="https://habrastorage.org/r/w1560/webt/kg/nf/k1/kgnfk1erl4lfx35dipzjer7psn8.png" data-src="https://habrastorage.org/webt/kg/nf/k1/kgnfk1erl4lfx35dipzjer7psn8.png"><br>
   <p><br> Привет, друзья!</p><br>
   <p>В этой серии статей я расскажу вам о <a href="https://remix.run/">Remix</a> — новом фреймворке для создания клиент-серверных веб-приложений на JavaScript (точнее, на <a href="https://ru.reactjs.org/">React</a>) со встроенной поддержкой <a href="https://www.typescriptlang.org/">TypeScript</a>.</p><br>
   <p>Remix позволяет разрабатывать так называемые PESPA (Progressive Enhancement Single Page Apps — одностраничные приложения с возможностью прогрессивного улучшения). Это означает следующее:</p><br>
   <ul>
    <li>почти весь код приложения "живет" на сервере;</li>
    <li>приложение остается функциональным даже при отсутствии JS;</li>
    <li>JS используется только для прогрессивного улучшения UX (User Experience — пользовательский опыт).</li>
   </ul><br>
   <p>Подробнее о PESPA и других архитектурах веб-приложений можно почитать <a href="https://habr.com/ru/company/timeweb/blog/695798/">здесь</a>.</p><br>
   <p>Очевидно, что разработчики Remix вдохновлялись <a href="https://nextjs.org/">Next.js</a> и <a href="https://svelte.dev/">Svelte</a>.</p><br>
   <p>К слову, <a href="https://my-js.org/docs/guide/nextjs">здесь</a> вы найдете полное руководство по Next.js.</p><br>
   <p>В первой части мы пройдемся по руководствам из официальной документации, во второй — более подробно рассмотрим возможности, предоставляемые Remix, в третьей — разработаем что-нибудь интересное.</p><br>
   <p>Это часть номер раз.</p><a name="habracut"></a><br>
   <h2 id="soderzhanie">Содержание</h2><br>
   <ul>
    <li><a href="#routing">Маршрутизация / Routing</a></li>
    <li><a href="#resource_routes">Ресурсные роуты / Resource Routes</a></li>
    <li><a href="#api_routes">Интерфейс роутов / API Routes</a></li>
    <li><a href="#back_front">Бэкенд для фронтенда / Backend for Frontend</a></li>
    <li><a href="#data_loading">Загрузка данных / Data Loading</a></li>
    <li><a href="#data_writes">Запись данных / Data Writes</a></li>
    <li><a href="#optimistic_ui">Оптимистичное обновление UI / Optimistic UI</a></li>
    <li><a href="#module_constraints">Ограничения модулей / Module Constraints</a></li>
    <li><a href="#error_handling">Обработка ошибок / Error Handling</a></li>
    <li><a href="#not_found">Обработка ошибки 404 / Not Found Handling</a></li>
    <li><a href="#env">Переменные среды окружения / Environment Variables</a></li>
    <li><a href="#styling">Стилизация / Styling</a></li>
    <li><a href="#ts">TypeScript</a></li>
   </ul><br>
   <h2 id="a-idroutinga-marshrutizaciya--routing">Маршрутизация / Routing</h2><br>
   <p>Маршрутизация (роутинг) — это, пожалуй, самая важная концепция в Remix. Все начинается с маршрутов (роутов): компилятор, первоначальный запрос документа и почти все последующие действия пользователя.</p><br>
   <p>Начнем с определения понятий:</p><br>
   <ul>
    <li>вложенные роуты (nested routes) — связь (map) роутов с сегментами URL обеспечивает соответствие URL определенным компонентам и данным, известным перед рендерингом страницы;</li>
    <li>URL — полный путь в поисковой строке браузера пользователя. Один URL может совпадать (соответствовать — match) с несколькими роутами. <em>Обратите внимание</em>: роут и URL — разные вещи в Remix;</li>
    <li>роут (route) или модуль роута (route module) — модуль JS с определенными экспортами (<code>loader</code>, <code>action</code>, <code>default function</code> (компонент) и др.), который соответствует одному или нескольким сегментам URL. Поскольку роут соответствует сегменту URL, по одному пути могут рендерится несколько модулей. Иерархия компонентов соответствует сегментам URL (в основном);</li>
    <li>путь (path) или путь роута (route path) — сегмент URL, которому соответствует отдельный модуль. Путь роута определяется названием файла в директории <code>app/routes</code>;</li>
    <li>родительский макет (parent layout route) или родительский роут (parent route) — модуль, который рендерит макет для дочерних компонентов через компонент <code>Outlet</code>;</li>
    <li>макет без пути (pathless layout route) или роут без пути (pathless route) — модуль, который не добавляет сегменты к URL, но добавляет компонент в иерархию UI (User Interface — пользовательский интерфейс) при совпадении его дочерних роутов;</li>
    <li>дочерний роут (child route) — модуль, который рендерится внутри родительского <code>Outlet</code> при совпадении его пути с URL;</li>
    <li>индексный роут (index route) — модуль, который имеет такой же путь, как его родительский роут, но рендерится в качестве дефолтного дочернего роута внутри <code>Outlet</code>;</li>
    <li>динамический сегмент (dynamic segment) — сегмент пути роута, извлекаемый из URL и передаваемый в приложение, такой как идентификатор (ID) записи или слаг (slug) поста;</li>
    <li>сплат (splat) — замыкающая звездочка (trailing wildcard) в пути роута, который благодаря этому совпадает со всеми сегментами URL (включая последующий <code>/</code>);</li>
    <li>аутлет (outlet) — компонент, который рендерится внутри родительского модуля, предназначенный для рендеринга дочерних модулей. Другими словами, аутлет определяет локацию дочерних роутов.</li>
   </ul><br>
   <h3 id="vlozhennyy-routing">Вложенный роутинг</h3><br>
   <p>Вложенный роутинг — это связь между сегментами URL и иерархией компонентов в UI. Сегменты URL определяют:</p><br>
   <ul>
    <li>макеты, формирующие страницу;</li>
    <li>загрузку JS-кода, используемого на странице;</li>
    <li>загрузку данных, используемых на странице.</li>
   </ul><br>
   <h4 id="opredelenie-routov">Определение роутов</h4><br>
   <p>Роуты определяются посредством создания файлов в директории <code>app/routes</code>. Вот как может выглядеть иерархия роутов приложения:</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── accounts.jsx
    ├── dashboard.jsx
    ├── expenses.jsx
    ├── index.jsx
    ├── reports.jsx
    ├── sales
    │   ├── customers.jsx
    │   ├── deposits.jsx
    │   ├── index.jsx
    │   ├── invoices
    │   │   ├── $invoiceId.jsx
    │   │   └── index.jsx
    │   ├── invoices.jsx
    │   └── subscriptions.jsx
    └── sales.jsx</code></pre><br>
   <ul>
    <li><code>root.jsx</code> — это корневой роут, служащий макетом для всего приложения. Другие роуты рендерятся внутри его <code>Outlet</code>;</li>
    <li><em>обратите внимание</em> на файлы, названия которых совпадают с названиями директорий, в которых эти файлы находятся. Эти файлы предназначены для формирования иерархии макетов компонентов. Например, <code>sales.jsx</code> — это родительский роут для всех дочерних роутов внутри директории <code>app/routes/sales</code>. При совпадении с URL любого роута из этой директории, он будет рендерится внутри <code>Outlet</code> модуля <code>sales.jsx</code>;</li>
    <li>роут <code>index.jsx</code> будет рендерится внутри <code>Outlet</code> при совпадении URL с путем директории (например, пути <code>example.com/sales</code> соответствует роут <code>app/routes/sales/index.jsx</code>).</li>
   </ul><br>
   <h4 id="rendering-ierarhii-maketa-routa">Рендеринг иерархии макета роута</h4><br>
   <p>Предположим, что URL имеет вид <code>/sales/invoices/123</code>. С этим URL будут совпадать следующие роуты:</p><br>
   <ul>
    <li><code>root.jsx</code>;</li>
    <li><code>routes/sales.jsx</code>;</li>
    <li><code>routes/sales/invoices.jsx</code>;</li>
    <li><code>routes/sales/invoices/$invoiceId.jsx</code>.</li>
   </ul><br>
   <p>При посещении этой страницы пользователем Remix отрендерит такую иерархию компонентов:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;Sales&gt;
    &lt;Invoices&gt;
      &lt;InvoiceId /&gt;
    &lt;/Invoices&gt;
  &lt;/Sales&gt;
&lt;/Root&gt;</code></pre><br>
   <p>Иерархия компонентов полностью соответствует иерархии файлов в директории <code>app/routes</code>:</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── sales
    │   ├── invoices
    │   │   └── $invoiceId.jsx
    │   └── invoices.jsx
    ├── sales.jsx
    └── accounts.jsx</code></pre><br>
   <p>Иерархия компонентов для URL <code>/accounts</code> будет такой:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;Accounts /&gt;
&lt;/Root&gt;</code></pre><br>
   <p>Для рендеринга дочерних роутов внутри родительского используется <code>Outlet</code>. <code>root.jsx</code> рендерит основной макет, боковую панель и аутлет для дочерних роутов:</p><br>
   <pre><code class="javascript">import { Outlet } from "@remix-run/react";

export default function Root() {
  return (
    &lt;Document&gt;
      &lt;Sidebar /&gt;
      {/* ! */}
      &lt;Outlet /&gt;
    &lt;/Document&gt;
  );
}</code></pre><br>
   <p>В свою очередь, <code>sales.jsx</code> рендерит аутлет для всех его дочерних роутов (<code>app/routes/sales/*</code>):</p><br>
   <pre><code class="javascript">import { Outlet } from "@remix-run/react";

export default function Sales() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Sales&lt;/h1&gt;
      &lt;SalesNav /&gt;
      {/* ! */}
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}</code></pre><br>
   <h4 id="indeksnye-routy">Индексные роуты</h4><br>
   <p>Индексный роут — это дефолтный дочерний роут. При отсутствии других дочерних роутов рендерится индексный модуль. Например, URL <code>exmaple.com/sales</code> соответствует индексный роут <code>app/routes/sales/index.jsx</code>.</p><br>
   <p>Индексные роуты не должны рендерить дочерние модули, они являются тупиком для URL. Например, вместо рендеринга глобальной панели навигации в <code>app/routes/index.jsx</code>, ее следует рендерить в <code>app/root.jsx</code>.</p><br>
   <p><strong>Параметр строки запроса <code>?index</code></strong></p><br>
   <p>Данный параметр позволяет отличать индексные роуты от их родительский модулей, которые рендерят макеты. Предположим, что у нас имеется такая иерархия роутов:</p><br>
   <pre><code class="plaintext">└── app
    ├── root.jsx
    └── routes
        ├── sales
        │   ├── invoices
        │   │   └── index.jsx
        │   └── invoices.jsx</code></pre><br>
   <p>Какому роуту будет соответствовать путь <code>/sales/invoices</code>? Роуту <code>/sales/invoices.jsx</code> или роуту <code>/sales/invoices/index.jsx</code>? Ответ: роуту <code>/sales/invoices.jsx</code>. Для совпадения с роутом <code>/sales/invoices/index.jsx</code> путь должен заканчиваться параметром строки запроса <code>?index</code>:</p><br>
   <pre><code class="plaintext">└── app
    ├── root.jsx
    └── routes
        ├── sales
        │   ├── invoices
        │   │   └── index.jsx   &lt;-- /sales/invoices?index
        │   └── invoices.jsx    &lt;-- /sales/invoices</code></pre><br>
   <p>В некоторых случаях добавление <code>?index</code> происходит автоматически (например, при отправке формы в индексном или его родительском роуте), в других — это делается вручную (например, при использовании <code>fetcher.submit()</code> или <code>fetcher.load()</code>).</p><br>
   <h3 id="vlozhennye-url-bez-vlozhennyh-maketov">Вложенные URL без вложенных макетов</h3><br>
   <p>Иногда может потребоваться добавить вложенный URL без добавления компонента в иерархию UI. Рассмотрим страницу редактирования счета:</p><br>
   <ul>
    <li>мы хотим, чтобы URL имел вид <code>/sales/invoices/$invoiceId/edit</code>;</li>
    <li>мы хотим, чтобы соответствующий компонент был прямым потомком корневого компонента.</li>
   </ul><br>
   <p>Другими словами, мы не хотим этого:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;Sales&gt;
    &lt;Invoices&gt;
      &lt;InvoiceId&gt;
        &lt;EditInvoice /&gt;
      &lt;/InvoiceId&gt;
    &lt;/Invoices&gt;
  &lt;/Sales&gt;
&lt;/Root&gt;</code></pre><br>
   <p>Мы хотим это:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;EditInvoice /&gt;
&lt;/Root&gt;</code></pre><br>
   <p>Для создания плоской иерархии UI используется плоское название файла — использование <code>.</code> в названии файла позволяет добавлять сегменты URL без добавления компонентов в иерархию UI:</p><br>
   <pre><code class="plaintext">└── app
    ├── root.jsx
    └── routes
        ├── sales
        │   ├── invoices
        │   │   └── $invoiceId.jsx
        │   └── invoices.jsx
        ├── sales.invoices.$invoiceId.edit.jsx 👈 не является вложенным
        └── sales.jsx</code></pre><br>
   <p>Пути <code>example.com/sales/invoices/123/edit</code> будет соответствовать такая иерархия компонентов:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;EditInvoice /&gt;
&lt;/Root&gt;</code></pre><br>
   <p>А пути <code>example.com/sales/invoices/123</code> (без <code>/edit</code>) такая:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;Sales&gt;
    &lt;Invoices&gt;
      &lt;InvoiceId /&gt;
    &lt;/Invoices&gt;
  &lt;/Sales&gt;
&lt;/Root&gt;</code></pre><br>
   <h3 id="makety-bez-puti">Макеты без пути</h3><br>
   <p>Иногда, наоборот, может потребоваться добавить компонент в иерархию UI без добавления сегментов в URL. Для этого используются макеты без пути.</p><br>
   <p>Предположим, что мы хотим получить такую иерархию UI:</p><br>
   <pre><code class="javascript">&lt;Root&gt;
  &lt;Auth&gt;
    &lt;Login /&gt;
  &lt;/Auth&gt;
&lt;/Root&gt;</code></pre><br>
   <p>В данном случае иерархия роутов может выглядеть так:</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── auth
    │   ├── login.jsx
    │   ├── logout.jsx
    │   └── signup.jsx
    └── auth.jsx</code></pre><br>
   <p>У нас имеется правильная иерархия UI, но, возможно, мы не хотим, чтобы каждый URL содержал префикс <code>/auth</code>, например, вместо <code>/auth/login</code> мы хотим видеть просто <code>/login</code>.</p><br>
   <p>Для удаления вложенности URL при сохранении вложенности UI достаточно добавить к названиям роута и директории 2 нижних подчеркивания:</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── __auth
    │   ├── login.jsx
    │   ├── logout.jsx
    │   └── signup.jsx
    └── __auth.jsx</code></pre><br>
   <h3 id="dinamicheskie-segmenty">Динамические сегменты</h3><br>
   <p>Если название файла содержит префикс <code>$</code>, соответствующая часть пути роута становится динамическим сегментом. Это означает, что любое значение в URL для данного сегмента будет извлекаться из URL и передаваться в приложение.</p><br>
   <p>Рассмотрим роут <code>$invoiceId.jsx</code>. При переходе по адресу <code>/sales/invoices/123</code> строка <code>123</code> будет извлечена из URL и передана в <code>loader</code>, <code>action</code> и компонент в виде одноименного свойства объекта <code>params</code>:</p><br>
   <pre><code class="javascript">import { useParams } from "@remix-run/react";

export async function loader({ params }) {
  const id = params.invoiceId;
}

export async function action({ params }) {
  const id = params.invoiceId;
}

export default function Invoice() {
  const params = useParams();
  const id = params.invoiceId;
}</code></pre><br>
   <p>Роуты могут содержать несколько параметров. Параметры могут быть директориями.</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── projects
    │   ├── $projectId
    │   │   └── $taskId.jsx
    │   └── $projectId.jsx
    └── projects.jsx</code></pre><br>
   <p>В данном случае при переходе по адресу <code>/projects/123/abc</code> параметры буду следующими:</p><br>
   <pre><code class="plaintext">params.projectId; // "123"
params.taskId; // "abc"</code></pre><br>
   <h3 id="splaty">Сплаты</h3><br>
   <p>Если название файла содержит только <code>$</code> (<code>$.jsx</code>), то такой роут является сплатом. С таким роутом совпадает любое значение URL для оставшейся части URL до конца. В отличие от динамических сегментов, сплат не останавливается при достижении следующего <code>/</code>.</p><br>
   <p>Рассмотрим такую иерархию роутов:</p><br>
   <pre><code class="plaintext">app
├── root.jsx
└── routes
    ├── files
    │   ├── $.jsx
    │   ├── mine.jsx
    │   └── recent.jsx
    └── files.jsx</code></pre><br>
   <p>При переходе по адресу <code>example.com/files/images/work/flyer.jpg</code>, сегменты URL, начиная с <code>files</code> будут перехвачены сплатом и доступны в приложении через <code>params["*"]</code>:</p><br>
   <pre><code class="javascript">export async function loader({ params }) {
  params["*"]; // "images/work/flyer.jpg"
}</code></pre><br>
   <p>Сплаты могут использоваться для реализации кастомных страниц 404 с данными из <code>loader</code> (при отсутствии кастомной страницы 404 рендерится корневой <code>CatchBoundary</code>, не позволяющий загружать данные для страницы при отсутствии совпадения с роутами).</p><br>
   <h2 id="a-idresource_routesa-resursnye-routy--resource-routes">Ресурсные роуты / Resource Routes</h2><br>
   <p>Ресурсные роуты не являются частью UI, но являются частью приложения. Они могут возвращать любые ответы.</p><br>
   <p>Большая часть роутов в Remix является роутами UI, т.е. роутами, которые рендерят компоненты. Но роут не обязательно должен это делать. Роуты, которые не экспортируют дефолтные компоненты, являются ресурсными. Случаи их использования:</p><br>
   <ul>
    <li>JSON API для мобильных приложений, которые повторно используют серверный код с Remix UI;</li>
    <li>динамическая генерация PDF;</li>
    <li>динамическая генерация иконок социальных сетей для постов блога или других страниц;</li>
    <li>веб-хуки для сервисов вроде Stripe или GitHub;</li>
    <li>CSS-файлы, которые динамически рендерят кастомные свойства для темы, выбранной пользователем.</li>
   </ul><br>
   <h3 id="sozdanie-resursnogo-routa">Создание ресурсного роута</h3><br>
   <p>Ресурсный роут должен экспортировать либо <code>loader</code> (для обработки GET-запросов), либо <code>action</code> (для обработки других запросов).</p><br>
   <p>Рассмотрим роут для рендеринга отчета (внимание на ссылку):</p><br>
   <pre><code class="javascript">// app/routes/reports/$id.tsx
export async function loader({ params }: LoaderArgs) {
  return json(await getReport(params.id));
}

export default function Report() {
  const report = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;div&gt;
      &lt;h1&gt;{report.name}&lt;/h1&gt;
      &lt;Link to="pdf" reloadDocument&gt;
        PDF
      &lt;/Link&gt;
      {/* ... */}
    &lt;/div&gt;
  );
}</code></pre><br>
   <p>Ссылка ведет на PDF-версию страницы. Для ее создания необходимо реализовать ресурсный роут:</p><br>
   <pre><code class="javascript">// app/routes/reports/$id/pdf.tsx
export async function loader({ params }: LoaderArgs) {
  const report = await getReport(params.id);

  const pdf = await generateReportPDF(report);

  return new Response(pdf, {
    status: 200,
    headers: {
      "Content-Type": "application/pdf",
    },
  });
}</code></pre><br>
   <p>Когда пользователь нажимает на ссылку, он получает отчет в формате PDF.</p><br>
   <p><em>Обратите внимание</em>: в качестве ссылки на ресурсный роут следует использовать либо компонент <code>Link</code> с атрибутом <code>reloadDocument</code>, либо HTML-элемент <code>a</code>. <code>Link</code> без <code>reloadDocument</code> считается ссылкой на роут UI.</p><br>
   <p>Для того, чтобы добавить расширение файла к пути ресурсного роута, можно обернуть расширение или <code>.</code> в <code>[]</code>:</p><br>
   <pre><code class="bash"># /reports/123/pdf
app/routes/reports/$id/pdf.ts

# /reports/123.pdf
app/routes/reports/$id[.pdf].ts

# /reports/123.pdf
app/routes/reports/$id[.]pdf.ts</code></pre><br>
   <h3 id="obrabotka-raznyh-metodov">Обработка разных методов</h3><br>
   <p>Для обработки GET-запросов из ресурсного роута экспортируется <code>loader</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";

export const loader = async ({ request }: LoaderArgs) =&gt; {
  return json({ success: true }, 200);
};</code></pre><br>
   <p>Для обработки других запросов из ресурсного роута экспортируется <code>action</code>:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";

export const action = async ({ request }: ActionArgs) =&gt; {
  switch (request.method) {
    case "POST": {
      // ...
    }
    case "PUT": {
      // ...
    }
    case "PATCH": {
      // ...
    }
    case "DELETE": {
      // ...
    }
    default: {
      throw new Response("Неизвестный метод", {
        status: 400
      })
    }
  }
};</code></pre><br>
   <h3 id="veb-huki">Веб-хуки</h3><br>
   <p>Пример веб-хука для получения уведомлений о создании нового коммита в репозитории GitHub:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import crypto from "crypto";

export const action = async ({ request }: ActionArgs) =&gt; {
  if (request.method !== "POST") {
    return json({ message: "Метод запрещен" }, 405);
  }

  const payload = await request.json();

  /* валидируем веб-хук */
  const signature = request.headers.get(
    "X-Hub-Signature-256"
  );
  const generatedSignature = `sha256=${crypto
    .createHmac("sha256", process.env.GITHUB_WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest("hex")}`;

  if (signature !== generatedSignature) {
    return json({ message: "Signature mismatch" }, 401);
  }

  /* обрабатываем веб-хук (например, помещаем фоновую задачу в очередь) */

  return json({ success: true }, 200);
};</code></pre><br>
   <h2 id="a-idapi_routesa-interfeys-routov--api-routes">Интерфейс роутов / API Routes</h2><br>
   <p>Рассмотрим такой роут:</p><br>
   <pre><code class="javascript">// routes/teams.tsx
export async function loader() {
  return json(await getTeams());
}

export default function Teams() {
  return (
    &lt;TeamsView teams={useLoaderData&lt;typeof loader&gt;()} /&gt;
  );
}</code></pre><br>
   <p>При клике пользователем по <code>&lt;Link to="/teams" /&gt;</code> Remix запрашивает данные у сервера в <code>loader</code> и рендерит модуль. Таким образом, нам не нужен отдельный роут для взаимодействия с API.</p><br>
   <p>Что если мы хотим получить данные из <code>loader</code> без участия пользователя? Хорошим примером такой ситуации является компонент Combobox, который получает записи из БД и предлагает их пользователю.</p><br>
   <p>Для этого можно использовать хук <code>useFetcher</code>.</p><br>
   <p>Предположим, что у нас есть такой роут для обработки поиска:</p><br>
   <pre><code class="javascript">// routes/city-search.tsx
export async function loader({ request }: LoaderArgs) {
  const url = new URL(request.url);

  return json(
    await searchCities(url.searchParams.get("q"))
  );
}</code></pre><br>
   <p>Вызываем <code>useFetcher()</code> в соответствующем компоненте:</p><br>
   <pre><code class="javascript">function CitySearchCombobox() {
  const cities = useFetcher();

  return (
    &lt;cities.Form method="get" action="/city-search"&gt;
      &lt;Combobox aria-label="Cities"&gt;
        &lt;div&gt;
          &lt;ComboboxInput
            name="q"
            onChange={(event) =&gt;
              cities.submit(event.target.form)
            }
          /&gt;
          {cities.state === "submitting" ? (
            &lt;Spinner /&gt;
          ) : null}
        &lt;/div&gt;

        {cities.data ? (
          &lt;ComboboxPopover className="shadow-popup"&gt;
            {cities.data.error ? (
              &lt;p&gt;Не удалось загрузить список городов&lt;/p&gt;
            ) : cities.data.length ? (
              &lt;ComboboxList&gt;
                {cities.data.map((city) =&gt; (
                  &lt;ComboboxOption
                    key={city.id}
                    value={city.name}
                  /&gt;
                ))}
              &lt;/ComboboxList&gt;
            ) : (
              &lt;span&gt;Подходящих городов не найдено&lt;/span&gt;
            )}
          &lt;/ComboboxPopover&gt;
        ) : null}
      &lt;/Combobox&gt;
    &lt;/cities.Form&gt;
  );
}</code></pre><br>
   <h2 id="a-idback_fronta-bekend-dlya-frontenda--backend-for-frontend">Бэкенд для фронтенда / Backend for frontend</h2><br>
   <p>Несмотря на то, что Remix предназначен для разработки фуллстек-приложений, он отлично вписывается в архитектуру "Бэкенд для фронтенда". Эта архитектура предполагает использование Remix в качестве посредника между UI и существующими серверными сервисами.</p><br>
   <p>Поскольку Remix "полифиллит" Web Fetch API, мы можем использовать <code>fetch</code> прямо в <code>loader</code> и <code>action</code> для получения данных от сервера:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import escapeHtml from "escape-html";

export async function loader({ request }: LoaderArgs) {
  const apiUrl = "http://api.example.com/some-data.json";

  const res = await fetch(apiUrl, {
    headers: {
      Authorization: `Bearer ${process.env.API_TOKEN}`,
    },
  });

  const data = await res.json();

  const prunedData = data.map((record) =&gt; {
    return {
      id: record.id,
      title: record.title,
      formattedBody: escapeHtml(record.content),
    };
  });

  return json(prunedData);
}</code></pre><br>
   <p>Такой подход позволяет:</p><br>
   <ul>
    <li>упростить интеграцию со сторонними сервисами, а также хранить токены и секреты вне сборки для клиента;</li>
    <li>сократить количество данных, передаваемых по сети, что может существенно повысить производительность приложения;</li>
    <li>перенести большое количество кода на сервер, что также хорошо влияет на производительность приложения.</li>
   </ul><br>
   <h2 id="a-iddata_loadinga-zagruzka-dannyh--data-loading">Загрузка данных / Data Loading</h2><br>
   <p>Одним из главных преимуществ Remix является упрощение взаимодействия с сервером для получения данных в компонентах. Remix автоматически:</p><br>
   <ul>
    <li>рендерит страницы на сервере;</li>
    <li>является устойчивым к изменениям сетевых условий;</li>
    <li>загружает только те данные, которые необходимы для обновления страницы;</li>
    <li>загружает данные, JS-модули, CSS и другие ресурсы параллельно при переходе с одной страницы на другую. Это позволяет избежать водопадов (waterfalls) рендеринг+получение данных, что приводит к более согласованному UI;</li>
    <li>обеспечивает синхронизацию между данными в UI и на сервере путем повторного запуска <code>action</code>;</li>
    <li>обеспечивает восстановление прокрутки;</li>
    <li>обрабатывает серверные ошибки с помощью предохранителей (error boundaries);</li>
    <li>обеспечивает хороший UX для "Не найдено" и "Не авторизован" с помощью перехватчиков (catch boundaries).</li>
   </ul><br>
   <h3 id="osnovy">Основы</h3><br>
   <p>Каждый модуль может экспортировать компонент и функцию <code>loader</code>. Хук <code>useLoaderData</code> позволяет получать данные из <code>loader</code> в компоненте:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

export const loader = async () =&gt; {
  return json([
    { id: "1", name: "Pants" },
    { id: "2", name: "Jacket" },
  ]);
};

export default function Products() {
  const products = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;div&gt;
      &lt;h1&gt;Список товаров&lt;/h1&gt;
      {products.map((product) =&gt; (
        &lt;div key={product.id}&gt;{product.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre><br>
   <p>Компонент рендерится как на сервере, так и в браузере. <code>loader</code> выполняется только на сервере. Это означает, что массив товаров не включается в сборку для браузера. Это также означает, что мы можем безопасно использовать серверные API и SDK для базы данных, обработки платежей, CMS и т.д.</p><br>
   <p>Если серверные модули включаются в клиентскую сборку, импорт этих модулей следует перенести в файл с названием, содержащим суффикс <code>.server.ts</code> (<code>{something}.server.ts</code>).</p><br>
   <h3 id="parametry-routa">Параметры роута</h3><br>
   <p>Когда в названии файла содержится символ <code>$</code>, например, <code>routes/users/$userId.tsx</code> или <code>routes/users/$userId/projects/$projectId.tsx</code>, динамические сегменты (начинающиеся с <code>$</code>) извлекаются из URL и передаются в <code>loader</code> в качестве объекта <code>params</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";

export const loader = async ({ params }: LoaderArgs) =&gt; {
  console.log(params.userId);
  console.log(params.projectId);
};</code></pre><br>
   <p>Эти параметры могут использоваться для поиска необходимых данных:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";

export const loader = async ({ params }: LoaderArgs) =&gt; {
  return json(
    await fakeDb.project.findMany({
      where: {
        userId: params.userId,
        projectId: params.projectId,
      },
    })
  );
};</code></pre><br>
   <h4 id="tipy-parametrov">Типы параметров</h4><br>
   <p>Поскольку параметры содержатся в URL, а не в исходном коде, мы не можем быть уверены в том, что они всегда будут определены. Поэтому типом ключей параметров является <code>string | undefined</code>. Хорошей практикой является валидация параметров перед их использованием, например, с помощью <code>invariant</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import invariant from "tiny-invariant";

export const loader = async ({ params }: LoaderArgs) =&gt; {
  invariant(params.userId, "Ожидается params.userId");
  invariant(params.projectId, "Ожидается params.projectId");

  params.projectId; // &lt;-- TS теперь знает, что типом `projectId` является `string`
};</code></pre><br>
   <p>Для обработки таких исключений используются предохранители (error boundaries).</p><br>
   <h3 id="vneshnie-api">Внешние API</h3><br>
   <p>Remix предоставляет полифилл для <code>fetch</code> на сервере, что облегчает получение данных из существующих JSON API. Вместо управления состоянием, обработки ошибок, решения проблем, связанных с гонкой условий (race conditions) и т.п., мы просто запрашиваем данные в <code>loader</code> (на сервере), а Remix делает все остальное:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

export async function loader() {
  const res = await fetch("https://api.github.com/gists");

  return json(await res.json());
}

export default function GistsRoute() {
  const gists = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;ul&gt;
      {gists.map((gist) =&gt; (
        &lt;li key={gist.id}&gt;
          &lt;a href={gist.html_url}&gt;{gist.id}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre><br>
   <h3 id="baza-dannyh">База данных</h3><br>
   <p>Поскольку Remix выполняется на сервере, мы можем напрямую подключаться к БД в модулях. Пример подключения к Postgres с помощью <a href="https://prisma.io/">Prisma</a>:</p><br>
   <pre><code class="javascript">// app/db.server.ts
import { PrismaClient } from "@prisma/client";
const db = new PrismaClient();
export default db;</code></pre><br>
   <pre><code class="javascript">// app/routes/products/$categoryId.tsx
import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import db from "~/db.server";

export const loader = async ({ params }: LoaderArgs) =&gt; {
  return json(
    await db.product.findMany({
      where: {
        categoryId: params.categoryId,
      },
    })
  );
};

export default function ProductCategory() {
  const products = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;div&gt;
      &lt;p&gt;{products.length} Товаров&lt;/p&gt;
      {/* ... */}
    &lt;/div&gt;
  );
}</code></pre><br>
   <p>Для типизации данных можно использовать типы, генерируемые Prisma Client, при вызове <code>useLoaderData()</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import db from "~/db.server";

async function getLoaderData(productId: string) {
  const product = await db.product.findUnique({
    where: {
      id: productId,
    },
    select: {
      id: true,
      name: true,
      imgSrc: true,
    },
  });

  return product;
}

export const loader = async ({ params }: LoaderArgs) =&gt; {
  return json(await getLoaderData(params.productId));
};

export default function Product() {
  const product = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;div&gt;
      &lt;p&gt;Товар {product.id}&lt;/p&gt;
      {/* ... */}
    &lt;/div&gt;
  );
}</code></pre><br>
   <h3 id="ne-naydeno">Не найдено</h3><br>
   <p>При отсутствии записи в БД достаточно выбросить ответ в <code>loader</code> и Remix остановит выполнение кода и передаст управление ближайшему перехватчику (catch boundary):</p><br>
   <pre><code class="javascript">export const loader = async ({
  params,
  request,
}: LoaderArgs) =&gt; {
  const product = await db.product.findOne({
    where: { id: params.productId },
  });

  if (!product) {
    // мы не можем отрендерить компонент,
    // поэтому выбрасываем ответ для остановки выполнения кода
    // и отображения страницы "Не найдено"
    throw new Response("Not Found", { status: 404 });
  }

  const cart = await getCart(request);

  return json({
    product,
    inCart: cart.includes(product.id),
  });
};</code></pre><br>
   <h3 id="parametry-stroki-zaprosa">Параметры строки запроса</h3><br>
   <p>Параметры строки запроса (поисковой строки) (URL Search Params) — это часть URL, следующая за <code>?</code>. Эти параметры доступны в <code>request.url</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";

export const loader = async ({ request }: LoaderArgs) =&gt; {
  const url = new URL(request.url);
  const term = url.searchParams.get("term");

  return json(await fakeProductSearch(term));
};</code></pre><br>
   <p>Здесь:</p><br>
   <ul>
    <li>объект <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">request</a> содержит свойство <code>url</code>;</li>
    <li>конструктор <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL">URL</a> преобразует строку URL в объект;</li>
    <li><code>url.searchParams</code> — это экземпляр <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams">URLSearchParams</a>, содержащий преобразованную в объект строку запроса.</li>
   </ul><br>
   <h4 id="perezagruzka-dannyh">Перезагрузка данных</h4><br>
   <p>При изменении строки запроса в случае с рендерингом нескольких вложенных роутов, все эти роуты перезагружаются. Это связано с тем, что параметры строки запроса могут использоваться любым <code>loader</code> в этих роутах. Для предотвращения рендеринга отдельных роутов можно использовать <a href="https://remix.run/docs/en/v1/route/should-reload">shouldReload</a> (данный интерфейс пока является нестабильным, поэтому в рамках этого руководства не рассматривается).</p><br>
   <h4 id="parametry-stroki-zaprosa-v-komponentah">Параметры строки запроса в компонентах</h4><br>
   <p>Иногда требуется читать и обновлять параметры строки запроса в компонентах, а не в <code>loader</code> или <code>action</code>. Существует несколько способов это делать.</p><br>
   <p><em>Установка параметров строки запроса</em></p><br>
   <p>Пример модификации строки запроса пользователем:</p><br>
   <pre><code class="javascript">// app/products/shoes
export default function ProductFilters() {
  return (
    &lt;Form method="get"&gt;
      &lt;label htmlFor="nike"&gt;Nike&lt;/label&gt;
      &lt;input
        type="checkbox"
        id="nike"
        name="brand"
        value="nike"
      /&gt;

      &lt;label htmlFor="adidas"&gt;Adidas&lt;/label&gt;
      &lt;input
        type="checkbox"
        id="adidas"
        name="brand"
        value="adidas"
      /&gt;

      &lt;button type="submit"&gt;Обновить&lt;/button&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>Если пользователь выбрал один бренд, например, Nike, то строка запроса будет иметь вид <code>/products/shoes?brand=nike</code>, если оба, то <code>/products/shoes?brand=nike&amp;brand=adidas</code>.</p><br>
   <p><em>Обратите внимание</em>, что <code>brand</code> повторяется в строке запроса, поскольку оба чекбокса называются <code>brand</code>. Для доступа к этим значениям в <code>loader</code> предназначен метод <code>searchParams.getAll</code>:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";

export async function loader({ request }: LoaderArgs) {
  const url = new URL(request.url);
  const brands = url.searchParams.getAll("brand");

  return json(await getProducts({ brands }));
}</code></pre><br>
   <h4 id="dopolnenie-url-strokoy-zaprosa">Дополнение URL строкой запроса</h4><br>
   <p>URL легко дополняется строкой запроса с помощью компонента <code>Link</code>:</p><br>
   <pre><code class="javascript">&lt;Link to="?brand=nike"&gt;Nike (только)&lt;/Link&gt;</code></pre><br>
   <p><strong>Чтение параметров строки запроса в компонентах</strong></p><br>
   <p>Для доступа к параметрам строки запроса в компонентах используется хук <code>useSearchParams</code>:</p><br>
   <pre><code class="javascript">import { useSearchParams } from "@remix-run/react";

export default function ProductFilters() {
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  return (
    &lt;Form method="get"&gt;
      &lt;label htmlFor="nike"&gt;Nike&lt;/label&gt;
      &lt;input
        type="checkbox"
        id="nike"
        name="brand"
        value="nike"
        defaultChecked={brands.includes("nike")}
      /&gt;

      &lt;label htmlFor="adidas"&gt;Adidas&lt;/label&gt;
      &lt;input
        type="checkbox"
        id="adidas"
        name="brand"
        value="adidas"
        defaultChecked={brands.includes("adidas")}
      /&gt;

      &lt;button type="submit"&gt;Обновить&lt;/button&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>С помощью хука <code>useSubmit</code> можно отправлять форму при изменении значения любого поля:</p><br>
   <pre><code class="javascript">import {
  useSubmit,
  useSearchParams,
} from "@remix-run/react";

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  return (
    &lt;Form
      method="get"
      onChange={(e) =&gt; submit(e.currentTarget)}
    &gt;
      {/* ... */}
    &lt;/Form&gt;
  );
}</code></pre><br>
   <h4 id="parametry-stroki-zaprosa-i-upravlyaemye-inputy">Параметры строки запроса и управляемые инпуты</h4><br>
   <p>Что если мы хотим синхронизировать состояние чекбоксов со строкой запроса? В случае с управляемыми инпутами (controlled inputs) сделать это не так просто, как может показаться на первый взгляд.</p><br>
   <p>Предположим, что для изменения бренда в компоненте может использоваться как <code>&lt;input type="checkbox"&gt;</code> так и <code>&lt;Link /&gt;</code>:</p><br>
   <pre><code class="javascript">import { useSearchParams } from "@remix-run/react";

export default function ProductFilters() {
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  return (
    &lt;Form method="get"&gt;
      &lt;p&gt;
        &lt;label htmlFor="nike"&gt;Nike&lt;/label&gt;
        &lt;input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          defaultChecked={brands.includes("nike")}
        /&gt;
        &lt;Link to="?brand=nike"&gt;Nike&lt;/Link&gt;
      &lt;/p&gt;

      &lt;button type="submit"&gt;Обновить&lt;/button&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>Если пользователь выбирает чекбокс и отправляет форму, URL обновляется вместе с состоянием чекбокса. Но если пользователь нажимает на ссылку, то обновляется только URL, а состояние чекбокса остается прежним. Что если переключиться с <code>defaultChecked</code> на <code>checked</code>?</p><br>
   <pre><code class="javascript">&lt;input
  type="checkbox"
  id="adidas"
  name="brand"
  value="adidas"
  checked={brands.includes("adidas")}
/&gt;</code></pre><br>
   <p>Возникает другая проблема: при клике по ссылке меняется как URL, так и состояние чекбокса, но сам чекбокс больше не работает, поскольку React не позволяет изменять состояние чекбокса до изменения контролирующего его URL.</p><br>
   <p>Существует, как минимум, 2 решения.</p><br>
   <p>Самым простым является автоматическая отправка формы при выборе чекбокса:</p><br>
   <pre><code class="javascript">import {
  useSubmit,
  useSearchParams,
} from "@remix-run/react";

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  return (
    &lt;Form method="get"&gt;
      &lt;p&gt;
        &lt;label htmlFor="nike"&gt;Nike&lt;/label&gt;
        &lt;input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          onChange={(e) =&gt; submit(e.currentTarget.form)}
          checked={brands.includes("nike")}
        /&gt;
        &lt;Link to="?brand=nike"&gt;Nike&lt;/Link&gt;
      &lt;/p&gt;

      {/* ... */}
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p><em>Обратите внимание</em>: при отправке формы в <code>onChange()</code> следует предотвращать распространение события <code>submit</code> с помощью <code>stopPropagation()</code> во избежание всплытия (bubble) события до формы и ее повторной отправки.</p><br>
   <p>Второе решение предполагает наличие локального состояния для чекбокса:</p><br>
   <ul>
    <li>инициализируем состояние с помощью параметров строки запроса;</li>
    <li>обновляем состояние при выборе чекбокса пользователем;</li>
    <li>обновляем состояние при изменении строки запроса.</li>
   </ul><br>
   <pre><code class="javascript">import {
  useSubmit,
  useSearchParams,
} from "@remix-run/react";

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  const [nikeChecked, setNikeChecked] = React.useState(
    // инициализируем состояние с помощью параметров строки запроса
    brands.includes("nike")
  );

  // обновляем состояние при изменении строки запроса
  // (отправка формы или нажатие ссылки)
  React.useEffect(() =&gt; {
    setNikeChecked(brands.includes("nike"));
  }, [brands, searchParams]);

  return (
    &lt;Form method="get"&gt;
      &lt;p&gt;
        &lt;label htmlFor="nike"&gt;Nike&lt;/label&gt;
        &lt;input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          onChange={(e) =&gt; {
            // обновляем состояние чекбокса без отправки формы
            setNikeChecked(true);
          }}
          checked={nikeChecked}
        /&gt;
        &lt;Link to="?brand=nike"&gt;Nike&lt;/Link&gt;
      &lt;/p&gt;

      {/* ... */}
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>Эту логику работы с чекбоксами можно абстрагировать следующим образом:</p><br>
   <pre><code class="javascript">&lt;div&gt;
  &lt;SearchCheckbox name="brand" value="nike" /&gt;
  &lt;SearchCheckbox name="brand" value="reebok" /&gt;
  &lt;SearchCheckbox name="brand" value="adidas" /&gt;
&lt;/div&gt;;

function SearchCheckbox({ name, value }) {
  const [searchParams] = useSearchParams();
  const all = searchParams.getAll(name);
  const [checked, setChecked] = React.useState(
    all.includes(value)
  );

  React.useEffect(() =&gt; {
    setChecked(all.includes(value));
  }, [all, searchParams, value]);

  return (
    &lt;input
      type="checkbox"
      name={name}
      value={value}
      checked={checked}
      onChange={(e) =&gt; setChecked(e.target.checked)}
    /&gt;
  );
}</code></pre><br>
   <h3 id="optimizacii">Оптимизации</h3><br>
   <p>Remix перезагружает все роуты в трех случаях:</p><br>
   <ul>
    <li>вызов <code>action</code> (формы, <code>useSubmit()</code>, <code>fetcher.submit()</code>);</li>
    <li>изменение строки запроса;</li>
    <li>переход пользователя на текущую страницу (когда пользователь кликает по ссылке, ведущей на страницу, на которой он уже находится).</li>
   </ul><br>
   <h3 id="upravlenie-sostoyaniem">Управление состоянием</h3><br>
   <p>Remix спроектирован таким образом, что исключает необходимость использования каких-либо библиотек для управления состоянием приложения, вроде <code>React Query</code>, <code>SWR</code>, <code>Apollo</code>, <code>Relay</code>, <code>urql</code> и т.д. Однако он вовсе не исключает возможность их использования в случаях, когда возможностей, предоставляемых Remix, недостаточно для реализации функционала приложения.</p><br>
   <h3 id="zametki">Заметки</h3><br>
   <p><code>loader</code> выполняется на сервере с помощью <code>fetch</code>, предоставляемого браузером, поэтому данные сериализуются с помощью <code>JSON.stringify()</code>. Это означает, что данные, возвращаемые загрузчиком, должны быть сериализуемыми. Пример частично несериализуемых данных:</p><br>
   <pre><code class="javascript">export async function loader() {
  return {
    date: new Date(),
    someMethod() {
      return "некоторое значение";
    },
  };
}

export default function RouteComp() {
  const data = useLoaderData&lt;typeof loader&gt;();
  console.log(data);
  // '{"date":"..."}'
}</code></pre><br>
   <p>Для доступа к данным, возвращаемым загрузчиком, нельзя использовать <code>loader</code>:</p><br>
   <pre><code class="javascript">export const loader = async () =&gt; {
  return json(await fakeDb.products.findMany());
};

export default function RouteComp() {
  // не работает
  const data = loader();
}</code></pre><br>
   <h2 id="a-iddata_writesa-zapis-dannyh--data-writes">Запись данных / Data Writes</h2><br>
   <p>Запись данных в Remix основана на двух фундаментальных веб-интерфейсах: <code>&lt;form&gt;</code> и HTTP. Несмотря на использование прогрессивного улучшения для реализации оптимистичного обновления UI, индикаторов загрузки и отображения результатов валидации, модель программирования по-прежнему основывается на формах HTML.</p><br>
   <p>При отправке формы Remix:</p><br>
   <ul>
    <li>вызывает <code>action()</code> для формы;</li>
    <li>перезагружает все данные (<code>loader()</code>) для всех роутов страницы.</li>
   </ul><br>
   <p>Существует несколько способов вызвать <code>action()</code> и выполнить повторную валидацию роутов:</p><br>
   <ul>
    <li><code>&lt;Form&gt;</code></li>
    <li><code>useSubmit()</code></li>
    <li><code>useFetcher()</code></li>
   </ul><br>
   <p>В данном разделе мы будем говорить только о формах.</p><br>
   <h3 id="formy">Формы</h3><br>
   <p>Нативные формы поддерживают 2 глагола (verbs) HTTP: <code>GET</code> и <code>POST</code>. Эти глаголы сообщают Remix о наших намерениях. В случае с <code>GET</code> Remix определяет, какие части страницы меняются и запрашивает данные только для этих частей, а данные для частей, оставшихся прежними, доставляются из кэша. В случае с <code>POST</code> Remix перезагружает все данные для обеспечения их согласованности с серверными данными.</p><br>
   <h4 id="get">GET</h4><br>
   <p><code>GET</code> — это обычная навигация (navigation), когда данные формы конвертируются в строку запроса URL. Рассмотрим такую форму:</p><br>
   <pre><code class="javascript">&lt;form method="get" action="/search"&gt;
  &lt;label&gt;Искать &lt;input name="term" type="text" /&gt;&lt;/label&gt;
  &lt;button type="submit"&gt;Поиск&lt;/button&gt;
&lt;/form&gt;</code></pre><br>
   <p>Когда пользователь заполняет поле <code>term</code> и нажимаем "Поиск", браузер преобразуется данные формы в строку запроса и добавляет ее к URL, указанному в <code>action</code>. Предположим, что пользователь ввел <code>Remix</code>. Тогда браузер выполнит перенаправление к <code>/search?term=remix</code>. Если названием инпута будет <code>q</code>, браузер выполнит перенаправление к <code>/search?q=remix</code>.</p><br>
   <p>Пример с бОльшим количеством полей:</p><br>
   <pre><code class="javascript">&lt;form method="get" action="/search"&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Brand&lt;/legend&gt;
    &lt;label&gt;
      &lt;input name="brand" value="nike" type="checkbox" /&gt;
      Nike
    &lt;/label&gt;
    &lt;label&gt;
      &lt;input name="brand" value="reebok" type="checkbox" /&gt;
      Reebok
    &lt;/label&gt;
    &lt;label&gt;
      &lt;input name="color" value="white" type="checkbox" /&gt;
      Белый
    &lt;/label&gt;
    &lt;label&gt;
      &lt;input name="color" value="black" type="checkbox" /&gt;
      Черный
    &lt;/label&gt;
    &lt;button type="submit"&gt;Поиск&lt;/button&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;</code></pre><br>
   <p>В зависимости от того, какие чекбоксы выбрал пользователь, браузер будет выполнять перенаправления к таким URL:</p><br>
   <pre><code class="plaintext">/search?brand=nike&amp;color=black
/search?brand=nike&amp;brand=reebok&amp;color=white</code></pre><br>
   <h4 id="post">POST</h4><br>
   <p>Для создания, обновления или удаления данных используется метод <code>POST</code>. И речь идет не только о больших формах, например, для редактирования профиля пользователя, но и о кнопках типа "Нравится", обернутых в форму. Рассмотрим такую форму для создания нового проекта:</p><br>
   <pre><code class="javascript">&lt;form method="post" action="/projects"&gt;
  &lt;label&gt;Название: &lt;input name="name" type="text" /&gt;&lt;/label&gt;
  &lt;label&gt;Описание: &lt;textarea name="description"&gt;&lt;/textarea&gt;&lt;/label&gt;
  &lt;button type="submit"&gt;Создать&lt;/button&gt;
&lt;/form&gt;</code></pre><br>
   <p>Когда пользователь нажимает "Создать", браузер преобразует данные формы в тело запроса (request body) и отправляет запрос на сервер. После этого данные становятся доступными для обработчика запросов на сервере, что позволяет создать ноую запись в БД. Обработчик должен вернуть ответ. Вероятно, после создания записи нам следует перенаправить пользователя на страницу с только что созданным проектом:</p><br>
   <pre><code class="javascript">export async function action({ request }: ActionArgs) {
  const body = await request.formData();
  // создаем проект
  const project = await createProject(body);
  // выполняем перенаправление
  return redirect(`/projects/${project.id}`);
}</code></pre><br>
   <p>Собственно, это все, что требуется для выполнения мутации данных в Remix.</p><br>
   <h3 id="primer-prodvinutoy-mutacii">Пример продвинутой мутации</h3><br>
   <p>В этом примере мы реализуем следующее:</p><br>
   <ul>
    <li>опциональное использование JS;</li>
    <li>валидация формы;</li>
    <li>обработка ошибок;</li>
    <li>индикаторы загрузки (прогрессивное улучшение);</li>
    <li>отображение ошибок (прогрессивное улучшение).</li>
   </ul><br>
   <p><em>Обратите внимание</em>: для мутации данных в примере будет использоваться компонент <code>Form</code>. Использование этого компонента вместо нативного элемента <code>form</code> частично отключает дефолтное поведение браузера по обработке отправки формы. Если вы не планируете реализовывать кастомные индикаторы загрузки и оптимистичное обновление UI, передайте <code>Form</code> проп <code>reloadDocument</code>. Это сделает <code>Form</code> и <code>form</code> полностью идентичными.</p><br>
   <h4 id="forma">Форма</h4><br>
   <p>Допустим, что в <code>app/routes/projects/new.tsx</code> у нас имеется такая форма:</p><br>
   <pre><code class="javascript">import { Form } from "@remix-run/react";

export default function NewProject() {
  return (
    &lt;Form method="post" action="/projects/new"&gt;
      &lt;p&gt;
        &lt;label&gt;
          Название: &lt;input name="name" type="text" /&gt;
        &lt;/label&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label&gt;
          Описание:
          &lt;br /&gt;
          &lt;textarea name="description" /&gt;
        &lt;/label&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/p&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>Добавляем <code>action()</code> для этой формы (POST-запросы обрабатываются <code>action()</code>, а GET-запросы — <code>loader()</code>):</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node";

export const action = async ({ request }: ActionArgs) =&gt; {
  const formData = await request.formData();
  // создаем проект
  const project = await createProject(formData);
  // выполняем перенаправление
  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  // ...
}</code></pre><br>
   <h4 id="validaciya">Валидация</h4><br>
   <p>Предположим, что наш API возвращает ошибки валидации следующим образом:</p><br>
   <pre><code class="javascript">const [errors, project] = await createProject(formData);</code></pre><br>
   <p>При наличии ошибок мы возвращаемся к форме и показываем их:</p><br>
   <pre><code class="javascript">export const action = async ({ request }: ActionArgs) =&gt; {
  const formData = await request.formData();
  const [errors, project] = await createProject(formData);

  if (errors) {
    const values = Object.fromEntries(formData);
    return json({ errors, values });
  }

  return redirect(`/projects/${project.id}`);
};</code></pre><br>
   <p>Для доступа к данным, возвращаемым функцией <code>action</code> используется хук <code>useActionData</code>:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node";
import { useActionData } from "@remix-run/react";

export const action = async ({ request }: ActionArgs) =&gt; {
  // ...
};

export default function NewProject() {
  const actionData = useActionData&lt;typeof action&gt;();

  return (
    &lt;form method="post" action="/projects/new"&gt;
      &lt;p&gt;
        &lt;label&gt;
          Название:{" "}
          &lt;input
            name="name"
            type="text"
            defaultValue={actionData?.values.name}
          /&gt;
        &lt;/label&gt;
      &lt;/p&gt;

      {actionData?.errors.name ? (
        &lt;p style={{ color: "red" }}&gt;
          {actionData.errors.name}
        &lt;/p&gt;
      ) : null}

      &lt;p&gt;
        &lt;label&gt;
          Описание:
          &lt;br /&gt;
          &lt;textarea
            name="description"
            defaultValue={actionData?.values.description}
          /&gt;
        &lt;/label&gt;
      &lt;/p&gt;

      {actionData?.errors.description ? (
        &lt;p style={{ color: "red" }}&gt;
          {actionData.errors.description}
        &lt;/p&gt;
      ) : null}

      &lt;p&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/p&gt;
    &lt;/form&gt;
  );
}</code></pre><br>
   <p><em>Обратите внимание</em> на атрибут <code>defaultValue</code>. При отсутствии этого атрибута форма будет очищаться при каждой отправке.</p><br>
   <h4 id="sostoyanie-ozhidaniya">Состояние ожидания</h4><br>
   <p>Для доступа к состоянию ожидания или перехода (transition) используется хук <code>useTransition</code>:</p><br>
   <pre><code class="javascript">import { redirect } from "@remix-run/node";
import {
  useActionData,
  Form,
  useTransition,
} from "@remix-run/react";

// ...

export default function NewProject() {
  const transition = useTransition();
  const actionData = useActionData&lt;typeof action&gt;();

  return (
    &lt;Form method="post"&gt;
      &lt;fieldset
        disabled={transition.state === "submitting"}
      &gt;
        &lt;p&gt;
          &lt;label&gt;
            Название:{" "}
            &lt;input
              name="name"
              type="text"
              defaultValue={
                actionData
                  ? actionData.values.name
                  : undefined
              }
            /&gt;
          &lt;/label&gt;
        &lt;/p&gt;

        {actionData &amp;&amp; actionData.errors.name ? (
          &lt;p style={{ color: "red" }}&gt;
            {actionData.errors.name}
          &lt;/p&gt;
        ) : null}

        &lt;p&gt;
          &lt;label&gt;
            Описание:
            &lt;br /&gt;
            &lt;textarea
              name="description"
              defaultValue={
                actionData
                  ? actionData.values.description
                  : undefined
              }
            /&gt;
          &lt;/label&gt;
        &lt;/p&gt;

        {actionData &amp;&amp; actionData.errors.description ? (
          &lt;p style={{ color: "red" }}&gt;
            {actionData.errors.description}
          &lt;/p&gt;
        ) : null}

        &lt;p&gt;
          &lt;button type="submit"&gt;
            {transition.state === "submitting"
              ? "Создание..."
              : "Создать"}
          &lt;/button&gt;
        &lt;/p&gt;
      &lt;/fieldset&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <p>Теперь при нажатии "Создать" пользователем происходит блокировка полей формы и текст кнопки меняется на "Создание...".</p><br>
   <p>Кроме данных о состоянии отправки формы, содержащихся в <code>transition.submission</code>, мы можем получить доступ к данным формы через <code>transition.formData</code>.</p><br>
   <h4 id="soobscheniya-ob-oshibkah">Сообщения об ошибках</h4><br>
   <p>Реализуем простой компонент для анимирования высоты и прозрачности сообщений об ошибках:</p><br>
   <pre><code class="javascript">type Props = {
  error?: string;
  isSubmitting: boolean;
}

function ValidationMessage({ error, isSubmitting }: Props) {
  const [show, setShow] = useState(!!error);

  useEffect(() =&gt; {
    const id = setTimeout(() =&gt; {
      const hasError = !!error;
      setShow(hasError &amp;&amp; !isSubmitting);
    });
    return () =&gt; clearTimeout(id);
  }, [error, isSubmitting]);

  return (
    &lt;div
      style={{
        opacity: show ? 1 : 0,
        height: show ? "1em" : 0,
        color: "red",
        transition: "all 300ms ease-in-out",
      }}
    &gt;
      {error}
    &lt;/div&gt;
  );
}</code></pre><br>
   <p>Оборачиваем сообщения об ошибках в этот компонент и меняем цвет границ инпутов на красный при наличии ошибки:</p><br>
   <pre><code class="javascript">export default function NewProject() {
  const transition = useTransition();
  const actionData = useActionData&lt;typeof action&gt;();

  return (
    &lt;Form method="post"&gt;
      &lt;fieldset
        disabled={transition.state === "submitting"}
      &gt;
        &lt;p&gt;
          &lt;label&gt;
            Название:{" "}
            &lt;input
              name="name"
              type="text"
              defaultValue={
                actionData
                  ? actionData.values.name
                  : undefined
              }
              style={{
                borderColor: actionData?.errors.name
                  ? "red"
                  : "",
              }}
            /&gt;
          &lt;/label&gt;
        &lt;/p&gt;

        {actionData?.errors.name ? (
          &lt;ValidationMessage
            isSubmitting={transition.state === "submitting"}
            error={actionData?.errors?.name}
          /&gt;
        ) : null}

        &lt;p&gt;
          &lt;label&gt;
            Описание:
            &lt;br /&gt;
            &lt;textarea
              name="description"
              defaultValue={actionData?.values.description}
              style={{
                borderColor: actionData?.errors.description
                  ? "red"
                  : "",
              }}
            /&gt;
          &lt;/label&gt;
        &lt;/p&gt;

        &lt;ValidationMessage
          isSubmitting={transition.state === "submitting"}
          error={actionData?.errors.description}
        /&gt;

        &lt;p&gt;
          &lt;button type="submit"&gt;
            {transition.state === "submitting"
              ? "Создание..."
              : "Создать"}
          &lt;/button&gt;
        &lt;/p&gt;
      &lt;/fieldset&gt;
    &lt;/Form&gt;
  );
}</code></pre><br>
   <h2 id="a-idoptimistic_uia-optimistichnoe-obnovlenie-ui--optimistic-ui">Оптимистичное обновление UI / Optimistic UI</h2><br>
   <p>Оптимистичное обновление UI (оптимистичный UI) — это паттерн, позволяющий обновлять UI моментально с помощью "фейковых" (в том смысле, что они отличаются от серверных) данных без отображения индикаторов загрузки на время, необходимое серверу для обновления реальных данных. Как правило, на клиенте у нас для этого имеется достаточно данных. Если в процессе обновления данных на сервере возникла ошибка, мы восстанавливаем предыдущее состояние UI и сообщаем о проблеме пользователю. Однако в большинстве случаев обновление данных на сервере проходит успешно.</p><br>
   <p>В Remix оптимистичное обновление UI реализуется с помощью хуков <code>useTransition</code> и <code>useFetcher</code>.</p><br>
   <h3 id="strategiya">Стратегия</h3><br>
   <ol>
    <li>Пользователь отправляет форму (или мы делаем это сами с помощью <code>useSubmit()</code> или <code>fetcher.submit()</code>).</li>
    <li>Remix выполняет отправку формы и предоставляет в наше распоряжение данные формы в <code>transition.submission</code> или <code>fetcher.submission</code>.</li>
    <li>Приложение использует <code>submission.formData</code> для рендеринга оптимистичной версии страницы, т.е. той страницы, которая должна рендериться в случае успешной отправки формы.</li>
    <li>Remix автоматически ревалидирует все данные:<br>
     <ul>
      <li>при успешной отправке формы пользователь ничего не замечает;</li>
      <li>при неудачной отправке восстанавливается исходное состояние страницы, а пользователь получает сообщение об ошибке.</li>
     </ul></li>
   </ol><br>
   <h3 id="primer">Пример</h3><br>
   <p>Рассмотрим процесс создания нового проекта.</p><br>
   <p>Роут проекта загружает проект и рендерит его:</p><br>
   <pre><code class="javascript">// app/routes/project/$id.tsx
import type { LoaderArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import { ProjectView } from "~/components/project";

export async function loader({ params }: LoaderArgs) {
  return json(await findProject(params.id));
}

export default function ProjectRoute() {
  const project = useLoaderData&lt;typeof loader&gt;();

  return &lt;ProjectView project={project} /&gt;;
}</code></pre><br>
   <p>Критически важным здесь является то, что роут проекта рендерит повторно используемый компонент <code>ProjectView</code>, который в дальнейшем будет использоваться для оптимистичного обновления UI. Этот компонент может выглядеть так:</p><br>
   <pre><code class="javascript">// app/components/project.tsx
export type { Project } from "~/types";

type Props = {
  project: Project
}

export function ProjectView({ project }: Props) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{project.title}&lt;/h2&gt;
      &lt;p&gt;{project.description}&lt;/p&gt;
      &lt;ul&gt;
        {project.tasks.map((task) =&gt; (
          &lt;li key={task.id}&gt;{task.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre><br>
   <p>Реализуем роут создания проекта:</p><br>
   <pre><code class="javascript">// app/routes/projects/new.tsx
import type { ActionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node";
import { Form } from "@remix-run/react";

import { createProject } from "~/utils";

export const action = async ({ request }: ActionArgs) =&gt; {
  const body = await request.formData();
  const newProject = Object.fromEntries(body);

  const project = await createProject(newProject);

  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  return (
    &lt;&gt;
      &lt;h2&gt;Новый проект&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;label&gt;
          Название: &lt;input name="title" type="text" /&gt;
        &lt;/label&gt;
        &lt;label htmlFor="description"&gt;Описание:&lt;/label&gt;
        &lt;textarea name="description" id="description" /&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/Form&gt;
    &lt;/&gt;
  );
}</code></pre><br>
   <p><code>useTransition()</code> позволяет легко реализовать индикатор загрузки на время отправки формы, создания новой записи в БД и ответа сервера в виде перенаправления на страницу проекта:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node";
// !
import { Form, useTransition } from "@remix-run/react";

import { createProject } from "~/utils";

export const action = async ({ request }: ActionArgs) =&gt; {
  const body = await request.formData();
  const newProject = Object.fromEntries(body);
  const project = await createProject(newProject);
  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  // !
  const transition = useTransition();

  return (
    &lt;&gt;
      &lt;h2&gt;Новый проект&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;label&gt;
          Название: &lt;input name="title" type="text" /&gt;
        &lt;/label&gt;
        &lt;label htmlFor="description"&gt;Описание:&lt;/label&gt;
        &lt;textarea name="description" id="description" /&gt;
        &lt;button
          type="submit"
          // !
          disabled={transition.submission}
        &gt;
          {transition.submission
            ? "Создание..."
            : "Создать"}
        &lt;/button&gt;
      &lt;/Form&gt;
    &lt;/&gt;
  );
}</code></pre><br>
   <p>Однако, поскольку мы знаем, что создание проекта на сервере почти наверняка будет успешным, имеем все необходимые данные и знаем, как будет выглядеть страница, мы может заменить индикатор загрузки компонентом <code>ProjectView</code>:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node";
import { Form, useTransition } from "@remix-run/react";

// !
import { ProjectView } from "~/components/project";
import { createProject } from "~/utils";

export const action = async ({ request }: ActionArgs) =&gt; {
  const body = await request.formData();
  const newProject = Object.fromEntries(body);
  const project = await createProject(newProject);
  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  const transition = useTransition();
  // !
  return transition.submission ? (
    &lt;ProjectView
      project={Object.fromEntries(
        transition.submission.formData
      )}
    /&gt;
  ) : (
    &lt;&gt;
      &lt;h2&gt;Новый проект&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;label&gt;
          Название: &lt;input name="title" type="text" /&gt;
        &lt;/label&gt;
        &lt;label htmlFor="description"&gt;Описание:&lt;/label&gt;
        {/* ! */}
        &lt;textarea name="description" id="description" /&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/Form&gt;
    &lt;/&gt;
  );
}</code></pre><br>
   <p>Теперь после того как пользователь нажал "Создать", UI обновляется мгновенно. После успешного создания проекта, пользователь перенаправляется на его страницу. Поскольку в обоих случаях для рендеринга UI используется компонент <code>ProjectView</code>, все, что может заметить пользователь, это изменение URL.</p><br>
   <p>Самой сложной частью оптимистичного обновления UI является обработка потенциальных ошибок и уведомление пользователя о том, что операция провалилась. Здесь существует 2 варианта: позволить Remix обработать ошибку автоматически посредством рендеринга ближайшего <code>ErrorBoundary</code> или вернуть ошибку из <code>loader()</code>. Рассмотрим второй вариант:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import {
  Form,
  useActionData,
  useTransition,
} from "@remix-run/react";

import { ProjectView } from "~/components/project";
import { createProject } from "~/utils";

export const action = async ({ request }: ActionArgs) =&gt; {
  const body = await request.formData();
  const newProject = Object.fromEntries(body);

  try {
    const project = await createProject(newProject);

    return redirect(`/projects/${project.id}`);
  } catch (e: unknown) {
    console.error(e);

    return json("Во время создания проекта произошла ошибка", {
      status: 500,
    });
  }
};

export default function NewProject() {
  const error = useActionData&lt;typeof action&gt;();
  const transition = useTransition();

  return transition.submission ? (
    &lt;ProjectView
      project={Object.fromEntries(
        transition.submission.formData
      )}
    /&gt;
  ) : (
    &lt;&gt;
      &lt;h2&gt;Новый проект&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;label&gt;
          Название: &lt;input name="title" type="text" /&gt;
        &lt;/label&gt;
        &lt;label htmlFor="description"&gt;Описание:&lt;/label&gt;
        &lt;textarea name="description" id="description" /&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/Form&gt;
      {error ? &lt;p&gt;{error}&lt;/p&gt; : null}
    &lt;/&gt;
  );
}</code></pre><br>
   <p>Теперь при возникновении ошибки пользователь возвращается к форме и видит соответствующее сообщение.</p><br>
   <h3 id="validaciya-na-storone-klienta">Валидация на стороне клиента</h3><br>
   <p>Во избежание лишних ошибок, связанных с отсутствием или неверным форматом данных, необходимых для создания проекта, может быть полезным валидировать значения полей формы на клиенте. К счастью, это легко реализовать с помощью встроенных механизмов HTML-элементов:</p><br>
   <pre><code class="javascript">import type { ActionArgs } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import {
  Form,
  useActionData,
  useTransition,
} from "@remix-run/react";

import { ProjectView } from "~/components/project";
import { createProject } from "~/utils";

export const action = async ({ request }: ActionArgs) =&gt; {
  const body = await request.formData();
  const newProject = Object.fromEntries(body);
  try {
    const project = await createProject(newProject);
    return redirect(`/projects/${project.id}`);
  } catch (e: unknown) {
    console.error(e);
    return json("Во время создания проекта произошла ошибка", {
      status: 500,
    });
  }
};

export default function NewProject() {
  const error = useActionData&lt;typeof action&gt;();
  const transition = useTransition();

  return transition.submission ? (
    &lt;ProjectView
      project={Object.fromEntries(
        transition.submission.formData
      )}
    /&gt;
  ) : (
    &lt;&gt;
      &lt;h2&gt;Новый проект&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;label&gt;
          Название:{" "}
          &lt;input
            // минимальная длина названия проекта - 3 символа
            minLength={3}
            name="title"
            // название проекта является обязательным
            required
            type="text"
          /&gt;
        &lt;/label&gt;
        &lt;label htmlFor="description"&gt;Описание:&lt;/label&gt;
        &lt;textarea name="description" id="description" /&gt;
        &lt;button type="submit"&gt;Создать&lt;/button&gt;
      &lt;/Form&gt;
      {error ? &lt;p&gt;{error}&lt;/p&gt; : null}
    &lt;/&gt;
  );
}</code></pre><br>
   <p>К слову, шаблон поля для ввода email может выглядеть так:</p><br>
   <pre><code class="javascript">&lt;input
  type="email"
  name="email"
  // !
  pattern="[^@\s]+@[^@\s]+\.[^@\s]+"
  required
/&gt;</code></pre><br>
   <h2 id="a-idmodule_constraintsa-ogranicheniya-moduley--module-constraints">Ограничения модулей / Module Constraints</h2><br>
   <p>Поскольку приложение Remix выполняется как на сервере, так и в браузере, следует проявлять осторожность в отношении побочных эффектов модулей (module side effects).</p><br>
   <ul>
    <li>серверный код — Remix не сможет удалить серверный код из сборки для браузера при наличии побочных эффектов, использующих серверный код;</li>
    <li>клиентский код — Remix рендерит страницы на сервере, поэтому модули на верхнем уровне не должны содержать код, обращающийся в браузерным API.</li>
   </ul><br>
   <h3 id="udalenie-servernogo-koda-iz-sborki-dlya-brauzera">Удаление серверного кода из сборки для браузера</h3><br>
   <p>Для удаления серверного кода из сборки для клиента Remix делает следующее:</p><br>
   <ul>
    <li>создает "проксирующий" модуль для роута;</li>
    <li>этот модуль импортирует только браузерные экспорты.</li>
   </ul><br>
   <p>Рассмотрим модуль, экспортирующий функции <code>loader</code>, <code>meta</code> и компонент:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import PostsView from "../PostsView";
import { prisma } from "../db";

export async function loader() {
  return json(await prisma.post.findMany());
}

export function meta() {
  return { title: "Список постов" };
}

export default function Posts() {
  const posts = useLoaderData&lt;typeof loader&gt;();
  return &lt;PostsView posts={posts} /&gt;;
}</code></pre><br>
   <p>Серверу требуются весь код модуля, а браузеру — только компонент и <code>meta()</code>. Если <code>prisma</code> попадет в клиентскую сборку, то модуль сломается, поскольку <code>prisma</code> использует большое количество API Node.js.</p><br>
   <p>Прокси-модуль для этого роута выглядит так:</p><br>
   <pre><code class="javascript">export { meta, default } from "./routes/posts.tsx";</code></pre><br>
   <p>А код для клиентской сборки так:</p><br>
   <pre><code class="javascript">import { useLoaderData } from "@remix-run/react";

import PostsView from "../PostsView";

export function meta() {
  return { title: "Список постов" };
}

export default function Posts() {
  const posts = useLoaderData&lt;typeof loader&gt;();

  return &lt;PostsView posts={posts} /&gt;;
}</code></pre><br>
   <h4 id="pobochnye-effekty-moduley">Побочные эффекты модулей</h4><br>
   <p>Простыми словами, побочный эффект — это код, который что-то делает, а побочный эффект модуля — это код, который что-то делает при загрузке модуля.</p><br>
   <p>Например, добавление такой строки кода в предыдущий пример сломает модуль:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import PostsView from "../PostsView";
import { prisma } from "../db";
// !
console.log(prisma);

export async function loader() {
  return json(await prisma.post.findMany());
}

export function meta() {
  return { title: "Список постов" };
}

export default function Posts() {
  const posts = useLoaderData&lt;typeof loader&gt;();
  return &lt;PostsView posts={posts} /&gt;;
}</code></pre><br>
   <p>Импортируемый серверный модуль <code>prisma</code> выводится в консоль, поэтому код для клиентской сборки будет выглядеть следующим образом:</p><br>
   <pre><code class="javascript">import { useLoaderData } from "@remix-run/react";

import PostsView from "../PostsView";
// !
import { prisma } from "../db"; // 😬
// !
console.log(prisma); // 🥶

export function meta() {
  return { title: "Список постов" };
}

export default function Posts() {
  const posts = useLoaderData&lt;typeof loader&gt;();
  return &lt;PostsView posts={posts} /&gt;;
}</code></pre><br>
   <p><code>loader()</code> была удалена, но импорт <code>prisma</code> остался.</p><br>
   <p>В данном случае проблему легко устранить путем перемещения логгирования в <code>loader()</code>:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import PostsView from "../PostsView";
import { prisma } from "../db";

export async function loader() {
  // !
  console.log(prisma);
  return json(await prisma.post.findMany());
}

export function meta() {
  return { title: "Список постов" };
}

export default function Posts() {
  const posts = useLoaderData&lt;typeof loader&gt;();
  return &lt;PostsView posts={posts} /&gt;;
}</code></pre><br>
   <p>Теперь импорт <code>prisma</code> будет удален вместе с <code>loader()</code>.</p><br>
   <p>Если вы столкнулись с ситуацией, когда серверный код попадает в сборку для браузера при отсутствии побочных эффектов модулей, перенесите соответствующий код в файл, название которого содержит суффикс <code>server</code>, например, <code>db.server.ts</code>. Это сообщит Remix, что такой код используется только на сервере.</p><br>
   <h3 id="funkcii-bolee-vysokogo-poryadka">Функции более высокого порядка</h3><br>
   <p>При работе с Remix велик соблазн абстрагировать <code>loader()</code> с помощью функций более высокого порядка (higher order functions), например, так:</p><br>
   <pre><code class="javascript">import { redirect } from "@remix-run/node";

export function removeTrailingSlash(loader) {
  return function (arg) {
    const { request } = arg;
    const url = new URL(request.url);
    if (
      url.pathname !== "/" &amp;&amp;
      url.pathname.endsWith("/")
    ) {
      return redirect(request.url.slice(0, -1), {
        status: 308,
      });
    }
    return loader(arg);
  };
}</code></pre><br>
   <p>И использовать их следующим образом:</p><br>
   <pre><code class="javascript">import { removeTrailingSlash } from "~/http";

export const loader = removeTrailingSlash(({ request }) =&gt; {
  return { some: "data" };
});</code></pre><br>
   <p>Это делает <code>loader()</code> побочным эффектом модуля, поэтому он не будет удален из клиентской сборки.</p><br>
   <p>Для того, чтобы реализовать ранний возврат ответа, достаточно выбросить ответ в <code>loader()</code>:</p><br>
   <pre><code class="javascript">import { redirect } from "@remix-run/node";

export function removeTrailingSlash(url) {
  if (url.pathname !== "/" &amp;&amp; url.pathname.endsWith("/")) {
    throw redirect(request.url.slice(0, -1), {
      status: 308,
    });
  }
}</code></pre><br>
   <p>Пример использования:</p><br>
   <pre><code class="javascript">import { json } from "@remix-run/node";

import { removeTrailingSlash } from "~/http";

export const loader = async ({ request }: LoaderArgs) =&gt; {
  removeTrailingSlash(request.url);
  return json({ some: "data" });
};</code></pre><br>
   <p>Это позволит Remix исключить <code>loader</code> из сборки для браузера. Кроме того, такой код легче читать. Сравните следующие блоки кода:</p><br>
   <pre><code class="javascript">// 1
export const loader = async ({ request }: LoaderArgs) =&gt; {
  return removeTrailingSlash(request.url, () =&gt; {
    return withSession(request, (session) =&gt; {
      return requireUser(session, (user) =&gt; {
        return json(user);
      });
    });
  });
};

// 2
export const loader = async ({ request }: LoaderArgs) =&gt; {
  removeTrailingSlash(request.url);
  const session = await getSession(request);
  const user = await requireUser(session);
  return json(user);
};</code></pre><br>
   <p>Какой вам нравится больше? Полагаю, ответ очевиден. В данном случае можно провести аналогию между использованием <code>async/await</code> вместо промисов и коллбэков.</p><br>
   <h3 id="brauzernyy-kod-na-servere">Браузерный код на сервере</h3><br>
   <p>Remix не удаляет браузерный код из сборки для сервера, поскольку модули нуждаются в каждом экспорте для успешного серверного рендеринга. Это означает, что ответственность за изоляцию кода, который должен выполняться только в браузере, ложится на плечи разработчика.</p><br>
   <p>Следующий пример сломает приложение:</p><br>
   <pre><code class="javascript">import { loadStripe } from "@stripe/stripe-js";

// переменная `window` не определена, поскольку код выполняется на сервере
const stripe = await loadStripe(window.ENV.stripe);

export async function redirectToStripeCheckout(sessionId) {
  return stripe.redirectToCheckout({ sessionId });
}</code></pre><br>
   <h4 id="inicializaciya-brauzernyh-api">Инициализация браузерных API</h4><br>
   <p>Существует несколько способов инициализации браузерных интерфейсов при импорте модуля.</p><br>
   <p><em>Защитник документа (document guard)</em></p><br>
   <pre><code class="javascript">import firebase from "firebase/app";

// !
if (typeof document !== "undefined") {
  firebase.initializeApp(document.ENV.firebase);
}

export { firebase };</code></pre><br>
   <p>Если переменная <code>document</code> определена, значит средой выполнения кода является браузер. Проверка "определенности" <code>document</code> является более надежным способом идентификации браузера, чем <code>window</code>, потому что в Deno, например, имеется глобальная переменная <code>window</code>.</p><br>
   <p><em>Ленивая инициализация</em></p><br>
   <p>Суть данного подхода состоит в том, что браузерный API инициализируется при использовании библиотеки (вызове функции):</p><br>
   <pre><code class="javascript">import { loadStripe } from "@stripe/stripe-js";

export async function redirectToStripeCheckout(sessionId) {
  // !
  const stripe = await loadStripe(window.ENV.stripe);
  return stripe.redirectToCheckout({ sessionId });
}</code></pre><br>
   <p>Во избежание множественной инициализации достаточно записать интерфейс в глобальную (в пределах модуля) переменную:</p><br>
   <pre><code class="javascript">import { loadStripe } from "@stripe/stripe-js";

let _stripe;
async function getStripe() {
  if (!_stripe) {
    _stripe = await loadStripe(window.ENV.stripe);
  }
  return _stripe;
}

export async function redirectToStripeCheckout(sessionId) {
  const stripe = await getStripe();
  return stripe.redirectToCheckout({ sessionId });
}</code></pre><br>
   <h4 id="rendering-s-brauzernymi-api">Рендеринг с браузерными API</h4><br>
   <p>Другим распространенным случаем является обращение к браузерным интерфейсам в процессе рендеринга.</p><br>
   <p>Следующим пример сломает приложение, поскольку сервер попытается использовать локальное хранилище (local storage):</p><br>
   <pre><code class="javascript">function useLocalStorage(key) {
  const [state, setState] = useState(
    localStorage.getItem(key)
  );

  const setWithLocalStorage = (nextState) =&gt; {
    setState(nextState);
  };

  return [state, setWithLocalStorage];
}</code></pre><br>
   <p>Для решения проблемы достаточно перенести инициализацию состояния в хук <code>useEffect</code>:</p><br>
   <pre><code class="javascript">function useLocalStorage(key) {
  const [state, setState] = useState(null);

  useEffect(() =&gt; {
    setState(localStorage.getItem(key));
  }, [key]);

  const setWithLocalStorage = (nextState) =&gt; {
    setState(nextState);
  };

  return [state, setWithLocalStorage];
}</code></pre><br>
   <p>Напоследок, рассмотрим кастомный хук, позволяющий безопасно использовать хук <code>useLayoutEffect</code>:</p><br>
   <pre><code class="javascript">import React from "react";

const canUseDOM = typeof document !== "undefined";

const useLayoutEffect = canUseDOM
  ? React.useLayoutEffect
  : () =&gt; {};</code></pre><br>
   <h2 id="a-iderror_handlinga-obrabotka-oshibok--error-handling">Обработка ошибок / Error Handling</h2><br>
   <p>Remix автоматически перехватывает (catch) ошибку и рендерит ближайший (к месту ее возникновения) <code>ErrorBoundary</code> (предохранитель) в случаях, когда ошибка возникла в процессе:</p><br>
   <ul>
    <li>рендеринга в браузере;</li>
    <li>рендеринга на сервере;</li>
    <li>в <code>loader()</code> при первоначальном запросе на серверный рендеринг документа;</li>
    <li>в <code>action()</code> при первоначальном запросе на серверный рендеринг документа;</li>
    <li>в <code>loader()</code> при переходе на стороне клиента в браузере (Remix сериализует ошибку и отправляет ее по сети в браузер);</li>
    <li>в <code>action()</code> при переходе на стороне клиента в браузере.</li>
   </ul><br>
   <h3 id="kornevoy-predohranitel">Корневой предохранитель</h3><br>
   <p>При использовании стартового шаблона в файле <code>root.{tsx|jsx}</code> имеется такой предохранитель:</p><br>
   <pre><code class="javascript">export function ErrorBoundary({ error }) {
  console.error(error);

  return (
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;О, нет!&lt;/title&gt;
        &lt;Meta /&gt;
        &lt;Links /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        {/* UI, который будет рендериться при возникновении ошибки */}
        &lt;Scripts /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</code></pre><br>
   <p>При рендеринге корневого предохранителя перемонтируется весь документ — это объясняет необходимость рендеринга компонентов <code>Meta</code>, <code>Links</code> и <code>Scripts</code>.</p><br>
   <h3 id="vlozhennye-predohraniteli">Вложенные предохранители</h3><br>
   <p>Каждый роут может содержать собственный предохранитель. Преимущество такого подхода состоит в том, что при возникновении ошибки в роуте с предохранителем только определенная часть UI окажется сломанной, остальная страница будет выглядеть как задумывалось.</p><br>
   <p>Рассмотрим такую иерархию роутов:</p><br>
   <pre><code class="plaintext">├── sales
│   ├── invoices
│   │   └── $invoiceId.js
│   └── invoices.js
└── sales.js</code></pre><br>
   <p>Если <code>$invoiceId.js</code> экспортирует <code>ErrorBoundary</code> и ошибка возникает в его компоненте, <code>loader()</code> или <code>action()</code>, сломается только раздел счета (invoice), остальная часть страницы будет успешно отрендерена.</p><br>
   <p>Если роут не содержит собственного предохранителя, ошибка "всплывает" до ближайшего родительского предохранителя, поэтому нет необходимости экспортировать <code>ErrorBoundary</code> из каждого модуля.</p><br>
   <h2 id="a-idnot_founda-obrabotka-oshibki-404--not-found-handling">Обработка ошибки 404 / Not Found Handling</h2><br>
   <p>Случаи отправки статус-кода 404:</p><br>
   <ul>
    <li>URL не совпадает ни с одним роутом;</li>
    <li><code>loader()</code> не обнаружил необходимых данных.</li>
   </ul><br>
   <p>Первый случай обрабатывается Remix автоматически, обработка второго случая — задача разработчика.</p><br>
   <p>При отсутствии данных, запрашиваемых пользователем, необходимо выбросить ответ:</p><br>
   <pre><code class="javascript">export async function loader({ params }: LoaderArgs) {
  const page = await db.page.findOne({
    where: { slug: params.slug },
  });

  if (!page) {
    throw new Response("Не найдено", {
      status: 404,
    });
  }

  return json(page);
}</code></pre><br>
   <p>Remix перехватывает такой ответ и передает управление ближайшему перехватчику (catch boundary). Перехватчик похож на предохранитель (error boundary), только вместо компонента <code>ErrorBoundary</code> из модуля должен экспортироваться компонент <code>CatchBoundary</code>.</p><br>
   <p>Когда выбрасывается ответ, код <code>loader()</code> перестает выполняться. Это означает, что нам не нужно заботиться об обработке состояния ожидания, ошибок и отсутствия данных в компоненте.</p><br>
   <h4 id="kornevoy-perehvatchik">Корневой перехватчик</h4><br>
   <p>Корневой перехватчик может выглядеть так:</p><br>
   <pre><code class="javascript">export function CatchBoundary() {
  const caught = useCatch();

  return (
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Упс!&lt;/title&gt;
        &lt;Meta /&gt;
        &lt;Links /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          {caught.status} {caught.statusText}
        &lt;/h1&gt;
        &lt;Scripts /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</code></pre><br>
   <h4 id="vlozhennye-perehvatchiki">Вложенные перехватчики</h4><br>
   <p>Каждый роут может экспортировать собственного перехватчика:</p><br>
   <pre><code class="javascript">import type { LoaderArgs } from "@remix-run/node";
import {
  Form,
  useLoaderData,
  useParams,
} from "@remix-run/react";

export async function loader({ params }: LoaderArgs) {
  const page = await db.page.findOne({
    where: { slug: params.slug },
  });

  if (!page) {
    throw new Response("Не найдено", {
      status: 404,
    });
  }

  return json(page);
}

export function CatchBoundary() {
  const params = useParams();

  return (
    &lt;div&gt;
      &lt;h2&gt;Запрашиваемая страница отсутствует&lt;/h2&gt;
      &lt;Form action="../create"&gt;
        &lt;button
          type="submit"
          name="slug"
          value={params.slug}
        &gt;
          Создать {params.slug}?
        &lt;/button&gt;
      &lt;/Form&gt;
    &lt;/div&gt;
  );
}

export default function Page() {
  return &lt;PageView page={useLoaderData&lt;typeof loader&gt;()} /&gt;;
}</code></pre><br>
   <p>Понятно, что так могут обрабатываться любые ответы, а не только 404.</p><br>
   <h2 id="a-idenva-peremennye-sredy-okruzheniya--environment-variables">Переменные среды окружения / Environment Variables</h2><br>
   <p>Remix имеет встроенную поддержку <a href="https://www.npmjs.com/package/dotenv">dotenv</a> в режиме разработки, поэтому при выполнении команды <code>remix dev</code> переменные среды окружения доступны через <code>process.env</code>.</p><br>
   <p>Создаем файл <code>.env</code> в корне проекта:</p><br>
   <pre><code class="bash">touch .env</code></pre><br>
   <p>Редактируем этот файл:</p><br>
   <pre><code class="bash">SOME_SECRET=super-secret</code></pre><br>
   <p>Получаем доступ к этой переменной в <code>loader()</code> или <code>action()</code>:</p><br>
   <pre><code class="javascript">export async function loader() {
  console.log(process.env.SOME_SECRET);
}</code></pre><br>
   <p>При выполнении команды <code>remix serve</code> переменные среды окружения в <code>process.env</code> не загружаются, они должны устанавливаться производственным сервером. Способы их установки зависят от используемого хостинга.</p><br>
   <p>При необходимости доступа к переменным на клиенте можно сделать следующее:</p><br>
   <ul>
    <li>вернуть <code>ENV</code> из корневого <code>loader()</code>:</li>
   </ul><br>
   <pre><code class="javascript">export async function loader() {
  return json({
    ENV: {
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
      FAUNA_DB_URL: process.env.FAUNA_DB_URL,
    },
  });
}

export function Root() {
  return (
    &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;Meta /&gt;
        &lt;Links /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;Outlet /&gt;
        &lt;Scripts /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</code></pre><br>
   <ul>
    <li>записать <code>ENV</code> в глобальный объект <code>window</code>:</li>
   </ul><br>
   <pre><code class="javascript">export async function loader() {
  return json({
    ENV: {
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
    },
  });
}

export function Root() {
  const data = useLoaderData&lt;typeof loader&gt;();

  return (
    &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;Meta /&gt;
        &lt;Links /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;Outlet /&gt;
        &lt;script
          dangerouslySetInnerHTML={{
            __html: `window.ENV = ${JSON.stringify(
              data.ENV
            )}`,
          }}
        /&gt;
        &lt;Scripts /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</code></pre><br>
   <pre><code class="javascript">import { loadStripe } from "@stripe/stripe-js";

export async function redirectToStripeCheckout(
  sessionId
) {
  const stripe = await loadStripe(
    window.ENV.STRIPE_PUBLIC_KEY
  );
  return stripe.redirectToCheckout({ sessionId });
}</code></pre><br>
   <h2 id="a-idstylinga-stilizaciya--styling">Стилизация / Styling</h2><br>
   <p>Основным способом стилизации веб-приложений является добавление <code>&lt;link rel="stylesheet"&gt;</code> на страницу. В Remix это делается посредством экспорта из роута функции <code>links</code>. Когда роут является активным, таблица стилей добавляется на страницу. Когда роут больше не является активным, таблица стилей удаляется со страницы.</p><br>
   <pre><code class="javascript">export function links() {
  return [
    {
      rel: "stylesheet",
      href: "https://unpkg.com/modern-css-reset@1.4.0/dist/reset.min.css",
    },
  ];
}</code></pre><br>
   <p><code>links()</code> вложенных роутов объединяются и рендерятся по порядку (начиная с корневого роута) в виде тегов <code>link</code> с помощью компонента <code>Link</code> в разделе <code>head</code> в файле <code>app/root.jsx</code>:</p><br>
   <pre><code class="javascript">import { Links } from "@remix-run/react";

export default function Root() {
  return (
    &lt;html&gt;
      &lt;head&gt;
        &lt;Links /&gt;
        {/* ... */}
      &lt;/head&gt;
      {/* ... */}
    &lt;/html&gt;
  );
}</code></pre><br>
   <p>Файлы CSS могут импортироваться в модули напрямую. В этом случае Remix:</p><br>
   <ul>
    <li>копирует файл в директорию для клиентской сборки;</li>
    <li>создает отпечаток (fingerprint) файла для долгосрочного кэширования;</li>
    <li>возвращает URL для использования в модуле в процессе рендеринга.</li>
   </ul><br>
   <pre><code class="javascript">import styles from "~/styles/global.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}</code></pre><br>
   <p>Преимущества использования <code>&lt;link&gt;</code> для загрузки стилей заключаются в следующем:</p><br>
   <ul>
    <li>URL может кэшироваться браузером и CDN;</li>
    <li>один и тот же URL может использоваться разными страницами приложения;</li>
    <li>таблица стилей может загружаться одновременно с JS;</li>
    <li>ресурсы CSS могут запрашиваться предварительно с помощью <code>&lt;link rel="prefetch" /&gt;</code>;</li>
    <li>изменения в компонентах не ломают кэш для стилей;</li>
    <li>изменения в стилях не ломают кэш для JS.</li>
   </ul><br>
   <h3 id="obychnye-tablicy-stiley">Обычные таблицы стилей</h3><br>
   <h4 id="stili-routov">Стили роутов</h4><br>
   <p>Каждый роут может добавлять собственные стили на страницу:</p><br>
   <pre><code class="javascript">// app/routes/dashboard.tsx
import styles from "~/styles/dashboard.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}</code></pre><br>
   <pre><code class="javascript">// app/routes/accounts.tsx
import styles from "~/styles/accounts.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}</code></pre><br>
   <pre><code class="javascript">// app/routes/sales.tsx
import styles from "~/styles/sales.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}</code></pre><br>
   <p>Соотношение URL и загружаемых стилей может выгялдеть так:</p><br>
   <ul>
    <li><code>/dashboard</code> — <code>dashboard.css</code>;</li>
    <li><code>/dashboard/accounts</code> — <code>dashboard.css</code> и <code>accounts.css</code>;</li>
    <li><code>/dashboard/sales</code> — <code>dashboard.css</code> и <code>sales.css</code>.</li>
   </ul><br>
   <p>Такой подход к загрузке стилей решает многие проблемы, связанные со стилизацией приложения: загрузка только используемых на текущей странице стилей, совпадение селекторов и названий классов, загрузка старых стилей, которые больше не используются и т.д.</p><br>
   <h4 id="raspredelennye-stili">Распределенные стили</h4><br>
   <p>В любом приложении имеются общие (распределенные — shared) компоненты: формы, кнопки, макеты и др. В Remix для стилизации таких компонентов рекомендуется использовать один из 2 подходов.</p><br>
   <p><em>Глобальная таблица стилей</em></p><br>
   <p>Создаем файл <code>shared.css</code> (или <code>global.css</code>):</p><br>
   <pre><code class="css">/* app/styles/shared.css */
/* используем названия классов */
.PrimaryButton {
  /* ... */
}

.TileGrid {
  /* ... */
}

/* или data-атрибуты */
[data-primary-button] {
  /* ... */
}

[data-tile-grid] {
  /* ... */
}</code></pre><br>
   <p>Импортируем этот файл в <code>app/root.tsx</code>:</p><br>
   <pre><code class="javascript">// app/root.tsx
import styles from "~/styles/shared.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}</code></pre><br>
   <p><em>Совместное использование стилей</em></p><br>
   <p>Создаем CSS-файл для каждого компонента и загружаем стили в роуте, который его использует.</p><br>
   <p>Предположим, что у нас имеется компонент <code>Button</code> в <code>app/components/button/index.js</code> со стилями в <code>app/components/button/styles.css</code>, а также компонент <code>PrimaryButton</code>, расширяющий <code>Button</code>.</p><br>
   <pre><code class="css">/* app/components/button/styles.css */
.btn {
  border: solid 1px;
  background: white;
  color: #454545;
}</code></pre><br>
   <pre><code class="javascript">// app/components/button/index.jsx
import styles from "./styles.css";

export const links = () =&gt; [
  { rel: "stylesheet", href: styles },
];

export const Button = React.forwardRef(
  ({ children, ...props }, ref) =&gt; {
    return &lt;button {...props} ref={ref} className="btn" /&gt;;
  }
);
Button.displayName = "Button";</code></pre><br>
   <p><em>Обратите внимание</em>, что <code>Button</code> экспортирует <code>links()</code>, хотя не является роутом.</p><br>
   <pre><code class="css">/* app/components/button-primary/styles.css */
.btn-primary {
  background: blue;
  color: white;
}</code></pre><br>
   <pre><code class="javascript">// app/components/button-primary/index.jsx
import { Button, links as buttonLinks } from "../button";
import styles from "./styles.css";

export const links = () =&gt; [
  ...buttonLinks(),
  { rel: "stylesheet", href: styles },
];

export const PrimaryButton = React.forwardRef(
  ({ children, ...props }, ref) =&gt; {
    return (
      &lt;Button {...props} ref={ref} className="btn btn-primary" /&gt;
    );
  }
);
PrimaryButton.displayName = "PrimaryButton";</code></pre><br>
   <p><em>Обратите внимание</em>, что <code>PrimaryButton</code> включает стили для <code>Button</code>.</p><br>
   <p>Поскольку кнопки не являются роутами, т.е. не связаны с сегментами URL, Remix не знает, когда предварительно запрашивать, загружать и выгружать их стили. Поэтому импорт и добавление на страницу стилей для кнопок должен дублироваться в роуте, который использует кнопки:</p><br>
   <pre><code class="javascript">import styles from "~/styles/index.css";

import {
  PrimaryButton,
  links as primaryButtonLinks,
} from "~/components/button-primary";

export function links() {
  return [
    ...primaryButtonLinks(),
    { rel: "stylesheet", href: styles },
  ];
}</code></pre><br>
   <p><em>Предварительная загрузка ресурсов</em></p><br>
   <p>С помощью тега <code>link</code> могут загружаться не только стили, но и другие ресурсы, используемые на странице, например, изображения:</p><br>
   <pre><code class="css">/* app/components/copy-to-clipboard/style.css */
.copy-to-clipboard {
  background: url("/icons/clipboard.svg");
}</code></pre><br>
   <pre><code class="javascript">// app/components/copy-to-clipboard/index.jsx
import styles from "./styles.css";

export const links = () =&gt; [
  {
    rel: "preload",
    href: "/icons/clipboard.svg",
    as: "image",
    type: "image/svg+xml",
  },
  { rel: "stylesheet", href: styles },
];

export const CopyToClipboard = React.forwardRef(
  ({ children, ...props }, ref) =&gt; {
    return (
      &lt;Button {...props} ref={ref} className="copy-to-clipboard" /&gt;
    );
  }
);
CopyToClipboard.displayName = "CopyToClipboard";</code></pre><br>
   <p><em>Медиа-запросы</em></p><br>
   <p>Атрибут <code>media</code> позволяет загружать определенные стили на основе ширины экрана пользователя и т.п.:</p><br>
   <pre><code class="javascript">export function links() {
  return [
    {
      rel: "stylesheet",
      href: mainStyles,
    },
    {
      rel: "stylesheet",
      href: largeStyles,
      media: "(min-width: 1024px)",
    },
    {
      rel: "stylesheet",
      href: xlStyles,
      media: "(min-width: 1280px)",
    },
    {
      rel: "stylesheet",
      href: darkStyles,
      media: "(prefers-color-scheme: dark)",
    },
  ];
}</code></pre><br>
   <h3 id="tailwindcss">TailwindCSS</h3><br>
   <p>Устанавливаем зависимости:</p><br>
   <pre><code class="bash">npm i -D npm-run-all tailwindcss</code></pre><br>
   <p>Инициализируем <a href="https://tailwindcss.com/">Tailwind</a>:</p><br>
   <pre><code class="bash">npx tailwindcss init</code></pre><br>
   <p>Редактируем <code>tailwind.config.js</code>:</p><br>
   <pre><code class="javascript">/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./app/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};</code></pre><br>
   <p>Обновляем раздел <code>scripts</code> в файле <code>package.json</code>:</p><br>
   <pre><code class="json">{
  "scripts": {
    "build": "run-s \"build:*\"",
    "build:css": "npm run generate:css -- --minify",
    "build:remix": "remix build",
    "dev": "run-p \"dev:*\"",
    "dev:css": "npm run generate:css -- --watch",
    "dev:remix": "remix dev",
    "generate:css": "npx tailwindcss -o ./app/tailwind.css",
    "start": "remix-serve build"
  }
}</code></pre><br>
   <p>Импортируем генерируемый файл CSS в приложение:</p><br>
   <pre><code class="javascript">// app/root.tsx
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import styles from "./tailwind.css";

export const links: LinksFunction = () =&gt; [
  { rel: "stylesheet", href: styles },
];</code></pre><br>
   <p>Для кастомизации стилей Tailwind с помощью директивы <code>@apply</code> необходимо создать CSS-файл в корневой директории, например, <code>styles/tailwind.css</code>:</p><br>
   <pre><code class="css">@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .custom-class {
    @apply ...;
  }
}</code></pre><br>
   <p>И отредактировать команду <code>generate:css</code> в <code>package.json</code>:</p><br>
   <pre><code class="json">"generate:css": "npx tailwindcss -i ./styles/tailwind.css -o ./app/tailwind.css"</code></pre><br>
   <p>Рекомендуется добавить генерируемый файл в <code>.gitignore</code>:</p><br>
   <pre><code class="plaintext">node_modules

/.cache
/build
/public/build
.env

/app/tailwind.css</code></pre><br>
   <h3 id="postcss">PostCSS</h3><br>
   <p>Устанавливаем зависимости:</p><br>
   <pre><code class="bash">npm i -D postcss-cli postcss autoprefixer</code></pre><br>
   <p>Создаем файл <code>postcss.config.js</code> в корневой директории:</p><br>
   <pre><code class="javascript">module.exports = {
  plugins: {
    autoprefixer: {},
  },
};</code></pre><br>
   <p>Создаем CSS-файл в корневой директории, например, <code>styles/app.css</code>.</p><br>
   <p>Добавляем скрипты в <code>package.json</code>:</p><br>
   <pre><code class="json">"dev:css": "postcss styles --base styles --dir app/styles -w",
"build:css": "postcss styles --base styles --dir app/styles --env production"</code></pre><br>
   <p>Данные команды преобразуют файлы из директории <code>styles</code> и помещают их в директорию <code>app/styles</code>.</p><br>
   <p>Импортируем генерируемый файл в <code>app/root.tsx</code>:</p><br>
   <pre><code class="javascript">import type { LinksFunction } from "@remix-run/node";

import styles from "./styles/app.css";

export const links: LinksFunction = () =&gt; {
  return [{ rel: "stylesheet", href: styles }];
};</code></pre><br>
   <p>Для запуска <a href="https://postcss.org/">PostCSS</a> и Remix одной командой можно использовать npm-пакет <a href="https://www.npmjs.com/package/concurrently">concurrently</a>:</p><br>
   <pre><code class="bash">npm i -D concurrently</code></pre><br>
   <pre><code class="json">"scripts": {
  "dev": "concurrently \"npm run dev:css\" \"remix dev\""
}</code></pre><br>
   <h3 id="sass">SASS</h3><br>
   <p>Устанавливаем <a href="https://sass-lang.com/">SASS</a>:</p><br>
   <pre><code class="bash">npm i -D sass</code></pre><br>
   <p>Добавляем скрипт в <code>package.json</code>:</p><br>
   <pre><code class="json">"sass": "sass --watch app/:app/"</code></pre><br>
   <p>Предполагается, что файлы SASS находятся в директории <code>app</code>. Флаг <code>--watch</code> означает наблюдение за добавлением, удалением и модификацией файлов.</p><br>
   <p>Команда для одновременного запуска SASS и Remix:</p><br>
   <pre><code class="json">"dev": "concurrently \"npm run sass\" \"remix dev\""</code></pre><br>
   <h2 id="a-idtsa-typescript">TypeScript</h2><br>
   <p>Remix поддерживает JS и TS из коробки, но компилятор Remix не выполняет проверку типов (он просто их удаляет). Однако для проверки типов достаточно добавить в <code>package.json</code> такой скрипт:</p><br>
   <pre><code class="json">"typecheck": "tsc -b"</code></pre><br>
   <p>Определения типов TS также встроены в Remix. При использовании начального шаблона создается файл <code>remix.env.d.ts</code>:</p><br>
   <pre><code class="javascript">/// &lt;reference types="@remix-run/dev" /&gt;
/// &lt;reference types="@remix-run/node" /&gt;</code></pre><br>
   <p>Ссылка на этот файл содержится в <code>tsconfig.json</code>:</p><br>
   <pre><code class="json">"include": ["remix.env.d.ts", "**/*.ts", "**/*.tsx"]</code></pre><br>
   <p>Это конец первой части руководства.</p><br>
   <p>Благодарю за внимание и happy coding!</p><br>
   <hr><br>
   <p><a href="https://timeweb.cloud/?utm_source=habr&amp;utm_medium=banner&amp;utm_campaign=vds-promo-6-rub"><img src="https://habrastorage.org/r/w1560/webt/p-/u9/l2/p-u9l27ynelxi92bcmdxhu76ma8.png" data-src="https://habrastorage.org/webt/p-/u9/l2/p-u9l27ynelxi92bcmdxhu76ma8.png"></a></p>
  </div>
 </div>
</div> <!----> <!---->