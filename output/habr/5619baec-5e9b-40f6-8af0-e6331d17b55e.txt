<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Здравствуйте, меня зовут Дмитрий Карловский. А&nbsp;вы на&nbsp;канале <a href="https://www.youtube.com/@core__dump" rel="noopener noreferrer nofollow">Core Dump</a>, где мы берём различные темы из&nbsp;компьютерной науки и без&nbsp;лишней зауми раскладываем их по&nbsp;полочкам.</p>
   <div class="tm-iframe_temp" data-src="https://embedd.srv.habr.com/iframe/63ee4afbb824706ff774628f" data-style="" id="63ee4afbb824706ff774628f" width=""></div>
   <h2>Принцип открытости/закрытости</h2>
   <p>В&nbsp;далёком 1988&nbsp;году Бертран Мейер сформулировал свой принцип написания кода долгоживущих проектов под&nbsp;названием «Принцип открытости/закрытости» или&nbsp;OCP.</p>
   <blockquote>
    <p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8/%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8" rel="noopener noreferrer nofollow">Open‑Closed Principle</a></p>
   </blockquote>
   <p>Вкратце, он звучит так: «программные сущности должны&nbsp;быть открыты для&nbsp;расширения, но&nbsp;закрыты для&nbsp;изменения». И, как&nbsp;любой короткий принцип, он требует десятки статей для&nbsp;толкования. Но&nbsp;к&nbsp;чёрту всю воду, включаем нашу соковыжималку!</p>
   <h2>Виды сущностей</h2>
   <p>Принцип OCP может&nbsp;быть применён к&nbsp;разным типам сущностей, описываемых нашим кодом..</p>
   <ul>
    <li><p>Функции</p></li>
    <li><p>Объекты</p></li>
    <li><p>Классы</p></li>
    <li><p>Интерфейсы</p></li>
    <li><p>Модули</p></li>
    <li><p>Пакеты</p></li>
   </ul>
   <p>По&nbsp;мере развития проекта, требования к&nbsp;нему меняются, обнаруживаются дефекты, придумываются улучшения. Короче, появляется необходимость внесения изменений.</p>
   <h2>Суть OCP</h2>
   <p>Простыми словами OCP можно объяснить так: Работает? Не&nbsp;трогай! Создай новую сущность. Ну ладно, баги чинить можно. Но&nbsp;не&nbsp;более!</p>
   <blockquote>
    <p>Копипаст лучше рефакторинга!</p>
   </blockquote>
   <p>При&nbsp;этом, Бертран Мейер допускал использование наследования для&nbsp;снижения копипаста, но&nbsp;это неизбежно приводит к&nbsp;сложным и порой абсурдным иерархиям классов. А&nbsp;вот популяризировавший OCP Роберт Мартин уже предлагает выделять абстракции заранее так, чтобы наследование реализации нам не&nbsp;требовалось. Ретроспективно это сделать, конечно, легко, но&nbsp;чтобы заранее ввести все абстракции на&nbsp;будущее, нужно выдающееся чутьё, если не&nbsp;сказать большего.</p>
   <h2>Путаница с расширениями</h2>
   <p>Стоит отдельно подчеркнуть неоднозначность формулировки. Может показаться, что&nbsp;обе половины принципа говорят об&nbsp;одном и том&nbsp;же предмете. Однако, подразумевают они на&nbsp;самом деле разные. Термин <em>изменение</em> относится к&nbsp;отдельной сущности&nbsp;— её нельзя <em>менять</em>. А&nbsp;вот термин <em>расширение</em> относится уже ко всему множеству сущностей&nbsp;— его можно&nbsp;лишь <em>расширять</em> добавлением новых сущностей.</p>
   <p></p>
   <figure class="">
    <img src="https://habrastorage.org/r/w1560/webt/2w/9n/dn/2w9ndneeaveog6chuxtrxh-_hk8.png" width="auto" height="auto" data-src="https://habrastorage.org/webt/2w/9n/dn/2w9ndneeaveog6chuxtrxh-_hk8.png">
    <figcaption></figcaption>
   </figure>
   <p>Пунктиром на&nbsp;диаграмме обозначены реализации которые тем или&nbsp;иным способом могут&nbsp;быть унаследованы. Но&nbsp;это возможно далеко не&nbsp;всегда.</p>
   <h2>Иерархия типов сущностей</h2>
   <p>И тут у&nbsp;нас начинаются скользкие вопросы. Возьмём, такую сущность как&nbsp;функция. Добавить в&nbsp;неё новый параметр в&nbsp;соответствии с&nbsp;принципом OCP нельзя, а&nbsp;надо создать новую функцию. Но&nbsp;если эта функция не&nbsp;в&nbsp;воздухе висит, а&nbsp;объявлена в&nbsp;рамках такой сущности как&nbsp;класс, то его тоже менять нельзя, и надо создать новый класс. А&nbsp;класс лежит в&nbsp;неймспейсе, который находится в&nbsp;модуле, который собирается в&nbsp;пакет. А&nbsp;пакет в&nbsp;яйце, яйцо в&nbsp;утке, утка в&nbsp;зайце, заец в&nbsp;шоке.</p>
   <p></p>
   <figure class="">
    <img src="https://habrastorage.org/r/w1560/webt/yv/_k/d-/yv_kd-ggyrcawz8tru45qmutwtw.png" width="auto" height="auto" data-src="https://habrastorage.org/webt/yv/_k/d-/yv_kd-ggyrcawz8tru45qmutwtw.png">
    <figcaption></figcaption>
   </figure>
   <p>Как&nbsp;далеко мы зайдём в&nbsp;этом расширении, стараясь ничего не&nbsp;менять?</p>
   <h2>Изменения - опасны?</h2>
   <p>Если мы изменим уже существующую, отлаженную, используемую кем‑то сущность, то можем намеренно или&nbsp;случайно внести в&nbsp;неё несовместимые изменения. Это может привести к&nbsp;некорректной работе зависящих от&nbsp;изменённой сущностей, падению сборки проекта, необходимости каскадного внесения изменений в&nbsp;косвенно зависящие сущности, в&nbsp;том числе и во&nbsp;внешние потребители, доступа к&nbsp;которым у&nbsp;нас может и не&nbsp;быть.</p>
   <blockquote>
    <p>❌ Ошибки в поведении</p>
    <p>❌ Ошибки при сборке</p>
    <p>❌ Несовместимость контрактов</p>
   </blockquote>
   <p>Проблема&nbsp;ли это? Если в&nbsp;проекте не&nbsp;используется тестирование, статическая типизация и прочие практики контроля качества, то любое изменение&nbsp;— это мина, на&nbsp;которую мы прыгаем, с&nbsp;разбега, рыбкой. Внесение изменения&nbsp;— 5&nbsp;минут, отладка его&nbsp;— 5&nbsp;дней. Во&nbsp;времена Мейера это&nbsp;была проблема огого!</p>
   <h2>Изменения - не опасны!</h2>
   <p>Однако, совсем другое дело, когда у&nbsp;нас есть современные практики контроля качества. Тогда мы не&nbsp;боимся вносить любые изменения, ведь уверены, что&nbsp;обо&nbsp;всех несовместимостях и дефектах мы довольно&nbsp;быстро узнаем благодаря автоматизированным инструментам: автотесты, авторефакторинги, автомиграции, тайпчекеры,&nbsp;линтеры, непрерывная интеграция и тд.</p>
   <blockquote>
    <p>✅ Тесты</p>
    <p>✅ Миграции</p>
    <p>✅ Статический анализ</p>
    <p>✅ Непрерывная интеграция</p>
   </blockquote>
   <p>Получается, что&nbsp;серьёзные проблемы у&nbsp;нас могут&nbsp;быть с&nbsp;изменением&nbsp;лишь тех сущностей, на&nbsp;которые завязаны внешние потребители, для&nbsp;которых нам необходимо сохранять обратную совместимость.</p>
   <h2>Отсутствие изменений - опасно!</h2>
   <p>А&nbsp;вот для&nbsp;внутренних, контролируемых нами, потребителей проблемы возникают, наоборот, если код не&nbsp;менять, ведь мы плодим горы похожего, но&nbsp;отличающегося в&nbsp;мелочах, кода. Его нужно поддерживать. Он потребляет больше тех или&nbsp;иных ресурсов. Короче, если в&nbsp;коде не&nbsp;прибираться, то он очень&nbsp;быстро тухнет.</p>
   <p>А&nbsp;самое печальное, что&nbsp;существующие закрытые к&nbsp;изменению сущности, зачастую оказываются несоответствующими актуальным требованиям. Так что&nbsp;их использование становится мало того, что&nbsp;бессмысленным или&nbsp;нежелательным, так ещё и откровенно вредным.</p>
   <p>Например, если раньше обращение к&nbsp;сущности не&nbsp;требовало авторизации, а&nbsp;потом вы решили, что&nbsp;авторизация таки нужна. Оставлять возможность работать без&nbsp;авторизации&nbsp;было&nbsp;бы очень опрометчиво. Это всё равно, что&nbsp;раскладывать грабли рядом с&nbsp;кроватью: с&nbsp;какой&nbsp;бы ноги ни встал с&nbsp;утра&nbsp;— весь день будешь потирать лобные извилины. Поэтому порой обратная совместимость должна&nbsp;быть сломана. И это нормально.</p>
   <blockquote>
    <p>❌ Раздутие множества сущностей</p>
    <p>❌ Поддержка разных реализаций одной задачи</p>
    <p>❌ Несовместимость с бизнес требованиями</p>
   </blockquote>
   <h2>Проектирование по OCP</h2>
   <p>Стигматизация изменений приводит к&nbsp;специфическому влиянию на&nbsp;архитектуру. Вместо того, чтобы написать простой наивный код, легко понимаемый любым разработчиком, приходится городить кучу абстракций на&nbsp;всякий случай, чтобы потом можно&nbsp;было <em>изменить</em> поведение, не&nbsp;меняя кода, а&nbsp;только дописывая новый.</p>
   <blockquote>
    <p>✅ Гибкость и расширяемость</p>
    <p>❌ Преждевременное усложнение</p>
   </blockquote>
   <p>А&nbsp;так как&nbsp;программисты не&nbsp;славятся умением предвидеть будущее, то неизбежно одни точки расширения окажутся невостребованными, а&nbsp;других наоборот будет не&nbsp;хватать, что&nbsp;таки приведёт к&nbsp;вынужденному <em>изменению</em> кода.</p>
   <h2>Правильный OCP</h2>
   <p>Что&nbsp;ж, давайте попробуем выцепить рациональное зерно из&nbsp;OCP, и <em>изменим</em> его так, чтобы пользы он приносил больше, чем вреда. Итак..</p>
   <blockquote>
    <p>Не&nbsp;ломай публичный контракт без&nbsp;необходимости!</p>
   </blockquote>
   <p>В&nbsp;отличие от&nbsp;предыдущей, наша формулировка OCP мало того, что&nbsp;разрешает обратно совместимые изменения сущностей, так ещё и не&nbsp;столь строга касательно ломающих изменений.</p>
   <p>В&nbsp;своей песочнице ты&nbsp;— царь и бог. Но&nbsp;создавая публичный контракт, важно думать не&nbsp;только о&nbsp;том, как&nbsp;им будут пользоваться, но&nbsp;и о&nbsp;том, как&nbsp;ты сам в&nbsp;дальнейшем будешь развивать проект, сохраняя обратную совместимость. А&nbsp;если уж придётся её ломать, то следует предоставь как&nbsp;минимум средства автоматического выявления несовместимостей, а&nbsp;как&nbsp;максимум&nbsp;— средства автоматического их разрешения.</p>
   <h2>Следовать ли OCP?</h2>
   <p>Как&nbsp;было показано ранее, в&nbsp;современных условиях следование OCP скорее вредно, чем полезно. Оно требует от&nbsp;программиста&nbsp;быть провидцем, иначе наказывает его протуханием кодовой базы. Поэтому требуется, если не&nbsp;полное отвержение, то хотя&nbsp;бы пересмотр принципа с&nbsp;использованием менее жёстких ограничений, разрешающих нам поддерживать проект в&nbsp;тонусе регулярными рефакторингами.</p>
   <blockquote>
    <p>❌ OCP</p>
    <p>✅ Обратная совместимость</p>
   </blockquote>
   <h2>Что ещё почитать про OCP?</h2>
   <p>В&nbsp;качестве десерта предлагаю вам статью Даниэля Норта, с&nbsp;критическим разбором принципов SOLID и OCP в&nbsp;частности, в&nbsp;противовес которому он вводит свой <em>Принцип Снежного Кома</em>, по&nbsp;которому любой ваш код рассматривается не&nbsp;как&nbsp;что‑то самоценное, а&nbsp;как&nbsp;постоянные затраты, которые всё множатся и преумножаются. Так что&nbsp;если есть возможность изменить код так, чтобы он стал проще, то именно так и стоит поступить. И чем раньше, тем лучше.</p>
   <blockquote>
    <p><a href="https://web.archive.org/web/20210320115030/https://habr.com/ru/post/548066/" rel="noopener noreferrer nofollow">История возникновения CUPID</a> / Daniel Terhorst-North</p>
   </blockquote>
   <h2>Продолжение следует..</h2>
   <p>Если данный разбор показался вам полезным, то дайте мне об&nbsp;этом знать посредством лайка или&nbsp;даже доната. А&nbsp;так&nbsp;же поделитесь ссылкой на&nbsp;него со своими коллегами. Особенно с&nbsp;теми, кто городит огород вокруг OCP.</p>
   <p>Если&nbsp;же вы не&nbsp;согласны с&nbsp;каким‑либо тезисом или, наоборот, чувствуете некую недосказанность, и хотите дополнить своими идеями или&nbsp;иными материалами по&nbsp;теме, то жду ваших комментариев.</p>
   <p>Наконец, подписывайтесь на&nbsp;канал, чтобы не&nbsp;пропустить дальнейшие разборы. Нам ещё много чего с&nbsp;вами нужно будет обсудить.</p>
   <blockquote>
    <p><a href="https://youtu.be/mD9uNzM1FA4" rel="noopener noreferrer nofollow">Лайки</a></p>
    <p><a href="https://boosty.to/hyoo" rel="noopener noreferrer nofollow">Поддержка</a></p>
    <p><a href="https://t.me/core_dump_chat" rel="noopener noreferrer nofollow">Комментарии</a></p>
    <p><a href="https://t.me/core_dump_channel" rel="noopener noreferrer nofollow">Подписка</a></p>
   </blockquote>
   <p>На&nbsp;этом пока что&nbsp;всё. С&nbsp;вами&nbsp;был открытый к&nbsp;расширению программер Дмитрий Карловский.</p>
   <p><a href="https://page.hyoo.ru/#!=qk8sq7_c388qt" rel="noopener noreferrer nofollow">Актуальный оригинал на $hyoo_page.</a></p>
   <figure class="">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/4b2/37b/84b/4b237b84b85c6b0dd7a0fdcfc528eb5f.png" width="409" height="569" data-src="https://habrastorage.org/getpro/habr/upload_files/4b2/37b/84b/4b237b84b85c6b0dd7a0fdcfc528eb5f.png">
    <figcaption></figcaption>
   </figure>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->