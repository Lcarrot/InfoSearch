<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <p>Ещё в мае 2022 года я переориентировал пару команд в Google на разработку полностью гомоморфного шифрования (<a href="https://buttondown.email/j2kun/archive/career-update-homomorphic-encryption/" rel="noopener noreferrer nofollow">вот объявление об этом в рассылке</a>). С тех пор я участвовал в работе над многими проектами в этой области, в частности, руководил поддержкой на <a href="http://github.com/google/fully-homomorphic-encryption" rel="noopener noreferrer nofollow">github.com/google/fully-homomorphic-encryption</a> – это опенсорсный ПГШ-компилятор для C++. В этой статье даётся вводная информация о том, как при помощи этого инструмента компилировать программы с расчётом на ПГШ. Также пробежимся по тому, из чего этот компилятор состоит.</p>
   <p>Если вы хотели бы поучаствовать в этом проекте, пожалуйста, напишите мне на <a href="mailto:mathintersectprogramming@gmail.com" rel="noopener noreferrer nofollow">mathintersectprogramming@gmail.com</a>&nbsp;или&nbsp;<a href="https://mathstodon.xyz/@j2kun" rel="noopener noreferrer nofollow">j2kun@mathstodon.xyz</a>. Мне придётся решить несколько бюрократических вопросов, чтобы можно было принимать вклад от сторонних разработчиков (должным образом ссылаясь на разработчиков в git-коммитах), но, при наличии достаточного интереса с вашей стороны я постараюсь управиться с этим, не откладывая.</p>
   <h2>Обзор</h2>
   <p>Ключевая идея в основе полностью гомоморфного шифрования (далее — ПГШ) заключается в том, что можно зашифровать данные, а затем гонять на них программы, даже не расшифровывая самих данных. Если довести такую ситуацию до крайности, то можно сказать, что обладай кто-либо физическим доступом к машине и, следовательно, возможностью проверить значения у неё в отдельных ячейках памяти в ходе выполнения программы, он всё равно не увидел бы ни малейшей информации об обрабатываемых данных (если бы не взломал криптосистему).</p>
   <p>Наш ПГШ-компилятор преобразует программы C++, работающие с обычным текстом, в программы, работающие с соответствующими ПГШ-шифротекстами (поскольку выдаёт высокоуровневый код, затем подлежащий дальнейшей компиляции. Следовательно, этот инструмент можно охарактеризовать как <em>транспилятор</em>). Если конкретнее, транспилятор преобразует конкретное <em>подмножество</em>&nbsp;правильных программ на C++ — подробнее о том, как определяется это подмножество, мы поговорим ниже — в программы, решающие те же задачи на зашифрованных данных посредством одной из поддерживаемых реализаций ПГШ-криптосистем. В данном смысле они близки к традиционному компилятору: разбирают ввод, прогоняют несколько этапов оптимизации, генерируют некоторый вывод. Правда, как будет показано в этой статье, благодаря уникальным свойствам ПГШ этот компилятор сближается по свойствам с инструментариями для операций над аппаратными схемами.</p>
   <p>Разнообразные варианты ПГШ, ныне поддерживаемые компилятором, называются «предзагрузкой вентилей» (gate bootstrapping). Мне не хватило бы времени детально разобрать здесь математику, лежащую в основе этого процесса — достаточно сказать, что такая технология позволяет пожертвовать производительностью, зато решает более простую задачу: выполняет оптимизацию и выдаёт работающую программу. А далее я скажу, что такая смесь ПГШ позволяет зашифровать <em>каждый бит</em> входной информации, превращая ввод в отдельный шифротекст. Затем программа представляется в виде логических (комбинационных) схем, состоящих из таких вентилей как AND (И), OR (ИЛИ), XNOR (исключающее ИЛИ), т.д.&nbsp; Одно из достоинств компилятора заключается в том, что он управляет отображением типов высшего порядка (например, целых чисел, массивов и структур) на списки зашифрованных булевых значений и обратно.</p>
   <p>Такой подход на основе схем приводит к некоторым ограничениям, которые пронизывают всю оставшуюся часть этого материала. Во-первых, все циклы должны быть полностью размотаны, и у них должны быть статически известные границы. Во-вторых, здесь не поддерживаются такие конструкции как указатели, а также динамическое выделение памяти. В-третьих, весь поток управления мультиплексируется; это значит, что вычисляются все ветвления всех операторов if, после чего выбирается только один вариант. Наконец, есть важные практические соображения, касающиеся используемой битовой ширины типов и расширения открытого текста до зашифрованного, что влияет на производительность результирующей программы.</p>
   <p>С другой стороны, оптимизация комбинационных схем – это хорошо изученная задача, для решения которой есть готовые продукты, поддающиеся интеграции (от автора: они что-то интегрировали) в ПГШ-компилятор. Так можно ускорить работу программ.</p>
   <h2>Зависимости</h2>
   <p><em>Если коротко:</em>&nbsp;почитайте&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/tree/main/docker" rel="noopener noreferrer nofollow">файлы docker</a>.</p>
   <p>В Google применяется внутренняя система сборки, именуемая&nbsp;blaze, а её опенсорсный аналог (полностью эквивалентный оригиналу за исключением названия) именуется bazel. Одна из первых любопытных вещей, которую можно отметить по поводу компилятора: bazel используется как для сборки, так и для <em>использования</em> проекта (второй аспект хотелось бы изменить). Так что вам потребуется установить bazel, а легче всего это сделать, <a href="https://bazel.build/install/bazelisk" rel="noopener noreferrer nofollow">установив&nbsp;bazelisk</a>, который аналогичен nvm&nbsp;для Node или&nbsp;pyenv&nbsp;для Python. Сразу много версий bazel вам не понадобится, но так легче всего установить новейшую версию. Я буду пользоваться Bazel 4.0.0, но есть и более свежие версии, которые также должны нормально работать.</p>
   <p>Вам понадобится компилятор C (я пользуюсь gcc12), поскольку большинство зависимостей в проекте построены на основе исходников (см. в следующем абзаце) и небольшого количества внешних библиотек и программ, обеспечивающих поддержку некоторых плагинов для оптимизации схем. Ниже приведён полный список для систем, основанных на debian.</p>
   <pre><code>apt-get update &amp;&amp; apt-get install -y \
  gcc \
  git \
  libtinfo5 \
  python \
  python3 \
  python3-pip \
  autoconf \
  libreadline-dev \
  flex \
  bison \
  wget</code></pre>
   <p>Как упоминалось выше, все остальные зависимости собираются&nbsp;<em>из исходного кода</em>, и при первой сборке проекта на эту работу требуется существенное время. Поэтому вы вполне можете клонировать и запустить эту сборку, прямо пока читаете статью. Приведённая ниже команда соберёт проект и все приводимые в качестве примера двоичные файлы, а затем кэширует промежуточные артефакты, чтобы можно было пользоваться ими в будущих сборках, просто перекомпилируя те элементы, которые могли измениться со времени последней сборки. В разделе о Bazel/Starlark подробнее рассказано о том, что делает эта команда.&nbsp;<strong>Замечание:&nbsp;</strong>особо странный случай – с LLVM. Если вы пользуетесь экзотической операционной системой (или контейнером docker, только позвольте мне не углубляться в объяснения, почему с этим есть проблема), то bazel может предпочесть собрать LLVM с нуля – в случае с первой сборкой на это может потребоваться час-два. Также он может отказать из-за того, что в вашей системе не хватает какой-то зависимости. Это особо тяжёлый случай (и жалоба №1 в случае со всеми проблемами, заводимыми у нас на GitHub). Но, если вы работаете на стандартной комбинации ОС/архитектура процессора (<a href="https://github.com/grailbio/bazel-toolchain/blob/08d1aa8cee67a7a9c51c09225cead1dad42dadc3/toolchain/internal/common.bzl" rel="noopener noreferrer nofollow">из тех, что перечислены здесь</a>), компилятор просто выберет нужную зависимость LLVM и установит её в вашей системе.</p>
   <pre><code>git clone https://github.com/google/fully-homomorphic-encryption.git
cd fully-homomorphic-encryption
bazel build ...:all</code></pre>
   <p>Чистая сборка на моём домашнем компьютере делается примерно за 16 минут.</p>
   <h2>Подробный разбор двух примеров: add и string_cap</h2>
   <p>В этом разделе я покажу два сквозных примера, в которых буду работать с компилятором как конечный пользователь. В первом примере рассмотрим донельзя простую программу, складывающую два 32-разрядных целых числа. Во втором примере будет программа, которая делает заглавным первый символ в каждом слове в строке, записанной в кодировке ASCII. Примеры уже лежат в репозитории в разделе&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/examples" rel="noopener noreferrer nofollow">transpiler/examples</a>, они называются&nbsp;<code>simple_sum</code>&nbsp;и&nbsp;<code>string_cap</code>.</p>
   <p>Обе эти программы представлены в виде компиляции единственной функции, которая является входной точкой для ПГШ-компонента программы. Также предоставляются API и библиотека для интеграции этой программы с более крупной.</p>
   <p>Начнём с&nbsp;simple_sum. Добавим заголовок и файл с исходным кодом как в любой стандартной программе на C++, но с одной дополнительной строкой, сообщающей компилятору, какую именно функцию нужно скомпилировать (а также какие функции внутри неё вызываются).</p>
   <pre><code class="cpp">// add.h
int add(int a, int b);
 
// add.cc
#include "add.h"
 
#pragma hls_top
int add(int a, int b) {
  return a + b;
}</code></pre>
   <p>Строка&nbsp;<code>#pragma hls_top</code>&nbsp;сообщает компилятору, какая функция является входной точкой. Кстати,&nbsp;hls&nbsp;здесь означает “<a href="https://en.wikipedia.org/wiki/High-level_synthesis" rel="noopener noreferrer nofollow">high level synthesis</a>” (высокоуровневый синтез), а сама инструкция компилятора взята из проекта <a href="https://github.com/google/xls" rel="noopener noreferrer nofollow">XLS</a>, используемого у нас в качестве парсера и первичного сборщика схем. Здесь <code>‘top’</code> означает просто «функция верхнего уровня».</p>
   <p>Затем в файле из того же каталога, именуемом BUILD&nbsp;(см. далее раздел о Bazel/Starlark, где даётся обзор системы сборки) создаётся цель для сборки, вызывающая ПГШ-компилятор. В данном случае в качестве бэкенда воспользуемся&nbsp;<a href="https://github.com/openfheorg/openfhe-development" rel="noopener noreferrer nofollow">OpenFHE</a>.</p>
   <pre><code class="cpp"># BUILD
# загружает ПГШ-компилятор в качестве расширения Bazel.
load("//transpiler:fhe.bzl", "fhe_cc_library")
 
fhe_cc_library(
  name = "add_fhe_lib",
  src = "add.cc",
  hdrs = ["add.h"],
  encryption = "openfhe",  # библиотека для криптосистемы бэкенда
  interpreter = True,      # используем динамическое планирование потоков
  optimizer = "yosys",     # оптимизатор логических схем
)</code></pre>
   <p>Полный набор опций для данного правила сборки (т.e., документация по главной входной точке компилятора) находится в&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/blob/f6b6fe3894e134827010524914d8993aa994ab08/transpiler/fhe.bzl#L585" rel="noopener noreferrer nofollow">docstring по макросу bazel</a>. Я выбрал те параметры, которые, на мой взгляд, позволяют добиться золотой середины между стабильностью и производительностью.</p>
   <p>Если выполните&nbsp;bazel build add_fhe_lib, то увидите, что сборка идёт – и на этом всё (подробнее см. в разделе «промежуточные файлы» о том, что здесь происходит за кулисами). Но, если вы что-либо неправильно введёте в файле сборки, то на этом месте компилятор споткнётся. Он генерирует заголовок и файл&nbsp;cc, содержащий тот же API, что и add, но с другими типами в качестве аргументов, а также дополнительные аргументы, требуемые на бэкенде библиотеки ПГШ.</p>
   <p>Далее нам потребуется главная процедура, использующая эту библиотеку. Поскольку бэкендом нам служит OpenFHE, здесь понадобится некоторая работа по конфигурации и первичное шифрование всех входных значений. Вот&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/codelab/add" rel="noopener noreferrer nofollow">полный код</a> с небольшими изменениями, внесёнными для публикации в блоге.</p>
   <pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;
 
#include "absl/strings/numbers.h"
#include "transpiler/codelab/add/add_fhe_lib.h"
#include "transpiler/data/openfhe_data.h"
 
constexpr auto kSecurityLevel = lbcrypto::MEDIUM;
 
int main(int argc, char** argv) {
  if (argc &lt; 3) {
    fprintf(stderr, "Usage: add_main [int] [int]\n\n");
    return 1;
  }
 
  int x, y;
  if(!absl::SimpleAtoi(argv[1], &amp;x)) {
    std::cout &lt;&lt; "Bad int " &lt;&lt; argv[1] &lt;&lt; std::endl;
    return 1;
  }
  if(!absl::SimpleAtoi(argv[2], &amp;y)) {
    std::cout &lt;&lt; "Bad int " &lt;&lt; argv[2] &lt;&lt; std::endl;
    return 1;
  }
  std::cout &lt;&lt; "Computing " &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; std::endl;
 
  // Настраиваем контекст бэкенда и ключи шифрования.
  auto context = lbcrypto::BinFHEContext();
  context.GenerateBinFHEContext(kSecurityLevel);
  auto sk = context.KeyGen();
  context.BTKeyGen(sk);
 
  OpenFhe&lt;int&gt; ciphertext_x = OpenFhe&lt;int&gt;::Encrypt(x, context, sk);
  OpenFhe&lt;int&gt; ciphertext_y = OpenFhe&lt;int&gt;::Encrypt(y, context, sk);
  OpenFhe&lt;int&gt; result(context);
  auto status = add(result, ciphertext_x, ciphertext_y, context);
  if(!status.ok()) {
    std::cout &lt;&lt; "FHE computation failed: " &lt;&lt; status &lt;&lt; std::endl;
    return 1;
  }
 
  std::cout &lt;&lt; "Result: " &lt;&lt; result.Decrypt(sk) &lt;&lt; "\n";
  return 0;
}</code></pre>
   <p>Вот что происходит в тех частях, которые не являются явно шаблонным кодом:</p>
   <p>Конфигурирование уровня безопасности библиотеки OpenFHE (он называется BinFHE, подсказывая, что выполняет полное гомоморфное шифрование двоичных схем).</p>
   <pre><code>constexpr auto kSecurityLevel = lbcrypto::MEDIUM;</code></pre>
   <p>Настройка первичного секретного ключа OpenFHE</p>
   <pre><code>auto context = lbcrypto::BinFHEContext();
context.GenerateBinFHEContext(kSecurityLevel);
auto sk = context.KeyGen();
context.BTKeyGen(sk);</code></pre>
   <p>Шифрование входных значений. Здесь используется API, предоставляемый компилятором (хотя, поскольку весь проект представляет собой исследовательский прототип, мне кажется, что его авторы так и не принялись за унификацию части, отвечающей за «настройку первичного секретного ключа» за API) и включаемый сюда из&nbsp;<code>include "transpiler/data/openfhe_data.h"</code></p>
   <pre><code class="cpp">OpenFhe&lt;int&gt; ciphertext_x = OpenFhe&lt;int&gt;::Encrypt(x, context, sk);
OpenFhe&lt;int&gt; ciphertext_y = OpenFhe&lt;int&gt;::Encrypt(y, context, sk)</code></pre>
   <p>Затем вызываем функцию <code>add</code>&nbsp;с активированным ПГШ и дешифруем результаты.</p>
   <p>Далее создаём ещё одно правило&nbsp;BUILD для двоичного файла:</p>
   <pre><code class="cpp">cc_binary(
    name = "add_openfhe_fhe_demo",
    srcs = [
        "add_openfhe_fhe_demo.cc",
    ],
    deps = [
        ":add_fhe_lib",
        "//transpiler/data:openfhe_data",
        "@com_google_absl//absl/strings",
        "@openfhe//:binfhe",
    ],
)</code></pre>
   <p>Запускаем код при помощи bazel:</p>
   <pre><code>$ bazel run add_openfhe_fhe_demo -- 5 7
Computing 5 + 7
Result: 12</code></pre>
   <p>На моей системе на это потребовалось менее 7 секунд.</p>
   <p>Рассмотрим более сложный пример&nbsp;string_cap, где во всей красе предстают циклы и массивы. Это слегка упрощённая версия примера,&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/examples/string_cap" rel="noopener noreferrer nofollow">выложенного на GitHub</a>. Начнём с заголовка и файла с исходным кодом:</p>
   <pre><code class="cpp">// string_cap.h
#define MAX_LENGTH 32
void CapitalizeString(char my_string[MAX_LENGTH]);
 
// string_cap.cc
#include "string_cap.h"
 
#pragma hls_top
void CapitalizeString(char my_string[MAX_LENGTH]) {
  bool last_was_space = true;
#pragma hls_unroll yes
  for (int i = 0; i &lt; MAX_LENGTH; i++) {
    char c = my_string[i];
    if (last_was_space &amp;&amp; c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
      my_string[i] = c - ('a' - 'A');
    }
    last_was_space = (c == ' ');
  }
}</code></pre>
   <p>Вот теперь есть что обсудить. Начнём с того, что у этой строки статическая длина, известная во время компиляции. Это необходимо, поскольку программа ПГШ является логической схемой. Она определяет подключения для каждого из входных значений и должна знать, сколько таких подключений определять. В данном случае у нас будет схема с 32 * 8&nbsp;подключениями, по одному на каждый разряд каждого из символов в массиве.</p>
   <p>Вторая новинка здесь – это&nbsp;<code>#pragma hsl_unroll yes</code>, которая, как и&nbsp;<code>hls_top</code>, приказывает компилятору XLS полностью размотать этот цикл. Поскольку программа ПГШ – это статическая схема, никаких циклов в ней быть не может. XLS разматывает наши циклы за нас – и, кстати, я недавно узнал, что она использует решатель Z3, чтобы сначала&nbsp;<em>доказать</em>, что циклы могут быть размотаны (в сложных программах это может приводить к увеличению времени компиляции). Я не знаю никаких других компиляторах, в которых предусматривался бы такой этап доказательства. Складывается впечатление, что&nbsp;<a href="https://llvm.org/doxygen/LoopUnroll_8cpp_source.html#l00269" rel="noopener noreferrer nofollow">размотчик циклом LLVM</a>&nbsp;просто транжирит свои циклы ЦП, если поручить ему полностью размотать бесконечный цикл.</p>
   <p>Основная процедура похожа на ту, что мы рассмотрели ранее:</p>
   <pre><code class="cpp">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
 
#include "openfhe/binfhe/binfhecontext.h"
#include "transpiler/data/openfhe_data.h"
#include "transpiler/examples/string_cap/string_cap.h"
#include "transpiler/examples/string_cap/string_cap_openfhe_yosys_interpreted.h"
 
int main(int argc, char** argv) {
  if (argc &lt; 2) {
    fprintf(stderr, "Usage: string_cap_openfhe_testbench string_input\n\n");
    return 1;
  }
 
  std::string input = argv[1];
  input.resize(MAX_LENGTH, '\0');
  std::string plaintext(input);
 
  auto cc = lbcrypto::BinFHEContext();
  cc.GenerateBinFHEContext(lbcrypto::MEDIUM);
  auto sk = cc.KeyGen();
  cc.BTKeyGen(sk);
 
  auto ciphertext = OpenFheArray&lt;char&gt;::Encrypt(plaintext, cc, sk);
  auto status = CapitalizeString(ciphertext, cc);
  if (!status.ok()) {
    std::cout &lt;&lt; "FHE computation failed " &lt;&lt; status &lt;&lt; std::endl;
    return 1;
  };
  std::cout &lt;&lt; "Decrypted result: " &lt;&lt; ciphertext.Decrypt(sk) &lt;&lt; std::endl;
}</code></pre>
   <p>Вот ключевые отличия:</p>
   <ul>
    <li><p>Мы изменяем размер входной информации так, чтобы она точно равнялась&nbsp;<code>MAX_LENGTH</code>, заполняя пространство нулевыми байтами.</p></li>
    <li><p>Мы используем&nbsp;<code>OpenFheArray</code>, а не&nbsp;<code>OpenFhe</code>, чтобы закодировать массив символов.</p></li>
   </ul>
   <p>А теперь, пропустив&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/blob/main/transpiler/examples/string_cap/BUILD#L35" rel="noopener noreferrer nofollow">правило сборки</a>&nbsp;двоичного файла и запустив его, получим:</p>
   <pre><code>$ bazel run string_cap_openfhe_yosys_interpreted_testbench -- 'hello there'
Decrypted result: Hello There</code></pre>
   <p>Интересно, что на моей машине на это также уходит около 6 секунд (столько же, сколько и в случае с программой, складывающей 32-разрядные числа). Для более длинной строки (до 32 символов) получим такое же время выполнения, поскольку, естественно, программа обрабатывает все символы из <code>MAX_LENGTH</code>, не зная, являются ли они нулевыми байтами.</p>
   <h2>Обзор Bazel и Starlark</h2>
   <p>ПГШ-компилятор зародился в Google любопытным образом. Он был создан десятками участников-добровольцев (в те самые 20% рабочего времени, которые уделяются на сторонние проекты), и многие из них работали над инструментарием <a href="https://github.com/google/xls" rel="noopener noreferrer nofollow">XLS для аппаратного синтеза</a>, который является центральным компонентом этого компилятора. В силу таких ограничений, а также потому, что вся работа полностью велась в Google, не было особого поля для манёвра, которое позволило бы обеспечить независимость компилятора от внутреннего сборочного инструментария, используемого в Google.</p>
   <p>Здесь мы подходим к Bazel и Starlark, сегодня служащие фасадом этого компилятора, обращённым к пользователю. <a href="https://bazel.build/" rel="noopener noreferrer nofollow">Bazel</a>&nbsp;– это опенсорсный аналог внутрикорпоративной сборочной системы Google (внутренний инструмент называется “Blaze”), а&nbsp;<a href="https://bazel.build/rules/language" rel="noopener noreferrer nofollow">Starlark</a>&nbsp;– это язык сценариев, созданный по образцу Python. Есть <a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26" rel="noopener noreferrer nofollow">множество мнений</a>&nbsp;о Bazel, которые я не буду здесь повторять. Лучше сделаю минимальный обзор того, как он работает в контексте ПГШ-компилятора.</p>
   <p>Сначала немного терминологии. Чтобы приступить к работе с Bazel, нужно сделать следующее.</p>
   <ul>
    <li><p>Определить <a href="https://github.com/google/fully-homomorphic-encryption/blob/main/WORKSPACE" rel="noopener noreferrer nofollow">файл</a> WORKSPACE, в котором описаны все внешние зависимости вашего проекта, рассказано, как вытягивать их исходный код, и какие команды bazel должны использоваться для их сборки. Можно сравнить эту информацию с высокоуровневыми списками CMakeList, за тем исключением, что в этом файле не содержится никаких инструкций о сборке проекта – просто объявляется корень дерева каталогов этого проекта и указывается имя проекта.</p></li>
    <li><p>Определить набор файлов&nbsp;BUILD&nbsp;в каждом подкаталоге, указав здесь&nbsp;<em>целевые сборки</em>, которые могут быть сделаны из содержащихся в этом каталоге файлов с исходным кодом (но не из его подкаталогов). Всё точно, как с файлами CMakeLists в подкаталогах. Каждая цель для сборки может объявлять зависимости, связывающие её с другими целями для сборки, а bazel build&nbsp;гарантирует, что первым делом будут собираться именно зависимости, а также кэширует результаты сборки в пределах всего сеанса. В корне многих проектов лежит файл BUILD, это нужно для предоставления публичных библиотек и API данного проекта.</p></li>
    <li><p>Использовать встроенные <em>правила</em> bazel, например,&nbsp;<code>cc_library</code>,&nbsp;<code>cc_binary</code>&nbsp;и&nbsp;<code>cc_test</code>, чтобы сгруппировать файлы в библиотеки, поддающиеся сборке при помощи <code>bazel build</code>, исполняемые двоичные файлы, которые также можно выполнять при помощи &nbsp;<code>bazel run</code>, а также тесты, которые можно выполнять при помощи&nbsp;bazel test. Большинство правил bazel сводятся к вызову какой-либо исполняемой программы, например, gcc или&nbsp;javac&nbsp;с конкретными аргументами. Одновременно с этим отслеживается накапливающееся множество зависимостей, касающихся артефактов сборки, это делается в «герметичном» месте файловой системы.</p></li>
    <li><p>Написать любые дополнительные <em>макросы</em> bazel,&nbsp;сцепляющие встроенные команды bazel, например, чтобы определять локальные группирования сборочных команд, которые должны происходить в определённой последовательности. Эти макросы выглядят как функции на Python, вызывающие отдельные правила bazel и, возможно, передающие данные между ними. Они записываются в файлах&nbsp;.bzl, которые интерпретируются непосредственно самим bazel.</p></li>
   </ul>
   <p>Вообще сборка целей в&nbsp;bazel&nbsp;проходит в две фазы. Сначала идёт фаза анализа. На ней загружаются все файлы BUILD&nbsp;и импортированные файлы .bzl, а также просматриваются все правила, которые при этом вызывались. В частности, компилятор&nbsp;<em>выполняет</em>&nbsp;макросы, так как должен знать, какие правила через них вызываются (а выполнение правил можно подстраховывать на уровне потока управления, либо можно динамически генерировать их аргументы, т.д.). Но правила сборки как таковые он <em>не выполняет</em>. За этой работой компилятору удаётся построить полный граф зависимостей, сообщить об опечатках, недостающих зависимостях, циклах, т.д. По завершении фазы анализа компилятор выполняет базовые правила в том порядке, в котором идут зависимости, и кэширует результаты. Bazel вновь выполнит какое-либо правило только в случае, если что-либо изменится в базовых зависимостях или в тех файлах, от которых он зависит.</p>
   <p>Компилятор ПГШ написан на Starlark – в том смысле, что главной входной точкой компилятора является макрос Bazel <code>fhe_cc_library</code>. Этот макрос сцепляет ряд правил, которые вызывают парсер, оптимизатор схем и этапы генерации кода – для каждого из этих элементов предусмотрено своё правило Bazel. Каждое из этих правил по очереди объявляет или записывает файлы, которые мы можем проверить – об этом в следующем разделе.</p>
   <p>Вот как выглядит&nbsp;<code>fhecclibrary</code>&nbsp;(если коротко, это подмножество потока управления):</p>
   <pre><code class="python">def fhe_cc_library(name, src, hdrs, copts = [], num_opt_passes = 1,
        encryption = "openfhe", optimizer = "xls", interpreter = False, library_name = None,
        **kwargs):
    """Правило для сборки библиотек cc_libraries на основе ПГШ. [docstring пропущен]"""
    transpiled_xlscc_files = "{}.cc_to_xls_ir".format(name)
    library_name = library_name or name
    cc_to_xls_ir(
        name = transpiled_xlscc_files,
        library_name = library_name,
        src = src,
        hdrs = hdrs,
        defines = kwargs.get("defines", None),
    )
 
    # ниже мы добавляем ведущее двоеточие к аргументу `src`, тем самым указывая, 
    # где находятся файлы, сгенерированные по предыдущему правилу. При этом имя файла 
    # служит уникальным идентификатором.
    transpiled_structs_headers = "{}.xls_cc_transpiled_structs".format(name)
    xls_cc_transpiled_structs(
        name = transpiled_structs_headers,
        src = ":" + transpiled_xlscc_files,
        encryption = encryption,
    )
 
    if optimizer == "yosys":  # other branch omitted for brevity
        verilog = "{}.verilog".format(name)
        xls_ir_to_verilog(name = verilog, src = ":" + transpiled_xlscc_files)
        netlist = "{}.netlist".format(name)
        verilog_to_netlist(name = netlist, src = ":" + verilog, encryption = encryption)
        cc_fhe_netlist_library(
            name = name,
            src = ":" + netlist,
            encryption = encryption,
            interpreter = interpreter,
            transpiled_structs = ":" + transpiled_structs_headers,
            copts = copts,
            **kwargs
        )
</code></pre>
   <p>Среди правил, вызываемых макросом, есть следующие:</p>
   <ul>
    <li><p><code>cc_to_xls_ir</code>, вызывающее парсер&nbsp;xlscc&nbsp;и выдающее внутреннее представление программы в виде высокоуровневой схемы. На этом шаге выполняется размотка циклов и другие умные вещи, связанные с преобразованием кода C++ в схему.</p></li>
    <li><p><code>xlscc_transpiled_structs</code>, вызывающее двоичный файл, который обрабатывает структуры (эта часть сложная, её рассмотрение выходит за рамки данной статьи).</p></li>
    <li><p><code>xls_ir_to_verilog</code>, преобразующее внутреннее представление XLS IR в verilog, так, чтобы его можно было оптимизировать при помощи Yosys/ABC – популярной программы для проектирования и оптимизации схем.</p></li>
    <li><p><code>verilog_to_netlist</code>, вызывающее Yosys как для оптимизации схемы, так и для преобразования её в максимально низкоуровневое внутреннее представление, называемое&nbsp;<a href="https://en.wikipedia.org/wiki/Netlist" rel="noopener noreferrer nofollow">netlist</a>.</p></li>
    <li><p>cc_fhe_netlist_library, вызывающее этап генерации, чтобы сформировать код C++ из netlist, сделанного на предыдущем этапе.</p></li>
   </ul>
   <p>В результате всей этой работы получается библиотека на C++ (сгенерированная на предыдущем этапе), которую можно слинковать для работы с имеющейся программой, и исходный код которой (сгенерированный выше) можно проверить. Теперь давайте посмотрим, как выглядит каждый из сгенерированных файлов.</p>
   <h2>Промежуточные файлы, сгенерированные компилятором</h2>
   <p>Выше я упоминал, что промежуточные файлы, сгенерированные каждым правилом сборки, bazel кладёт в «герметичное» место в файловой системе. На это место ставится символьная ссылка из корня рабочего пространства, это делается при помощи&nbsp;<code>bazel-bin</code>.</p>
   <pre><code>$ ls -al . | grep bazel-bin
/home/j2kun/.cache/bazel/_bazel_j2kun/42987a3d4769c6105b2fa57d2291edc3/execroot/com_google_fully_homomorphic_encryption/bazel-out/k8-opt/bin</code></pre>
   <p>В&nbsp;bazel-bin&nbsp;содержится зеркало дерева исходников проекта, а в каталоге для правила сборки находятся все сгенерированные файлы. Вот как эта информация выглядит для нашего сумматора 32-разрядных чисел:</p>
   <pre><code>$ ls
_objs                                   add_test
add_fhe_lib.cc                          add_test-2.params
add_fhe_lib.entry                       add_test.runfiles
add_fhe_lib.generic.types.h             add_test.runfiles_manifest
add_fhe_lib.h                           libadd.a
add_fhe_lib.ir                          libadd.a-2.params
add_fhe_lib.netlist.v                   libadd.pic.a
add_fhe_lib.netlist.v.dot               libadd.pic.a-2.params
add_fhe_lib.opt.ir                      libadd.so
add_fhe_lib.types.h                     libadd.so-2.params
add_fhe_lib.v                           libadd_fhe_lib.a
add_fhe_lib.ys                          libadd_fhe_lib.a-2.params
add_fhe_lib_meta.proto                  libadd_fhe_lib.pic.a
add_openfhe_fhe_demo                    libadd_fhe_lib.pic.a-2.params
add_openfhe_fhe_demo-2.params           libadd_fhe_lib.so
add_openfhe_fhe_demo.runfiles           libadd_fhe_lib.so-2.params
add_openfhe_fhe_demo.runfiles_manifest</code></pre>
   <p>Виден вывод, это файлы&nbsp;<code>.h</code>&nbsp;и&nbsp;<code>.cc</code>, а также скомпилированные на их основе файлы&nbsp;<code>.so</code>&nbsp;(артефакты сборки вывода), но для нас важнее внутренние сгенерированные файлы. Именно здесь можно посмотреть, какими получились сгенерированные схемы.</p>
   <p>Первый файл, который лучше рассмотреть подробнее – это&nbsp;<code>add_fhe_lib.opt.ir</code>, представляющий собой вывод компилятора xlscc&nbsp;с включением XLS-внутреннего шага оптимизации. Именно здесь в основном изложено, как компилятор использует проект XLS: преобразует входную программу в схему. Файл выглядит так:</p>
   <pre><code>package my_package
 
file_number 1 "./transpiler/codelab/add/add.cc"
 
top fn add(x: bits[32], y: bits[32]) -&gt; bits[32] {
  ret add.3: bits[32] = add(x, y, id=3, pos=[(1,18,25)])
}</code></pre>
   <p>Как видите, это определённое в XLS внутреннее представление (IR) главной процедуры, снабжённое некоторыми дополнительными метаданными к исходному коду. Поскольку XLS-IR нативно поддерживает операции сложения, результат тривиален. Здесь интересно отметить, что числа представлены в виде битовых массивов. Если коротко,&nbsp;<a href="https://google.github.io/xls/ir_semantics/" rel="noopener noreferrer nofollow">система значимых типов</a>&nbsp;XLS-IR поддерживает только биты, массивы и кортежи, причём, кортежи здесь – это механизм для поддержки структур.</p>
   <p>Далее XLS-IR преобразуется в Verilog в&nbsp;<code>addfhelib.v</code>, и в результате даёт (тоже тривиальный) код:</p>
   <pre><code class="cpp">module add(
  input wire [31:0] x,
  input wire [31:0] y,
  output wire [31:0] out
);
  wire [31:0] add_6;
  assign add_6 = x + y;
  assign out = add_6;
endmodule</code></pre>
   <p>На следующем этапе нужно прогнать этот verilog через&nbsp;<a href="https://github.com/YosysHQ/yosys" rel="noopener noreferrer nofollow">Yosys</a>, это зрелый комплект для синтеза схем. В контексте нашего проекта Yosys решает две задачи:</p>
   <ul>
    <li><p>Преобразует высокоуровневые операции в заданный набор логических вентилей (оперирующих отдельными битами)</p></li>
    <li><p>Оптимизирует полученную в результате схему, так, чтобы её размер получился минимальным</p></li>
   </ul>
   <p>XLS также на это способен, и, если хотите в этом убедиться, можете заменить у сборочного правила <code>optimizer</code>&nbsp;атрибут&nbsp;<code>yosys</code>&nbsp;на&nbsp;<code>xls</code>. Но мы обнаружили, что у Yosys схемы, как правило, получаются в 2-3 раза меньше. Скрипт, который мы даём yosys, находится в файле <code>fhe_yosys.bzl</code>. В этом файле заключены макросы bazel и правила, касающиеся вызова Yosys. Вывод программы-сумматора получается таким:</p>
   <pre><code>module add(x, y, out);
  wire _000_;
  wire _001_;
  wire _002_;
  [...]
  wire _131_;
  wire _132_;
  output [31:0] out;
  wire [31:0] out;
  input [31:0] x;
  wire [31:0] x;
  input [31:0] y;
  wire [31:0] y;
  nand2 _133_ (.A(x[12]), .B(y[12]), .Y(_130_));
  xor2 _134_ ( .A(x[12]), .B(y[12]), .Y(_131_));
  nand2 _135_ ( .A(x[11]), .B(y[11]), .Y(_132_));
  or2 _136_ ( .A(x[11]), .B(y[11]), .Y(_000_));
  nand2 _137_ ( .A(x[10]), .B(y[10]), .Y(_001_));
  xor2 _138_ ( .A(x[10]), .B(y[10]), .Y(_002_));
  nand2 _139_ ( .A(x[9]), .B(y[9]), .Y(_003_));
  or2 _140_ ( .A(x[9]), .B(y[9]), .Y(_004_));
  nand2 _141_ ( .A(x[8]), .B(y[8]), .Y(_005_));
  xor2 _142_ ( .A(x[8]), .B(y[8]), .Y(_006_));
  nand2 _143_ ( .A(x[7]), .B(y[7]), .Y(_007_));
  or2 _144_ ( .A(x[7]), .B(y[7]), .Y(_008_));
  [...]
  xor2 _291_ ( .A(_006_), .B(_035_), .Y(out[8]));
  xnor2 _292_ ( .A(x[9]), .B(y[9]), .Y(_128_));
  xnor2 _293_ ( .A(_037_), .B(_128_), .Y(out[9]));
  xor2 _294_ ( .A(_002_), .B(_039_), .Y(out[10]));
  xnor2 _295_ ( .A(x[11]), .B(y[11]), .Y(_129_));
  xnor2 _296_ ( .A(_041_), .B(_129_), .Y(out[11]));
  xor2 _297_ ( .A(_131_), .B(_043_), .Y(out[12]));
endmodule</code></pre>
   <p>Получается схема, в которой всего 165 вентилей.</p>
   <p>Затем на этапе генерации кода производится файл&nbsp;<code>add_fhe_lib.cc</code>, загружающий схему в интерпретатор, а интерпретатор умеет отобразить операцию&nbsp;<code>and2</code>&nbsp;на выбранный библиотечный вызов бэкендовой криптосистемы (см.&nbsp;<a href="https://github.com/google/fully-homomorphic-encryption/blob/main/transpiler/yosys_openfhe_runner.cc" rel="noopener noreferrer nofollow">исходный код бэкенда OpenFHE</a>) и использует планирование пула потоков на ЦП, чтобы ускорить вычисление всей схемы.</p>
   <p>Что касается схемы string_cap, файл&nbsp;<a href="https://pastebin.com/raw/1friPEPh" rel="noopener noreferrer nofollow">opt.ir</a>&nbsp;демонстрирует более разнообразное внутреннее представление XLS, в том числе, операции по расширению знака, индексированию и срезу массивов, а также мультиплексированию веток (<code>sel</code>). В результате оптимизации получается <a href="https://pastebin.com/raw/DMhP941T" rel="noopener noreferrer nofollow">684-вентильная схема</a>&nbsp;(хотя, многие из этих вентилей являются «инвертирующими» или «буферные», а значит, обходятся для ПГШ фактически даром).</p>
   <p>Компилятор также выдаёт файл <code>.dot</code>, который можно отобразить <a href="https://github.com/j2kun/j2kun.github.io/blob/main/svg/string_cap_openfhe_yosys_interpreted.netlist.v.dot.svg" rel="noopener noreferrer nofollow">в формате SVG</a>&nbsp;(внимание, размер SVG ~2,3 МибиБ). Осмотрев схему, вы убедитесь, что она достаточно неглубокая и широкая, что позволяет планировщику потоков развернуться в этой схеме с параллелизмом, и в результате она станет быстро работать. Тем временем сумматор 32-разрядных чисел, пусть на него и приходится всего около 25% вентилей – схема гораздо более глубокая и, следовательно, параллелизма в нём меньше.</p>
   <h2>Поддерживаемые программы для ввода C++ и издержки на шифрование</h2>
   <p>Выше у нас была экскурсия по компилятору, но, если вы собираетесь писать программы при помощи этого компилятора, необходимо учитывать несколько вещей.</p>
   <p>Во-первых, поддерживаемое этим компилятором подмножество C++ довольно невелико. Как упоминалось выше, все данные должны иметь статические размеры. Таким образом, нельзя написать программу, которая обрабатывала бы произвольные изображения. Вместо этого придётся взять верхнюю границу размера изображения, в соответствии с этим заполнить изображение нулями и только потом шифровать, а затем написать программу, которая бы оперировала изображением именно такого размера. В том же ключе выбранные вами целочисленные типы нетривиальным образом повлияют на производительность. Чтобы в этом убедиться, замените тип <code>int</code>&nbsp;в 32-разрядном сумматоре на&nbsp;<code>char</code>&nbsp;и посмотрите, какая схема у вас получится.</p>
   <p>Аналогично, в циклах нужно предусмотреть статические ограничения на количество итераций. Точнее, xlscc&nbsp;должен быть в состоянии полностью размотать каждый цикл. Таким образом, допускаются некоторые формы циклов while и такая рекурсия, которая доказуемо завершается. Здесь возможны некоторые проблемы, если во вводимом коде содержатся циклы со сложными критериями выхода (например,&nbsp;<code>break</code> контролируется при помощи if/else). Также в таком случае нужно тщательно продумывать, как именно писать циклы, хотя, работа над компилятором продолжается, и возможно, что в будущем он возьмёт это продумывание на себя.</p>
   <p>Наконец, если шифровать каждый бит обычного текста, это серьёзно сказывается на использовании доступного пространства. Каждая операция по шифрованию отдельного бита соответствует списку примерно из 700 32-разрядных целых чисел. Если вы хотите зашифровать монохромное изображение размером 100×100 пикселей, каждый пиксель которого выражается 8-разрядным целым числом (0-255), вам понадобится&nbsp;<strong>218 МибиБ,</strong>&nbsp;чтобы сохранить все эти пиксели в памяти. Это примерно 20&nbsp;000-кратные издержки. Для сравнения, видеоклип на песню Рика Эстли “Never Gonna Give You Up” при качестве 360p занимает около 9 МибиБ (что довольно мало для трёхминутного видео!). Если же этот видеоклип будет зашифрован по ПГШ, то его размер составит <strong>188 ГибиБ</strong>, что (осторожная оценка) соответствует 20 полнометражным фильмам в качестве 1080p. В некоторых других схемах ПГШ предусмотрены меньшие размеры шифротекста, но это достигается за счёт ещё более высоких требований к оперативной памяти, в которой будут производиться вычисления. Поэтому, если вы собираетесь эксплуатировать программы для обработки видео – это осуществимо, но работу потребуется должным образом распределить, а также продумать, как максимально ужать данные перед шифрованием. Например, можно работать при низком разрешении, в тонах серого, с пониженной кадровой частотой. Все эти меры также в целом ускорят работу программ.</p>
   <p>До новых встреч!</p>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->