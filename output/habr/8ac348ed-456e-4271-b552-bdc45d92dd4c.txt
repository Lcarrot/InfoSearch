<div>
 <div class="article-formatted-body article-formatted-body article-formatted-body_version-2">
  <div xmlns="http://www.w3.org/1999/xhtml">
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/d70/3aa/769/d703aa769e6788c7c89e2d8db634ed4a.png" width="780" height="439" data-src="https://habrastorage.org/getpro/habr/upload_files/d70/3aa/769/d703aa769e6788c7c89e2d8db634ed4a.png">
    <figcaption></figcaption>
   </figure>
   <div class="persona" persona="true">
    <img persona="true" class="image persona__image" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/64b/caa/d8d/64bcaad8db168c682c3c5ecfb22b9497.jpg" data-src="https://habrastorage.org/getpro/habr/upload_files/64b/caa/d8d/64bcaad8db168c682c3c5ecfb22b9497.jpg" data-blurred="true">
    <h5 class="persona__heading" persona="true">Автор статьи: Рустем Галиев</h5>
    <p>IBM Senior DevOps Engineer &amp; Integration Architect</p>
   </div>
   <p>Привет, Хабр!<br><br>Репликация PostgreSQL с опережающей записью (WAL) — ключевая концепция в высоконагруженных архитектурах, поскольку она позволяет создавать высокодоступные и отказоустойчивые системы баз данных.</p>
   <h2>Что такое WAL?</h2>
   <p>В PostgreSQL как физическая, так и логическая репликация основана на ведении журнала с упреждающей записью (WAL).</p>
   <p>Все изменения, внесенные в PostgreSQL каждой транзакцией, сначала сохраняются в файле журнала, а затем результат транзакции отправляется инициирующему клиенту. Файлы данных не изменяются при каждой транзакции. Это стандартный механизм для предотвращения потери данных в случае сбоя ОС, сбоя оборудования, сбоя PostgreSQL и т. д. Этот механизм называется ведением журнала с упреждающей записью, а файл журнала — журналом с упреждающей записью (WAL). Каждое изменение, которое выполняет транзакция (INSERT, UPDATE, DELETE, COMMIT), записывается в журнал в виде записи WAL. Записи WAL сначала записываются в буфер WAL в памяти. При фиксации транзакции записи записываются в файл сегмента WAL на диске.</p>
   <p>Порядковый номер журнала (LSN — log sequence number) записи WAL представляет расположение/позицию, в которой она сохраняется в файле журнала. LSN используется как уникальный идентификатор записи WAL. Логически журнал транзакций представляет собой файл размером 2^64 байта. Таким образом, номер LSN представляет собой 64-битное число, представленное двумя 32-битными шестнадцатеричными числами, разделенными символом <code>/</code>.</p>
   <p>Например:</p>
   <p><code>SELECT pg_current_wal_lsn();</code><br><br>В случае сбоя системы база данных может восстановить совершенные транзакции из WAL. PostgreSQL начинает восстановление с последней точки REDO или контрольной точки.</p>
   <p>Контрольная точка — это точка в журнале транзакций, в которой все файлы данных были обновлены, чтобы отразить информацию в журнале. Процесс сохранения записей WAL из файла журнала в фактические файлы данных называется контрольной точкой.</p>
   <h2>WAL-сегменты</h2>
   <p><strong>Файлы сегментов WAL</strong></p>
   <p>Понимание того, что такое WAL и как управляются файлы сегментов WAL, является ключом к пониманию того, как выполняется репликация с помощью WAL. Понимание файлов сегментов WAL также является основой для понимания того, что такое слоты репликации и зачем они нужны. В PostgreSQL журнал транзакций представляет собой виртуальный файл размером 8 байт. Физически журнал разделен на файлы размером 16 МБ, каждый из которых называется сегментом WAL.</p>
   <p>Имя файла сегмента WAL представляет собой 24-значное число со следующим правилом именования:</p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/610/c30/9cc/610c309cc02e62509a55b6c1edba13f8.png" width="1600" height="180" data-src="https://habrastorage.org/getpro/habr/upload_files/610/c30/9cc/610c309cc02e62509a55b6c1edba13f8.png">
    <figcaption></figcaption>
   </figure>
   <p>Например:<br><br><code>SELECT pg_walfile_name(pg_current_wal_lsn());</code><br><br><strong>Управление файлами сегментов WAL</strong></p>
   <p>Файлы сегментов WAL хранятся в подкаталоге pg_wal. PostgreSQL переключается на новый файл сегмента WAL при следующих условиях:</p>
   <ul>
    <li><p>Сегмент WAL заполнен.</p></li>
    <li><p>Выпущена функция <code>pg_switch_wal</code>.</p></li>
    <li><p>Dключен режим <code>archive_mode</code> и превышено время, заданное для <code>archive_timeout</code>.</p></li>
   </ul>
   <p>Переключенные файлы WAL можно либо удалить, либо переработать, т. е. переименовать и повторно использовать в будущем. Количество файлов WAL, которые сервер будет хранить в любой момент времени, зависит от конфигурации сервера, а также от активности сервера.</p>
   <p>Всякий раз, когда запускается контрольная точка, PostgreSQL оценивает и подготавливает количество файлов сегментов WAL, необходимых для этого цикла контрольной точки. Эта оценка делается с учетом количества файлов, использованных в предыдущих циклах контрольных точек. Они отсчитываются от сегмента, содержащего предыдущую точку REDO, и значение должно быть между <code>min_wal_size</code> (по умолчанию 80 МБ, т. е. 5 файлов) и <code>max_wal_size</code> (1 ГБ, т. е. 64 файла). При запуске контрольной точки необходимые файлы будут сохранены и переработаны, а ненужные удалены.</p>
   <p>Конкретный пример показан на следующей диаграмме. Предполагая, что перед запуском контрольной точки есть 6 файлов, WAL_3 содержит точку REDO, и PostgreSQL оценивает, что необходимо 5 файлов. В этом случае <code>WAL_1</code> будет переименован в <code>WAL_7</code> для переработки, а <code>WAL_2</code> будет удален.<br><br></p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/aae/182/362/aae1823628126a56c7a14d1f21fcfd41.png" width="1600" height="914" data-src="https://habrastorage.org/getpro/habr/upload_files/aae/182/362/aae1823628126a56c7a14d1f21fcfd41.png">
    <figcaption></figcaption>
   </figure>
   <h2>Работа с примером WAL</h2>
   <p><strong>Использование </strong><code>pg_waldump</code></p>
   <p><code>pg_waldump</code> — это утилита, которую можно использовать для отображения записей WAL в удобочитаемой форме. В этой лабораторной работе мы будем использовать эту утилиту для отображения некоторых записей WAL.</p>
   <p>У утилиты <code>pg_waldump</code> две основные цели:</p>
   <ul>
    <li><p>Образовательная: для всех, кто пытается понять, как работает WAL в деталях.</p></li>
    <li><p>Отладка: для тех, кто пытается отлаживать средства репликации или резервного копирования на основе потоковой передачи WAL.</p></li>
   </ul>
   <p>Находим OID базы данных<br><br><code>SELECT datname, oid FROM pg_database WHERE datname = 'postgres';</code><br><br>Находим OID табличного пространства<br><br><code>SELECT spcname, oid from pg_tablespace WHERE spcname = 'pg_default';</code><br><br>Находим текущий WAL LSN<br><br><code>SELECT pg_current_wal_lsn();</code><br><br>Создаем новую таблицу<br><br><code>CREATE TABLE abc(a VARCHAR(10));</code><br><br>Находим имя файла, созданного новой таблицей<br><br><code>SELECT pg_relation_filepath('abc');</code><br><br>Теперь мы вставляем новую строку во вновь созданную таблицу<br><br><code>INSERT INTO abc VALUES('pkn');</code><br><br>Теперь мы выходим из клиента psql, чтобы запустить утилиту <code>pg_waldump</code>.<br><br><code>\q</code><br><br>Мы проверяем запись WAL, созданную оператором CREATE TABLE в WAL, используя <code>pg_waldump</code><br><br><code>/usr/lib/postgresql/12/bin/pg_waldump --path=/var/lib/postgresql/12/main/pg_wal/ --rmgr=Storage --start=0/1600000 | grep CREATE &gt;1.txt</code></p>
   <p><code>cat 1.txt</code></p>
   <p><br>Проверяем запись WAL, созданную оператором INSERT в WALL<br><br><code>/usr/lib/postgresql/12/bin/pg_waldump --path=/var/lib/postgresql/12/main/pg_wal/ --rmgr=Heap --start=0/1600000 | grep INSERT+INIT &gt; 1.txt</code></p>
   <p><code>cat 1.txt</code></p>
   <h4>Непрерывное архивирование WAL</h4>
   <p>Копирование файлов WAL по мере их создания в любое место, кроме подкаталога pg_wall, с целью их архивирования называется архивированием WAL. Для архивирования скрипт, предоставленный пользователем, вызывается PostgreSQL каждый раз при создании файла WAL. Сценарий может использовать команду scp для копирования файла в одно или несколько мест. Местоположение может быть монтированием NFS. После архивации файлы сегментов WAL можно использовать для восстановления базы данных на любой указанный момент времени.</p>
   <h4>Репликация на основе доставки журналов: уровень файла</h4>
   <p>Доставка журналов — это процесс копирования файлов журналов на другой сервер PostgreSQL с целью создания другого резервного сервера путем воспроизведения файлов WAL. Этот сервер настроен на работу в режиме восстановления. Единственной целью этого сервера является применение любых новых файлов WAL по мере их поступления. Затем этот второй сервер становится горячей резервной копией основного сервера PostgreSQL, также называемого резервным. Резервный сервер также можно настроить как реплику чтения, где он также может обслуживать запросы только для чтения. Это называется горячим резервом.</p>
   <h4>Репликация на основе доставки журналов: блочный уровень</h4>
   <p>Потоковая репликация улучшает процесс доставки журналов. Вместо ожидания переключения WAL записи отправляются по мере их создания, что сокращает задержку репликации. Второе улучшение заключается в том, что резервный сервер будет подключаться к основному серверу по сети с использованием протокола репликации. Затем первичный сервер может отправлять записи WAL непосредственно через это соединение, не полагаясь на сценарии, предоставленные конечным пользователем.</p>
   <h4>Как долго основной сервер должен хранить файлы сегментов WAL?</h4>
   <p>Без каких-либо клиентов потоковой репликации сервер может отбросить/переработать файл сегмента WAL после того, как сценарий архивации сообщит об успешном выполнении (если только они не требуются для восстановления после сбоя). Однако при наличии резервных клиентов возникает проблема: сервер должен хранить файлы WAL до тех пор, пока в них нуждается самый медленный резервный клиент. Если резервный сервер, который был отключен на некоторое время, снова подключается к сети и запрашивает у основного файл WAL, которого у основного больше нет, то репликация завершается с ошибкой, подобной:</p>
   <p><code>ERROR: requested WAL segment 00000001000000010000002D has already been removed</code></p>
   <p>Таким образом, первичный сервер должен отслеживать, насколько он отстает от резервного и не удалять/не перерабатывать файлы WAL, которые все еще нужны резервным серверам. Эта функция обеспечивается через слоты репликации. Каждый слот репликации имеет имя, которое используется для идентификации слота. Каждый слот связан с:</p>
   <ul>
    <li><p>Самым старым файлом сегмента WAL, требуемым потребителем слота. Файлы сегментов WAL более поздние, чем это, не удаляются/не перерабатываются во время контрольных точек.&nbsp;</p></li>
    <li><p>Самым старым идентификатором транзакции, который необходимо сохранить потребителю слота. Строки, необходимые для любых транзакций позже этого, не удаляются очисткой.</p></li>
   </ul>
   <h2>PostgreSQL: логическая репликация</h2>
   <p>Физическая потоковая репликация создает побайтовую реплику первичного сервера только для чтения. Реплика содержит все базы данных, таблицы, роли, табличные пространства и т. д. оригинала. С потоковой репликацией мы получаем все или ничего. Но что, если нам нужна реплика только одной таблицы? Здесь в игру вступает логическое повторение.</p>
   <p>Логическая репликация может воспроизводить операции DML, происходящие в подмножестве таблиц на первичном сервере, на резервном сервере следующим образом:</p>
   <ul>
    <li><p>Логическое декодирование записей WAL.</p></li>
    <li><p>Потоковая передача их на резервный сервер.</p></li>
    <li><p>Применение их к таблице на резервном сервере в правильном порядке транзакций.</p></li>
   </ul>
   <p>Логическая репликация определяет два объекта: издатель (publisher) и подписчик (subscriber).</p>
   <p><strong>Издатель</strong> — это узел, который определяет определенную группу таблиц (называемую публикацией), на которую может подписаться подписчик, создав подписку для получения изменений в этой конкретной группе таблиц.<br><br></p>
   <figure class="full-width ">
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/310/167/678/31016767827be63108433846e70c2bcd.png" width="1600" height="1188" data-src="https://habrastorage.org/getpro/habr/upload_files/310/167/678/31016767827be63108433846e70c2bcd.png">
    <figcaption></figcaption>
   </figure>
   <p>Ниже приведен пример шагов настройки для логической репликации:<br><br>Входим как пользователь postgres<br><br><code>su - postgres</code><br><br>Модифицируем <code>postgresql.conf</code> для сервера издателя</p>
   <pre><code>cat &gt;&gt; /tmp/data_pub/postgresql.conf &lt;&lt;EOF
port = 6432
wal_level = logical
logging_collector = on

EOF</code></pre>
   <p>Запускаем сервер издателя на порту 6432<br><br><code>/usr/lib/postgresql/12/bin/pg_ctl -D /tmp/data_pub start</code><br><br>Запускаем CLI-инструмент psql<br><br><code>/usr/lib/postgresql/12/bin/psql --port=6432 --host=localhost --username=postgres --dbname=postgres<br></code><br>Создаем новую базу<br><br><code>CREATE DATABASE src_db;<br></code><br>Подключаемся к новой базе<br><br><code>\c src_db</code><br><br>Создаем новую таблицу<br><br><code>CREATE TABLE t1 (id integer primary key, val text);</code><br><br>Создаем пользователя репликации<br><br><code>CREATE USER replicant WITH replication;</code><br><br>Мы предоставляем пользователю репликации выбор строк из таблицы t1<br><br><code>GRANT SELECT ON t1 TO replicant;</code><br><br>Вставляем несколько строк в таблицу t1<br><br><code>INSERT INTO t1 (id, val) VALUES (10, 'ten'), (20, 'twenty'), (30, 'thirty');</code><br><br>Создаем публикацию<br><br><code>CREATE PUBLICATION pub1 FOR TABLE t1;</code><br><br><u>В новом терминале:<br></u><br>Мы входим как пользователь postgres<br><br><code>su - postgres</code><br><br>Модифицируем файл <code>postgresql.conf</code> для сервера подписчиков</p>
   <pre><code>cat &gt;&gt; /tmp/data_sub/postgresql.conf &lt;&lt;EOF
port = 7432
logging_collector = on

EOF</code></pre>
   <p>Запускаем сервер подписчик на порту 7432<br><br><code>/usr/lib/postgresql/12/bin/pg_ctl -D /tmp/data_sub start</code><br><br>Запускаем CLI-инструмент psql<br><br><code>/usr/lib/postgresql/12/bin/psql --port=7432 --host=localhost --username=postgres --dbname=postgres</code><br><br>Создаем новую базу<br><br><code>CREATE DATABASE dst_db;<br></code><br>Подключаемся к новой базе<br><br><code>\c dst_db</code><br><br>Создаем таблицу в базе<br><br><code>CREATE TABLE t1 (id integer primary key, val text);</code><br><br>Создаем подписку<br><br><code>CREATE SUBSCRIPTION sub1 CONNECTION 'host=localhost port=6432 dbname=src_db user=replicant' publication pub1;</code><br><br>Проверяем данные в подписанной таблице<br><br><code>SELECT * FROM t1;</code><br><br>Вставляем еще несколько строк в опубликованную таблицу<br><br><code>INSERT INTO t1 (id, val) VALUES (40, 'forty'), (50, 'fifty'), (60, 'sixty');</code><br><br>Проверьте данные в подписанной таблице<br><br><code>SELECT * FROM t1; <br></code></p>
   <p>В качестве заключения приглашаю всех на <a href="https://otus.pw/Zw95t/">бесплатный урок</a>, в рамках которого проанализируем, в каких единицах можно измерять нагрузку. Рассмотрим преимущества и недостатки различных подходов к масштабированию, а также проблемы высоконагруженных проектов.</p>
   <ul>
    <li><p><a href="https://otus.pw/Zw95t/">Зарегистрироваться на бесплатный урок</a></p></li>
   </ul>
   <p></p>
  </div>
 </div>
</div> <!----> <!---->